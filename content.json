{"meta":{"title":"法门扫地僧的一亩三分地的前端开发工程师H5开发HTML5CSSJavascript","subtitle":null,"description":null,"author":"扫地僧","url":"https://lzws0931.cn"},"pages":[{"title":"关于我","date":"2018-03-19T11:07:48.000Z","updated":"2018-03-21T16:35:35.038Z","comments":true,"path":"about/index.html","permalink":"https://lzws0931.cn/about/index.html","excerpt":"","text":"关于我我用了10年的网名和头像【法门扫地僧】嗯呢，我目前属于半个程序员，注意技术点是偏向前端开发，主要开发语言 前端洗剪吹，熟悉使用 HTML、CSS 和javascript等技术。对后端、前端、运营等技能有所了解。 热爱开源项目、热爱新技术、热爱新事物。 关于工作城市：长安 关于学习学海无涯，不要回头。 关于目标 减肥，挣钱，技术牛逼。 关于爱好没有什么嗜好，爱好也不是很广泛，有时候有点宅。 联系我 Email: 58267980@qq.com Blog: www.lzws0931.cn GitHub: 法门扫地僧 WeiBo: 法门扫地僧 博客园: 法门扫地僧"}],"posts":[{"title":"法门扫地僧简历经验分享","slug":"简历经验分享","date":"2018-09-13T14:35:09.000Z","updated":"2018-11-05T08:52:00.389Z","comments":true,"path":"2018/09/13/简历经验分享/","link":"","permalink":"https://lzws0931.cn/2018/09/13/简历经验分享/","excerpt":"","text":"Front-End前端开发工程师面试宝典！ （本文部分有转载，不定期更新！） 前言（README.md）12本仓库是我整理的前端常见面试题，大部分由我整理，其中个别部分参考网上其他资料，感谢！ 本资料仅供大家学习参考使用！欢迎大家Star和提交issues。 NO.1 READMENO.2 简历经验分享NO.3 angular常见问题NO.4 前端面试宝典第一版NO.5 前端笔记版本第二版NO.6 前端笔记版本第三版NO.7 前端笔记版本第四版NO.8 vue常见问题 欢迎大家一起交流提高简历经验分享1、简历的重要性找工作，难吗？并不难，但是简单吗？并不简单，因为面试，从你投递简历的那一刻已经开始了。面对日趋激烈的就业压力,准备就业的你，做好心理准备了吗？找工作之前，我想请问你一句话，如果你是一家公司，你会招聘你这样的人才吗？ 2、言简意赅面试，首先就是要有一个像样的简历，能拿的出手的简历，要让面试官知道你是谁，你来干什么，你能做什么，你能给我带来什么？这是最基本的，除此之外，简历是我们必不可少的，简历，简单的履历。不需要长篇大论，也不要一张纸敷衍了事。找工作！最开始竞争的就是简历！因为你到任何一个招聘单位要做的第一件事情就是要投递简历，而简历就是那些单位了解你的第一扇窗口。因此简历就成了你和单位沟通的第一通道，往往是招聘人员了解你的第一个途径，适度的引起用人单位对你的兴趣才是最重要的。一份好的简历，可以在众多求职简历中脱颖而出，给招聘人员留下深刻的印象，然后决定给你面试通知，它是帮助你应聘成功的敲门砖。 3、基本信息个人信息：根据不同情况，个人信息由必要和可选之分：必有信息：姓名、联系方式（手机、固定电话、Email、邮寄地址）。可选信息：性别、年龄、政治面貌、籍贯、民族、照片等。注意，自己根据自己需求进行填写，比如面试外企，就尽量不用写政治面貌，还有尽量写年龄，而不是写生日或者出生年月日，写年龄是为了面试官的体验，他直观的就能推测你多少岁大学毕业，几年经验，等等，还有手机号码采用344格式：132-1234-1234等等 4、教育经历 教育经历和工作经历还有项目经验一般按照时间逆序的写法来写，也就是说把最近的教育经历写在前面，比如你自考本科，那么把本科写在前面，当然，大专阶段可以写，也可以不写。如果要写的话，时间上需要衔接。最近的学历放在最前面，即如果你现在是即将硕士毕业，那么要先写硕士再写本科。大学以前高中阶段、初中阶段经历一般不写。 ​ 每段教育经历都应有起止日期的时间段，有助于让HR了解你的毕业日期或者看到你接受教育的成长轨迹。学校：便于HR能迅速识别你的学历，如果就读的是名校，校名可能对你应聘有所帮助，这种情况下，建议将学校校名加粗显示。如果你就读的是非名校，则可以不用加粗显示、专业：如果是应聘专业对口的职位，那么专业一定要加粗强调。若你是跨专业求职，有双学位或者有相关的辅修经历，那么辅修的专业要加粗强调。 ​ 如果你的学校是非名校，主专业也与职位要求不对口，且没有学习过相关的课程或者辅修经历，那么在这种严峻的教育硬伤下，你可能需要在简历中将教育背景往下调，弱化教育背景，转而强调其他与职位相关的实习经历或者社会实践经历。总而言之，应根据职位和自身情况做到突出优势，规避劣势。相关课程：不建议写，因为你学过和你会是两个概念，你可以把你的会的东西当做专业技能来展示。 5、工作经历工作经历：一般来说是简历的重点内容，如果有相关著名公司的话，那通过简历筛选的几率很大。因为相关的工作经历最能够体现与职位要求的技能。而对于应届毕业生来说，可以把自己的实习经历写上去，实习经历、兼职经历可以有效地弥补这一软肋。 工作经历一般就是说你在那家公司待了多长时间，什么岗位，你干了那些事情，或者说负责哪方面。 6、项目经验 项目经验：一般来说，项目经历往往反映的是求职者某个方面的实际动手能力、对某个领域或某种技能的掌握程度。一般在应聘IT类职位项目经历的描述是比较重要的。对于面试计算机的人来说，简历中项目的含义一般包含两个层面： （1）相关研究课题项目。课程设计，或者毕业论文都可以，或者你在大学期间实习做的项目都可以展示出来，如果自己做过的项目获得过奖项，那更好了，而毕业论文的内容中一般会有对应的研究背景、相关的调研、实验、数据统计及分析。做课题、写毕业论文的过程就是一个解决问题的过程，在这个过程中，我们必须学会获取大量信息、筛选有用信息，掌握分析问题、解决问题的方法，这样才能完成毕业论文。在这个过程中所锻炼的信息分析处理、某种软件的应用技能、书面表达等能力，也是你的求职砝码，可以在简历中呈现给HR。 而对于有些人没有太多的项目经验，那么你就应该把你自己自学或者做的项目适度的经历去阐述给面试官，面试中甚至可以带上自己的作品或者上次到github，展示给面试官也是很加分的，例如：在公司实习的经历中，曾经有过负责或参与公司某个项目的调研、立项或者实施，自己在项目中扮演着很重要的角色或者做了很重要的工作、贡献，那么可以单独将在这个公司实习的这段项目经历提取出来，重点描写，从而突出自己的相关技能水平。 7、自我评价自我评价，就是简单的夸夸自己，低调的告诉面试官，你很牛逼，但是要适度哦。 8、咋投递捏？招聘条件并非绝对限制，不要被招聘要求上面写到的专业，户口，工作经验或者211,985所吓到，和公司的规定条件不吻合还是有任用的机会的，有些东西往往只是一个限制标准而已，如果职业适性非常相合，也有丰富的经验，出线机会仍是非常浓厚。不管如何，如果你对该公司真的很有兴趣，不妨先试试看。 9、简历写作的原则：​ 1.关键词说话，HR平均浏览一份简历的时间不超过30秒，在这么短的时间内，HR主要是通过查看简历中是否有相关的关键词来进行判断。关键词的作用尤其在网申简历中更为明显。如果你是应聘互联网行业相关度的职位，HR可能会对简历中的“网站”、“流量”、“×××××.com”（网址域名）等关键词比较敏感； ​ 2.行为词说话，在描述过去经历的时候，无论是实习兼职经历还是工作经历，都需要把自己做的事情用清楚详细的、表示动作的词语（即行为词）叙述出来，形式上一般建议采用行为词开头的短句群。同样一段经历，是否掌握行为词的描述方法，其经历描述的效果也大相径庭。 ​ 3.用数字说话，不要说用户访问量大大提高，大大是多大？也不要说网页性能有了显著提高，有多显著？简历里的数字更能凸显个人亮点，吸引HR眼球，比如你自己封装了一个小插件，使你们项目进程提高了一周。 ​ 4.结果说话，想达到一份优秀简历的水平，你必须在简历中学会用客观的结果说话。这也就是在之前介绍工作实习经历描述中提到的“PAR法则”中的“R(Results)”，即结果，一般指业绩、成绩等。我们不仅要在简历中告诉HR，我们做过什么，而且通过描述我们做得怎么样，来向HR证明我们具备相关的素质、能力、经验。 ​ 5.真实性原则，没有必须要捏造一些四级或者六级或者一些证书，实事求是，我们干技术的，是凭借技术来征服的，证书只是锦上添花的事，不要为了提高简历的含金量去弄虚作假，但是我们可以适度的去活学活用，或者借鉴，比如，我面试的时候有人事问我，你大学当过学生会干部吗，我没当过，但是我宿舍哥们当过，那我是不是可以把他的经历说一下，这不叫欺骗，这是叫适度包装。 ​ 6.独特性原则，面试之前，我们应该考虑一下，我们比别人的优势在那里，同一个岗位，凭什么要你，不要别人？对于HR而言，对于简历中不同的履历，技能都能让HR眼前一亮，而这些比其他都东西更能让面试官记住你。 ​ 还有一点需要注意，创业经历，一般请适度表达，因为有时候会给面试官一些你不太稳定的感觉，所以问道这方面问题，请慎重回答，要让面试官知道你是一个安分守己的好员工。 10、优秀简历的特点言简意赅，强调成功的经验 简历内容要真实，重点突出 传递有效信息，使用有影响力词汇 突出自己技能，适当引用专业术语 11、简历和求职信有些公司比较喜欢自荐，这个时候最好写个求职信，求职信就是你找工作的时候，写给这家公司人事部对这个公司和这个岗位的一些看法，但是切忌指手画脚。一般自荐信建议手写，一百来字就可以，而在这百字之间你就要强调你很适合这个岗位。 求职信是针对个人来写的，简历是针对岗位来写的，而求职信更要突出个人的特征和求职意向，打动招聘者的心，求职信带有私人信件的性质，应有一定的感情色彩，行文要流畅，晓之以理，动之以情，既有说服力，又有感染力，让人相信你的资质，人品和能力。 12、求职信一般由三部分组成：开头、主体与结尾。 1、开头部分。包括称呼与引言。称呼一般是姓加职衔或官衔。一般以其高者尊者称呼。 2、主体部分。是求职信的重点，要简洁而有针对性地概述自己简历的内容。要突出自己的长处和优势，使对方觉得你的各方面情况与招聘条件相一致，与有关职位要求、特点相吻合。写作的具体内容，有关专家概括为如下5个方面： (1)简述你的主要求职资格、工作经验、参加过的有关社会活动、个人的兴趣和爱好。 (2)表述你具备的教育资历、工作经验和个人素质。①谈谈你为这项目标工作做了哪些教育准备，即你所受的哪些教育与目标工作的任职资格有关;②谈谈你过去所受的专业训练和工作经验以及和目标工作的相关性;③以事实证明你具有目标工作要求的个人素质;④举例说明你具有对做好目标工作的其他有利条件。 (3)要以成熟而务实的语气叙述。①切勿夸大其辞、自吹自擂;②提供你在学业上和工作中取得的重要成就，来证明所声言的资格和能力;③谈论一下目标单位的有关情况，表明你对其已有了解，并愿意为之效劳。 (4)重申你的求职动机，简要说明你对未来的设想。 (5)提示说明你在求职信后的有关附录或附件。 3、结语部分。要令人回味而记忆深刻。要把你想得到工作的迫切心情表达出来，请用人单位能尽快答复你，以恰当恳切的方式请求安排面谈。内容要具体简明，语气要热情，诚恳，有礼貌，别忘了向对方表示感谢。 求职信应该体现出自己的特色，在遵循上述一般原则的前提下，要开动脑筋，以自己的方式来赢得招聘者的青睐。​​ 求职信写作要求 求职信文字一定要简洁，字数最好不要超过1000字，它一般由几部分组成： 1)你所申请的职位和招聘信息来源; 2)表述你对该职位产生浓厚兴趣，并说明这种兴趣与你的理想追求或专长有关; 3)与申请职位有关的资历和经验和成绩都是非常重要的证明材料，说明你适合这个职位的原因; 4)表示如能得偿所愿，自信必能胜任此项工作; 5)提醒收信人留意你附呈的个人简历，并请求对方作进一步回应，如及早答复、予以安排面试等。 求职信的第一句话是最重要的，也是最难写的。其实有许多可取的写法，你可以说明是从什么渠道得知公司招聘信息，也可以叙述自己最有利的条件，不过最不稳妥的办法是参照广告的内容作自我介绍。第一句话(不包括称呼)的作用有二：一是吸引对方阅读你的信件;二是引导对方自然而然地进入你所突出的正题而不感到突然。 归纳起来，求职信的第一句话有以下几种形式： 1)概述式。用一句话概括你具备的最重要的求职资格和工作能力。 2)提名式。提及一为建议你到用人单位求职且为用人单位所熟悉和尊崇的人(记住连名带写上，后面可称呼其职衔或官衔，也可以称“先生”或“女士”)。 3)提问式。针对用人单位的需求和目标，提出一个设问，然后表示你真诚希望自己能够帮助他们实现目标。 4)赞扬式。赞扬用人单位近期取得的显著成就或发生的明显变化，然后表示渴望为其效力。但记住语气不要过度热情。 5)应征式。说明你通过什么途径看到用人单位的招聘广告，并肯定自己的条件基本满足广告提出的要求。 6)独创式。用一个新奇的、能表现你在某些方面才华的句子开头，但申请的职位必须是那种需要丰富想像力的类型，如广告文案、平面设计、装潢设计等。 13、如何让你的简历更加精彩1.回顾过去，表面目标，职业OR成就，还有最重要的事简历的格式，有些人连行间距字间距都不会调整。 2.放大你的卖点，在简历中需要求职意向要避免含糊笼统、毫无针对性。 在我们的求职意向中，我们应该体现出我们能为雇主做些什么，而不是雇主能给我们什么。 14、提高网申简历的投递技巧1.采用行业招聘网站求职 2.简历要与大公司沾边 3.经常刷新简历 4.不要只应聘最近三天的职位 5.让你的邮件永远在最前面 6.新颖的邮件标题 7.自己要学会让简历与职位匹配（不要太在乎对方职位要求的描述，很多职位描述只是写写，连经理都不知道要招什么样的人，如果你看到对方职位要求本科，你是专科就不敢投递简历，那就失去机会了。如果你看到对方要求有5年经验，你只有3年经验，你也不敢投，那完全没有必要。因为人事经理们对职位的描述只是例行公事随便写写而已，你千万不要当真！） 15、简历成功的要素1.态度端正，当你填写个人简历时，选一个可以静下心来的场所，梳理好自己的头绪：你要什么样的工作？你有什么样的优势？你有什么样的发展计划？而不是不经过思考简单将自己的经历和信息全部填进各种表格，让HR来判断你能做什么。你需要思考，提炼和总结，给出一个肯定和结论性的答案。像高考作文一样慎重对待你的简历，HR一定感受得到。 2.强调技能，把你的专业技能要表现出来，你会什么，用过什么，用什么技术点做过那些项目？ 16、简历中避免的错误1.打字或者语法错误，或者专业术语运用不当。 2.缺乏细节 3.没有用心，网上随便找一个简历改个名字就投递。 4.缺乏吸引的动词。 5.简历模版视觉上太花哨或者太low 6.联系方式错误，如果你的简历联系方式都错误，那你在工作种肯定也细心不到哪里去。 17、简历整体1234561.写好的简历，和同桌相互交换，检查已成文的个人简历，绝对不能出现错别字、语法和标点符号方面的低级错误。2.个人简历字体最好采用宋体或微软雅黑,尽量不要用花里呼哨的艺术字体和彩色字, 排版要简洁明快，切忌标新立异。3.简历一定要言简意赅，不用的信息不要写，而对你申请的工作有意义的经历和经验绝不能漏掉。4.你的个人简历越短越好（2-3页，最后一张不要弄个半页），招聘人不愿意花太多的时间阅读一篇冗长空洞的个人简历。5.你的个人经历顺序应该从现在开始倒过去叙诉，这样可使招聘单位在最短的时间内了解你最近的经历。6.在结构严谨的前提下，要使你的个人简历富有创造性，使阅读者能产生很强的阅读兴趣。 18、前端的职业技能展示（其实，你可以去招聘平台看公司的招聘要求，他要求会什么，你把自己会的技能点写上即可。） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151首先，你得精通这些技术单词的拼写吧！！！格式要统一，细节决定成败JavaScript、HTML、CSS、、jQuery、Zepto.jsHTML5、CSS3、移动Web、Ajax、BootStrap、LESS、SASS、CanvasJSON、JSONPRequireJS、SeaJSGrunt、GulpAngular.js、React.jsNode.js______________1.git属于分布式版本控制系统，是用于方便合作和版本控制的2.sublime是编辑器，类似于nodepad++,ultraEdit，是增强版的文本编辑器。3.sass和compass是css预处理器，可以变量、嵌套、混入(Mixin)、继承、导入、函数和操作符等，使css更具模块化和更加方便，基于ruby4.node是javascript的运行环境，基于google的V8 javascript引擎写的，可以将javascript扩展到服务器端。5.npm是包管理工具，类似的有bower，homebrew等（Bower – Js库依赖管理工具。当你需要jquery时，不需要手动下载，只需要执行 bower install jquery，自动安装依赖组件、组件依赖检测、版本兼容自动检测）6.gulp是自动化构建工具______________1.熟练使用HTML/CSS，能够书写符合W3C标准的页面，能够兼容主流浏览器，可以精确还原设计图.2.熟练使用JavaScript，可以脱离类库，用原生JS代码编写常见的网页特效，熟知DOM结构，可以实现代码优化，书写高质量代码3.熟练使用HTML5和CSS3相关技术开发手机等移动端和PC端前端应用;4.熟练使用jQuery库，了解Bootstrap进行网站开发,5.熟练使用zepto.js进行移动web开发；6.对Ajax交互、json和Jsonp交互有较好的理解和应用，了解http协议7.能够使用面向对象封装自己的框架，实现常用的功能，了解组件化开发，设计模式 8.熟练使用git、grunt/gulp对代码进行管理和构建，npm、bower等依赖管理工具；9.熟练使用angular熟悉MVC/MVVM框架模式；可以运用seajs，requirejs进行项目开发10.熟练使用ionic 进行移动app开发；11.可以运用seajs，requirejs进行项目开发，了解less、sass、React Native、node.js____________1.熟练使用HTML、CSS构建页面，有良好的代码编写能力，能精准还原符合3WC标准的页面。2.熟练使用JQuery和原生的JavaScript实现页面交互功能。3.掌握Ajax，能够实现前后端数据的交互，实现页面的异步加载。4.掌握并能够运用HTML5+CSS3的新功能。5.理解并掌握DOM、BOM、XML、JSON等。6.了解面向对象思想、能进行实际运用。7.了解bootstrap，能够用其搭建页面，实现响应式网站开发。8.了解node.js、angular.js，了解MVC思想。9.了解git、glup、npm等管理工具的使用方法。 ————————————熟练掌握html、div+css布局，手写符合w3c标准规范的页面代码；熟练javaScript，掌握常用的插件以提高工作效率。可根据项目需求用原生js写针对特定问题的库。熟练运用html5、css3进行移动端的页面开发。熟悉运用ajax技术处理后台数据，熟悉浏览器和服务器交互机制，依据接口文档与后台进行交互。熟悉js面向对象中的继承、封装、单体模式、工厂模式、原型模式等，坚持降低程序耦合度、提高代码复用性的设计理念，使代码高度模块化。能使用jQuery,bootstrap等框架实现轮播图等特效功能的加载机制，了解angularJS的相关应用;熟练使用sublime ，WebstromPhotoshop等开发工具————————————1.熟悉使用Fireworks、photoShop等软件切图并使用html与css精准还原设计稿并保持良好结构。2.熟悉javaScript并封装过小型类jQuery框架。3.可使用CSS3与HTML5实现3D旋转以及炫酷动画效果、熟悉canvas开发，能独立处理主流浏览器的兼容性问题。4.熟练使用JavaScript、jQuery，可以脱离类库，用原生JS代码编写常见的网页特效，并熟知DOM结构5.能熟练运用Ajax和模板引擎与后台进行数据交互，可利用JSONP实现跨域调取各个开放平台提供的API。6.有Bootstrap，requireJs，angularJs等前端主流框架的使用经验。7.熟悉NODE.js网络编程、MVC框架、MVVM框架，理解http基本原理，熟悉使用npm命令行工具及包管理工具开发项目并发布到npm生态圈。8.了解PHP基本API的使用，能与后台人员友好的交流。————————————1、 精通HTML和CSS ,能够书写语义合理、结构清晰、易维护的页面结构,高度还原设计图;2、 熟悉原生JavaScript ,完成页面交互和功能的实现 ,同时对jQuery能够熟练使用;3、 熟练使用HTML5和CSS3技术,熟悉bootstrap框架能够编写移动端网页制作和响应式布局 ,实现一个页面适配多种终端;4、 熟练掌握HTTP协议相关知识 、Ajax、php等相关技术,能够完成对页面的渲染,与后台开发人员一起完成交互程序;5、 熟悉面向对象编程、DOM编程;6、 对前端模块化开发有一定的了解 ,了解前端MVC框架、AngularJs;7、 可使用git管理代码;————————————1、掌握面向对象的特性，了解闭包、原型链、this等概念。2、掌握框架封装原理，能够通过原生的方式，对框架实现的基本理念有自己的理解；深刻理解移动App的开发模式和技术选型3、能够熟练使用前端工作流工具；4、理解MVC/MVVM设计思想，熟悉移动App的开发模式，能够基于流行的技术进行前端App开发；5、熟悉nodejs的全栈式解决方案，能够根据业务需求在众多框架中进行技术选型；6、熟悉软件开发中整个项目的生命周期，了解主流的后台开发技术以及相应的前后端协作方式。7、掌握前端MVC/MVVM框架实现机制，通过angularjs的实践深刻理解MVC的开发模式，理解双向数据绑定等相关概念。8、掌握移动端混合开发模式，通过ionic/angular的结合，理解使用html5css3/js实现APP开发的整体流程和实现机制。9、掌握移动端ReactNative的开发模式，通过实例展示框架在app开发上的独特之处。————————————1. 熟练使用HTML/CSS，能够书写符合W3C标准的页面，能够兼容主流浏览器，可以精确还原设计图；2. 熟悉W3C标准与ES规范，编写易读、易维护、高质量、高效率的代码；3. 熟练使用JavaScript，可以脱离类库，用原生JS代码编写常见的网页特效，熟知DOM结构，可以实现代码优化，书写高质量代码； 4. 掌握jquery、zepto库的使用；5. 熟悉Angular 框架，熟悉MVC/MVVM框架模式； 6. 熟悉AJAX、JSON数据处理机制，了解前后端的交互；7. 擅长HTML5，CSS3方面的应用，熟悉移动端开发，对手机终端的适配问题可以解决；8. 理解MVC/MVVM设计思想 ，了解HTTP网络通信协议；9. 热衷于web开发技术，对node有一定的使用经验；10.熟练使用git、github/gutlub对代码进行管理和构建，npm、bower等依赖管理工具；11.能够使用面向对象封装自己的框架，实现常用的功能，了解组件化开发———————————1、熟练掌握HTML、CSS等网页布局技术，能熟练运用DIV+CSS来制作静态页面。2、熟练掌握JavaScript技术，能用原生js封装特定功能模块。3、熟练掌握jQuery库，能够熟练运用jQuery API实现网页特效。4、熟练运用CSS3、HTML5制作炫酷的页面特效。5、掌握angular等流行框架的使用，充分了解了angularjs的双向数据绑定，路由，模块化，依赖注入等功能。6、熟悉ajax、Json实现页面的异步加载及前后端数据处理机制，了解前后端数据的交互机制能够熟练使用bootstrap模板，制作响应式网页。7、熟悉了解MVC的设计模式，了解HTTP网络通信协议。8、热衷于前端开发工作，对nodejs有一定的使用与了解。————————————1.熟练使用HTML,CSS构建页面，有良好的代码编写习惯2.理解并掌握DOM,BOM,XML,JSON3.熟练使用JavaScript实现动态网页的交互，熟练jQuery框架完成各项工作4.掌握Ajax技术，能够实现前后端的数据交互，实现页面的异步加载5.熟练运用CSS3的新特性，熟悉HTML5的新功能6.了解面向对象思想，并且能实际运用7.精通bootstrap，能够搭建页面实现响应式网站开发8.精通angularJS框架，了解MVC思想，实现todo单页面应用案例9.了解git gulp npm等管理工具的使用——————————————————1. 精通html,css,可合理利用语义化标签搭建结构清晰，易于维护的页面；2. 能够处理主流浏览器兼容性问题3. 熟练掌握原生JavaScript，能够熟练进行页面交互功能实现。4. 掌握 webstroms, sublime, photoshop， fireworks等开发软件的使用； 5. 熟练html5与css3 ;6. 熟练掌握Ajax，json等技术，实现与后台交互，实现页面异步数据加载；7. 熟悉面向对象编程,可进行常用功能插件开发；8. 了解git、npm等管理工具的使用方法;9. 拥有较强的学习能力和理解能力，能够独立解决和分析问题————————————————1.熟练使用html，css构建静态页面，有良好的代码注释和编写习惯2.熟练使用JQuery和原生Javascript实现页面特效和交互功能3.掌握Ajax，能实现前后端数据的交互，实现页面数据的异步加载4.掌握并能运用html5和CSS3的新功能5.了解面向对象思想，能运用于实际编程中6.了解bootstrap，能够用其搭建响应式网站7.了解git，gulp管理工具的使用8.了解nodejs后端基础，了解MVC思想，实现增删改查的网页应用9.掌握Photoshop使用，能完成成简单的设计任务————————————————————1.熟练使用HTML/CSS制作目标网页，并能做好主流浏览器的兼容性，能够使用HTML5和CSS3开发移动端、PC端页面应用；2.熟练使用JavaScript，可脱离类库，编写原生JS代码实现网页特效，并能进行代码优化；3.熟练运用jQuery实现常用网页特效，掌握Bootstrap进行响应式网站开发，了解Zepto.js进行移动web开发；4.理解并能应用Ajax交互，以及JSON/JSONP以及http协议；5.能够使用面向对象封装自己的框架，实现常用功能，了解组件化开发；6.能够使用git/gulp对团队代码进行管理和构建，了解npm、bower等包依赖管理工具；7.熟练使用angular开发，熟悉MVC框架模式，了解Node.js开发；——————————————————1.熟练DIV+CSS网页制作技术，熟悉W3C各标准，能根据设计图制作符规范的静态页面。2.熟悉jQuery框架，熟练掌握JQuery、DOM操作及事件处理，了解动态绑定事件的原理。3.熟练掌握HTML5+CSS3的新特性，并熟练应用到移动页面开发中以及能解决大部分浏览器兼容问题。4.熟练CSS3动画、过渡效果展示以及Cavas动画制作并实现页面交互。5.有基于Ajax的应用开发经验，DOM、BOM、JSON等相关技术，能与后台开发协作，完成操作交互、数据展示。6.能够使用Zepto、iScroll swape等技术构建页,了解面向对象编程思想。7.熟悉弹性布局及响应式布局，自适应，能有效解决和改善各种移动端的适配问题。也了解一些后端语言PHP、sql8.了解一些前端框架如：Bootstrap、Zepto、Less、流行框架等。9.了解模块化开发思想可用node.js，Seajs、Requirejs及Angularjs进行简单的模块化开发。 后期有时间了会持续细化和整理，面试的经验分享敬请期待、 备注： 1前端的路上我们一起携手共进！如果转载，请标注本链接地址。 ​MIT ©杨方涛 Email:58267980@qq.com","categories":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://lzws0931.cn/categories/面试宝典/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://lzws0931.cn/tags/面试/"}]},{"title":"付费_极客时间one","slug":"法门扫地僧付费_极客时间one","date":"2018-08-07T11:43:32.000Z","updated":"2018-11-05T09:00:10.551Z","comments":true,"path":"2018/08/07/法门扫地僧付费_极客时间one/","link":"","permalink":"https://lzws0931.cn/2018/08/07/法门扫地僧付费_极客时间one/","excerpt":"","text":"极客时间_one本文来自极客时间个人记录笔记。 任何工作不能是“我的部分做完了，其他的事情我不管”… 验证码有可能是个有效设计，但是他并不是一个好设计，因为挡住机器这件事本应该是服务提供方的责任，而服务方却将其成本转嫁给了用户 未完成的功能键要想加入一个新的功能，为了测试用户是否真的想对这个功能感兴趣，暂时不设置功能，而是通过用户的点击率看来验证用户的动机和需求。。 用最少的资源给你的产品试试水。","categories":[{"name":"技术","slug":"技术","permalink":"https://lzws0931.cn/categories/技术/"}],"tags":[{"name":"产品","slug":"产品","permalink":"https://lzws0931.cn/tags/产品/"}]},{"title":"‘一页尽览’体验第二版","slug":"‘一页尽览’体验第二版本","date":"2018-07-22T06:03:32.000Z","updated":"2018-07-22T06:10:24.284Z","comments":true,"path":"2018/07/22/‘一页尽览’体验第二版本/","link":"","permalink":"https://lzws0931.cn/2018/07/22/‘一页尽览’体验第二版本/","excerpt":"","text":"腾讯‘一页尽览’产品体验心得第二版因为自己是通过word提交给腾讯的产品的，所以没有写md文档，有点小麻烦，所以把内容通过预览截图的方式上次到了七牛云。","categories":[{"name":"技术","slug":"技术","permalink":"https://lzws0931.cn/categories/技术/"}],"tags":[{"name":"产品","slug":"产品","permalink":"https://lzws0931.cn/tags/产品/"}]},{"title":"‘一页尽览’产品体验","slug":"腾讯‘一页尽览’产品体验","date":"2018-07-17T02:26:32.000Z","updated":"2018-11-05T09:01:11.047Z","comments":true,"path":"2018/07/17/腾讯‘一页尽览’产品体验/","link":"","permalink":"https://lzws0931.cn/2018/07/17/腾讯‘一页尽览’产品体验/","excerpt":"","text":"腾讯‘一页尽览’产品体验心得因为自己是通过word提交给腾讯的产品的，所以没有写md文档，有点小麻烦，所以把内容通过预览截图的方式上次到了七牛云。","categories":[{"name":"技术","slug":"技术","permalink":"https://lzws0931.cn/categories/技术/"}],"tags":[{"name":"产品","slug":"产品","permalink":"https://lzws0931.cn/tags/产品/"}]},{"title":"浏览器渲染原理(本文转载)","slug":"浏览器渲染原理","date":"2018-05-10T05:51:00.000Z","updated":"2018-05-10T06:13:19.873Z","comments":true,"path":"2018/05/10/浏览器渲染原理/","link":"","permalink":"https://lzws0931.cn/2018/05/10/浏览器渲染原理/","excerpt":"","text":"从输入 URL 到页面加载完成发生了什么事DNS解析 TCP连接 发送HTTP请求 服务器处理请求并返回HTTP报文 浏览器解析渲染页面 浏览器应该有的功能网络;资源管理;网页浏览;多页面管理;插件与管理;账户和同步;安全机制;开发者工具 浏览器的主要功能总结起来就是一句话: 将用户输入的url转变成可视化的图像 浏览器的内核(渲染引擎)在浏览器中有一个最重要的模块，它主要的作用是将页面转变为可视化的图像结果。这个模块就是浏览器内核，通常它也被称为渲染引擎。 IE-----&gt;Trident Safari------&gt;WebKit Chrome;Opera-----&gt;Blink Firefox------&gt;Gecko 渲染引擎一个渲染引擎主要包括：HTML解析器，CSS解析器，布局layout模块，javascript引擎，绘图模块 渲染过程1.网页URL到构建DOM树的整个过程 1) 当用户输入URL的时候，Webkit调用资源加载器加载URL对应的网页 2) 加载器依赖网络模块建立连接，发送请求并接收答复 3) Webkit接收到各种网页或者资源的数据，其中某些资源可能是同步的或异步获取的 4) 网页被交给HTML解析器转变一系列的词语（Token） 5) 解析器根据词语构建节点（node），形成DOM树 6) 如果节点需要依赖于其他资源， 例如js css 图片 视频等，调用资源加载器来加载他们，但是这些都是异步的， 不会阻碍dom树的继续创建；顺序执行 并发加载 如果资源是css的话 调用CSS解析器解释将CSS解释成内部表示结构(CSSDOM) 如果资源是javascript的话 调用Javascript引擎解释并执行， 7）阻塞 css阻塞 css 在head中通过link的形式引入会阻塞页面的渲染 为什么？ 避免闪屏现象 js阻塞 直接引入的js会阻塞页面的渲染 为什么？ Javascript代码可能会修改DOM树的结构 8) 预解析 WebKit 和 Firefox 都进行了这项优化。在执行js脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理； 预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。 2.从DOM树到可视化图像 1) CSS文件被CSS解析器解释成内部表示结构(CSSDOM) 2) CSS解析器工作完成之后，在DOM树上附加解释后的样式信息，这就是RenderObject树 3) RenderObject在创建的同时，Webkit会根据网页的结构创建RenderLayer，同时构建一个绘图上下文 4) 根据绘图上下文生成最终的图像（这一过程需要依赖图形库） 3.上面介绍的是一个完整的渲染过程，但现代网页很多都是动态的，这意味着在渲染完成之后，由于网页的动画或者用户的交互， 浏览器其实一直在不停地重复执行渲染过程。（重绘重排），以上的数字表示的是基本顺序，这不是严格一致的， 这个过程可能重复也可能交叉。浏览器是一个边解析边渲染的过程 css图层浏览器在渲染一个页面时，会将页面分为很多个图层，图层有大有小，每个图层上有一个或多个节点。 在渲染DOM的时候，浏览器所做的工作实际上是： 1. 获取DOM后分割为多个图层 2. 对每个图层的节点计算样式结果 （Recalculate style--样式重计算） 3. 为每个节点生成图形和位置 （Layout--重排,回流） 4. 将每个节点绘制填充到图层位图中 （Paint--重绘） 5. 图层作为纹理上传至GPU 6. 符合多个图层到页面上生成最终屏幕图像 （Composite Layers--图层重组） 图层创建的条件Chrome中满足以下任意情况就会创建图层： 1. 拥有具有3D变换的CSS属性 2. 使用加速视频解码的&lt;video&gt;节点 3. &lt;canvas&gt;节点 4. CSS3动画的节点 5. 拥有CSS加速属性的元素(will-change) 6. 元素有一个z-index较低且包含一个复合层的兄弟元素（换句话说就是该元素在复合层上面渲染） 重绘(Repaint)重绘是一个元素外观的改变所触发的浏览器行为，例如改变outline、背景色等属性。浏览器会根据元素的新属性重新绘制， 使元素呈现新的外观。重绘不会带来重新布局，所以并不一定伴随重排。 需要注意的是，如果图层中某个元素需要重绘，那么整个图层都需要重绘。 比如一个图层包含很多节点，其中有个gif图，gif图的每一帧，都会重回整个图层的其他节点，然后生成最终的图层位图。 所以这需要通过特殊的方式来强制gif图属于自己一个图层（translateZ(0)或者translate3d(0,0,0) CSS3的动画也是一样（好在绝大部分情况浏览器自己会为CSS3动画的节点创建图层） 重排(Reflow 回流)渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排 &quot;重绘&quot;不一定需要&quot;重排&quot;，比如改变某个网页元素的颜色，就只会触发&quot;重绘&quot;，不会触发&quot;重排&quot;，因为布局没有改变。 但是，&quot;重排&quot;必然导致&quot;重绘&quot;，比如改变一个网页元素的位置，就会同时触发&quot;重排&quot;和&quot;重绘&quot;，因为布局改变了。 触发重绘的属性* color * background * outline-color * border-style * background-image * outline * border-radius * background-position * outline-style * visibility * background-repeat * outline-width * text-decoration * background-size * box-shadow 触发重排(回流)的属性盒子模型相关属性会触发重布局 定位属性及浮动也会触发重布局： 改变节点内部文字结构也会触发重布局： * width * top * text-align * height * bottom * overflow-y * padding * left * font-weight * margin * right * overflow * display * position * font-family * border-width * float * line-height * border * clear * vertival-align * min-height * white-space 常见的触发重排的操作Reflow 的成本比 Repaint 的成本高得多的多。DOM Tree 里的每个结点都会有 reflow 方法， 一个结点的 reflow 很有可能导致子结点，甚至父点以及同级结点的 reflow。在一些高性能的电脑上也许还没什么， 但是如果 reflow 发生在手机上，那么这个过程是非常痛苦和耗电的。 所以，下面这些动作有很大可能会是成本比较高的。 当你增加、删除、修改 DOM 结点时，会导致 Reflow , Repaint。 当你移动 DOM 的位置 当你修改 CSS 样式的时候。 当你 Resize 窗口的时候（移动端没有这个问题） 当你修改网页的默认字体时。 获取某些属性时(width,height...) 注：display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发生位置变化。 优化如果我们需要使得动画或其他节点渲染的性能提高，需要做的就是减少浏览器在运行时所需要做的工作（减少1234中的步骤） 1. 计算需要被加载到节点上的样式结果（Recalculate style--样式重计算） 2. 为每个节点生成图形和位置（Layout--回流和重布局） 3. 将每个节点填充到图层中（Paint Setup和Paint--重绘） 4. 组合图层到页面上（Composite Layers--图层重组） 1.元素位置移动变换时尽量使用CSS3的transform来代替对top left等的操作 变换（transform）和透明度（opacity）的改变仅仅影响图层的组合 2.使用opacity来代替visibility 透明度竟然不会触发重绘？ 透明度的改变时，GPU在绘画时只是简单的降低之前已经画好的纹理的alpha值来达到效果，并不需要整体的重绘。 不过这个前提是这个被修改opacity本身必须是一个图层，如果图层下还有其他节点，GPU也会将他们透明化 3.不要使用table布局 4.将多次改变样式属性的操作合并成一次操作 不要一条一条地修改DOM的样式，预先定义好class，然后修改DOM的className 5.将DOM离线后再修改 由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。 如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。 6.利用文档碎片 7.不要把某些DOM节点的属性值放在一个循环里当成循环的变量 当你请求向浏览器请求一些 style信息的时候，就会让浏览器flush队列，比如： 1. offsetTop, offsetLeft, offsetWidth, offsetHeight 2. scrollTop/Left/Width/Height 3. clientTop/Left/Width/Height 4. width,height 当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要flush队列， 因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近发生或改变的布局信息无关， 浏览器都会强行刷新渲染队列。 8.动画实现过程中，启用GPU硬件加速 9.为动画元素新建图层,提高动画元素的z-index","categories":[{"name":"技术","slug":"技术","permalink":"https://lzws0931.cn/categories/技术/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://lzws0931.cn/tags/浏览器/"}]},{"title":"成都三日游","slug":"法门扫地僧成都三日游","date":"2018-04-26T05:21:00.000Z","updated":"2018-04-26T07:15:22.670Z","comments":true,"path":"2018/04/26/法门扫地僧成都三日游/","link":"","permalink":"https://lzws0931.cn/2018/04/26/法门扫地僧成都三日游/","excerpt":"","text":"我一个人去成都逛了一圈123嗯，带的班结课了。不到一周，就业率70%，挺好的。都是大家努力的成果。希望最后大家都能百分百就业吧，拿到自己期望的工资。不过，有好些人上班了，也有不少压力，感觉掌握的东西还是比较欠缺，知识面窄，还有就是掌握的深度不够到位，慢慢熬吧。都一样，知识永远也学不完呀。趁着周末没事干，我觉得来一场说走就走的旅行，哈哈，成都一圈。散散心。 晒一波照片。哈哈，其实我拍了好多，这里只是晒部分，因为之前有次上次的照片看不到了，估计是之前的图床发生故障了。所以以后的照片上传到七牛云上去了。自己摸索的。啦啦 成都一个小哥哥让我很暖4月21日，成都，小雨因为雨不是很大，我就没打伞，有时候还是很享受在雨中漫步的感觉。然后，过马路，等红灯，旁边一个小哥哥。穿着西装，长的有点像最强大脑里面的王峰。看我没打伞，然后把伞往我这边靠了一下，说“躲躲雨”瞬间，我就被暖到了。陌生的城市，一个小小的举动。一看就是有素养的人然后他在回微信。过了马路走了一段路，我说我朝这边走，他说，那不好意思了。不能帮你了。我说谢谢。 感谢，一个人让我改变了一座城的看法。","categories":[{"name":"旅游","slug":"旅游","permalink":"https://lzws0931.cn/categories/旅游/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://lzws0931.cn/tags/生活/"}]},{"title":"路径并不像你想的那么简单","slug":"路径并不像你想的那么简单","date":"2018-04-08T06:21:00.000Z","updated":"2018-04-08T06:51:07.539Z","comments":true,"path":"2018/04/08/路径并不像你想的那么简单/","link":"","permalink":"https://lzws0931.cn/2018/04/08/路径并不像你想的那么简单/","excerpt":"","text":"相对路径，绝对路径？ 之前在通过demo学习相对路径和绝对路径的时候，感觉路径是很简单的知识点。相对，不就是相对于某一个东西而言的位置，绝对，不就是写死的路径么。可是，当把这些点放在项目里面的时候我才绝的并不简单。 相对路径-以引用文件之网页所在位置为参考基础，而建立出的目录路径。因此，当保存于不同目录的网页引用同一个文件时，所使用的路径将不相同，故称之为相对。 绝对路径-以Web站点根目录为参考基础的目录路径。之所以称为绝对，意指当所有网页引用同一个文件时，所使用的路径都是一样的。 每个文件／文件夹都只有一个绝对路径，无数个相对路径有一天，Cherry在路上遇到Sunkist，它问Sunkist的公司地址在哪里，Sunkist可能有两个答案：以这里为起点，西南方向500米的石室大厦中国广东省广州市思哲路石室大厦 第一个答案以当前的位置为起点所描述的称为相对路径。根据Sunkist当前的位置不一样，它回答的相对路径会不一样. 第二个答案从国家到省份城市巨细无遗地描述称为绝对路径，一个文件除非被移动，否则绝对路径是不会变化的。 每个文件/文件夹在一台计算机中可能会有无数个相对路径，但是只有一个绝对路径。（此demo引自）engine 如何表示上级目录../表示源文件所在目录的上一级目录，../../表示源文件所在目录的上上级目录，以此类推。 如何表示下级目录引用下级目录的文件，直接写下级目录文件的路径即可。1&lt;a href=&quot;adminwang/bbb.html&quot;&gt;链接bbb网页&lt;/a&gt;","categories":[{"name":"知识分享","slug":"知识分享","permalink":"https://lzws0931.cn/categories/知识分享/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://lzws0931.cn/tags/前端/"}]},{"title":"从一个人的社交圈看不到什么有用信息！","slug":"感谢","date":"2018-04-06T14:56:00.000Z","updated":"2018-04-06T15:09:51.263Z","comments":true,"path":"2018/04/06/感谢/","link":"","permalink":"https://lzws0931.cn/2018/04/06/感谢/","excerpt":"","text":"心里很不舒服 之前心里很不舒服还是几年前。 几年之前呢？ 13年还是16年？ 具体的时间我已经忘记了。。但是却非常不愿意有这种滋味。 感觉身上发冷，是由内而外的冷。 我不喜欢把自己内心的东西发布在任何一个社交平台，包括这里 不希望被别人看透彻，不希望被别人知道，这里一下，哪里一下。不要把任何个人的情绪波动表露出来，这就是缺乏安全感吧，只能相信自己。 这个博客是自己搭建起来的，像我的微博一样，自己养活那么大，真让我卖，还真舍不得。 偶尔矫情一下，还是有必要的。 大家都懂，感谢你。 小太阳","categories":[{"name":"生活琐事","slug":"生活琐事","permalink":"https://lzws0931.cn/categories/生活琐事/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://lzws0931.cn/tags/生活/"}]},{"title":"对于前后端分离的了解","slug":"对于前后端分离的了解","date":"2018-03-21T02:21:00.000Z","updated":"2018-03-21T02:51:13.123Z","comments":true,"path":"2018/03/21/对于前后端分离的了解/","link":"","permalink":"https://lzws0931.cn/2018/03/21/对于前后端分离的了解/","excerpt":"","text":"前后端分离、 本文来源我在慕课网学习时候看到笔记整理 https://www.imooc.com 什么叫前后端分离？ 前后端分离就是后端不再直接返回html， 直接返回数据，当然数据格式可以自己指定比如xml， json、yml都是可以的， html页面由前端去填充这些数据到dom中。 随着前后端技术的更新，越来越多的前端框架进入开发者们的视野，网站的前后分离架构越来越得到开发者们的喜爱与认可。 后端只提供数据接口、业务逻辑与持久化服务，而视图、控制与渲染则交给前端。 因此，越来越多的网站从后端渲染变成了前端渲染，前后端分离意味着后端可以不用去了解前端的代码， 前端不用学习后端的模板语法， 前后端不需要等到对方做好了才能调试了， 尽量在保证自己端的代码写好以及少bug， 这样在后期真正联调的时候就可以尽量避免bug了，而且前后端分离还意味着pc端、app、后台管理系统等各种系统可以尽量多的共用接口了。 什么时候选择前后端分离的开发模式？ 在开发过程中相信大家经常会遇到一个问题， android端、ios端、pc端、 后台管理系统如果使用传统的mvc开发模式， 只要页面不一样 我们都得给对应的系统写一套后台， 而且很多页面还需要后端去填充数据到html中、 但是前后端分离的开发模式我们只需要把接口写好， 其余都不用管让前端去协调各个接口之间如何配合。这种模式最大的好处就是适应性很强。 当然还有个很大的好处就是前端不用再等待将页面写好了然后交给后端， 然后后端再将代码改成模板语言了， 当然如果前端熟悉后端模板语法， 后端当然就很喜欢了， 但是前端往往不愿意去学习后端的模板语法，更喜欢用前端自己的模板语法。 前后端分离解决了这个问题 但是Restful api还是有缺点， 最大的问题就是seo， 爬虫爬不到， 百度就会给你降权， 对于那种需要流量的网站来说，这个是不太接受的， 所以后面就有了ssr技术， 在服务器端渲染好静态页面直接给前端， 这篇爬虫就能爬取到了， 而且有些系统比如内部系统或者后台管理系统这种根本就不在乎seo的直接就用restful api开发就行了。 除了上面的问题以外还有就是数据格式依赖严重， 如果后端改了某个字段的名称， 前端也得跟着改， 在以前这种改动后端自己就可以一个人完成，但是分离之后得前端去改了， 如果返回格式变了，前端变动更大。 还有就是文档变得很重要了我们得去维护文档了，因为前后端分离脱离了文档，后期想维护能麻烦死。 前后端分离开发 跨域问题 我们现在有个二次开发的项目，要求前后端分离开发，前端我用webpack-dev-server本地服务，要请求java后台tomact下数据，我要处理跨域请求的问题，jsonp肯定是不行了，后台代码基本已经确认了，我想问如何让后台做的少更改的情况下，前端这边需要做什么配置来解决跨域问题。 想问一些关于前后端分离开发的问题。因为第一次开发有很多地方不清楚，上网查了很多资料现在似懂非懂，基本上就开发环境下的跨域问题是前端后后台一起解决，还是只用前端解决。（网上说是一起解决，但我后台的同事也没有接触过，他们以前都是javaweb项目，也不太懂），第二就是后期部署时前端和后台是不是分开部署服务器，可以部署在同一个服务器上吗。 要么单独写jsonp的接口，要么后台设置cors。开发环境下，你可以使用webpack的代理，用你启动的node服务代理请求访问java的接口然后把结果返回给你，但是生产环境下必须要后端的配合，要么jsonp, 要么设置cors，前端是无法解决的！设置cors是改动成本最低的方式 Node.js覆盖哪些领域？有没有值得玩的？ 理论上 Node 运行在服务器，后端能做的 Node 都能做，但是有几个擅长的领域前端本地代码构建、打包：webpack、gulp、babel 等前端单元测试 &amp; UI 测试：mocha、kama、jest、puppeteer 等视觉渲染为核心的 web 站点：koa、express企业级 web 框架 egg爬虫 puppeteer桌面程序开发 node-webkit、electron比较好玩的应该是爬虫和啄米昂程序开发，但工作最常用的是本地代码构建、打包 &amp; web 请问一下，在公司里从事前端和后端的人是如何配合的？在前后端分离的情况下，后端同学的任务是把数据和文件做持久化存储，并提供操作数据数据的接口。前端同学负责请求数据，然后对数据做处理和适配，最后再把数据呈现出来。其实就是以接口为界限，后端负责接口的制作，前端负责接口的调用。 在实际开发中，一般是前后端同学拿到需求后，一起来确定各个功能点需要的接口，然后再逐个细化出各个接口的输入输出字段，最后由后端同学生成一个接口文档。 模块化为什么可以提高开发效率？1.对代码进行封装隔离，提高代码的复用性，就能减少代码量2.通过逐级对业务的拆解，达到简化业务的作用，降低系统复杂度3.更好的代码组织方式，能支持团队并行开发，提高团队的效率4.封闭作用域，减少变量冲突带来的不太容易发现的问题5.耦合小，利于后期扩展和修改，降低系统的后期维护成本 开发环境：开发环境是程序猿们专门用于开发的服务器，配置可以比较随意，为了开发调试方便，一般打开全部错误报告。 测试环境：一般是克隆一份生产环境的配置，一个程序在测试环境工作不正常，那么肯定不能把它发布到生产机上。 生产环境：是值正式提供对外服务的，一般会关掉错误报告，打开错误日志。 三个环境也可以说是系统开发的三个阶段：开发-&gt;测试-&gt;上线，其中生产环境也就是通常说的真实环境。","categories":[{"name":"前后分离","slug":"前后分离","permalink":"https://lzws0931.cn/categories/前后分离/"}],"tags":[{"name":"工作流","slug":"工作流","permalink":"https://lzws0931.cn/tags/工作流/"}]},{"title":"我的技术博客终于完成了！","slug":"我的技术博客终于完成了","date":"2018-03-19T13:52:00.000Z","updated":"2018-03-19T15:18:55.427Z","comments":true,"path":"2018/03/19/我的技术博客终于完成了/","link":"","permalink":"https://lzws0931.cn/2018/03/19/我的技术博客终于完成了/","excerpt":"","text":"经过了一周的努力，我的技术博客完成了其中我收获颇多。虽然我用的是hexo第三方的主题，但是我修改了里面不少的结构样式其中踩到很多的坑。由于主题用的是ejs模版，不是很熟悉，导致刚开始的时候结构和样式比较混乱。经过一天的查询资料以及了解根据文件命名的了解大体对文件有了初步认识。 其中博客里面还自主插入了网易云音乐,QQ聊天,微博秀等第三方的插件，特别是在微博秀的时候，对http和https有了更深刻的认识。 在最后显示博文的标题图片的时候，也遇到了bug,然后自己也获得了解决。由于刚开始没有重点去用笔记的形式记这些内容，所以只是在自己的印象笔记里面有了一些关键词的笔记。后期如果学习和做项目的过程中，希望能发挥出我自己这个技术博客的作用。 哦，对了，最后由于觉得用hexo的命令行发布博文太麻烦，又找到了一个hexo/admin的插件可以使用，大大的方便了后面对博文的编辑。而且我的MD编辑的语法不是很熟悉，后面会对此进行加强练习。 域名正在备案中，等备案成功了，我就终于完成了一个小梦想。最近在做这个网站的时候我竟然觉得自己慢慢喜欢上看技术。以前可是从来没有这样的感觉。 上线以后再对网站进行SEO优化吧，让百度多抓抓、、或许别人觉得这个网站很简单，比较丑但是这就是提高。脚踏实地的提高。接下来就是给七期就业了。加油。⛽️","categories":[{"name":"博客制作","slug":"博客制作","permalink":"https://lzws0931.cn/categories/博客制作/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://lzws0931.cn/tags/生活/"}]},{"title":"关于https不支持http的解决方案","slug":"关于https不支持http的解决方案","date":"2018-03-18T16:21:00.000Z","updated":"2018-03-21T02:28:03.403Z","comments":true,"path":"2018/03/19/关于https不支持http的解决方案/","link":"","permalink":"https://lzws0931.cn/2018/03/19/关于https不支持http的解决方案/","excerpt":"","text":"由于在写md的时候截图是用的微博的图床，上传到github才发现不让在其他网站使用，所有本文只有一张图片。 刚才进行网站测试的时候，微博秀这个插件不能显示出来，一直是空白，然后我把本地域名改成了127.0.0.1，显示出来了。可是部署到github以后还是显示空白，我以为是网络问题，但是检查了一下才发现报错了。 1Mixed Content: The page at ‘https://www.taobao.com/‘ was loaded over HTTPS, but requested an insecure image ‘http://g.alicdn.com/s.gif’. This content should also be served over HTTPS. 查了一下原因，显示说是现在的github是https协议了。而微博秀还是http的协议，然后通过了解可以通过ssl进行解决。但是有点麻烦，然后，我又经过查找资料。 把微博秀里面的http去掉了。写成了类似相对路径的形式。 并且查到可以在页面中加入（meta）头，为了以防万一，我进行了这两个步骤，然后部署后成功显示1&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot; /&gt; 正常显示了微博秀","categories":[{"name":"网站上线","slug":"网站上线","permalink":"https://lzws0931.cn/categories/网站上线/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://lzws0931.cn/tags/HTTP/"}]},{"title":"法门扫地僧面试宝典第三版","slug":"法门扫地僧前端面试宝典第二版","date":"2018-03-17T00:20:09.000Z","updated":"2018-11-05T08:53:49.800Z","comments":true,"path":"2018/03/17/法门扫地僧前端面试宝典第二版/","link":"","permalink":"https://lzws0931.cn/2018/03/17/法门扫地僧前端面试宝典第二版/","excerpt":"","text":"Front-End前端开发工程师面试宝典！ （本文部分有转载，不定期更新！） 前言（README.md）12本仓库是我整理的前端常见面试题，大部分由我整理，其中个别部分参考网上其他资料，感谢！ 本资料仅供大家学习参考使用！欢迎大家Star和提交issues。 NO.1 READMENO.2 简历经验分享NO.3 angular常见问题NO.4 前端面试宝典第一版NO.5 前端笔记版本第二版NO.6 前端笔记版本第三版NO.7 前端笔记版本第四版NO.8 vue常见问题 欢迎大家一起交流提高前端需要注意哪些SEO 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标 web开发中会话跟踪的方法有哪些 cookie session url重写 隐藏input ip地址 &lt;img&gt;的title和alt有什么区别 title是global attributes之一，用于为元素提供附加的advisory information。通常当鼠标滑动到元素上的时候显示。 alt是&lt;img&gt;的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。 doctype是什么,举例常见doctype及特点 &lt;!doctype&gt;声明必须处于HTML文档的头部，在&lt;html&gt;标签之前，HTML5中不区分大小写 &lt;!doctype&gt;声明不是一个HTML标签，是一个用于告诉浏览器当前HTMl版本的指令 现代浏览器的html布局引擎通过检查doctype决定使用兼容模式还是标准模式对文档进行渲染，一些浏览器有一个接近标准模型。 在HTML4.01中&lt;!doctype&gt;声明指向一个DTD，由于HTML4.01基于SGML，所以DTD指定了标记规则以保证浏览器正确渲染内容 HTML5不基于SGML，所以不用指定DTD 什么是web语义化,有什么好处web语义化是指通过HTML标记表示页面包含的信息，包含了HTML标签的语义化和css命名的语义化。HTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构css命名的语义化是指：为html标签添加有意义的class，id补充未表达的语义，如Microformat通过添加符合规则的class描述信息为什么需要语义化： 去掉样式后页面呈现清晰的结构 盲人使用读屏器更好地阅读 搜索引擎更好地理解页面，有利于收录 便团队项目的可持续运作及维护 HTTP method 一台服务器要与HTTP1.1兼容，只要为资源实现GET和HEAD方法即可 GET是最常用的方法，通常用于请求服务器发送某个资源。 HEAD与GET类似，但服务器在响应中值返回首部，不返回实体的主体部分 PUT让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档，或者，如果那个URL已经存在的话，就用干这个主体替代它 POST起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。 TRACE会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。 OPTIONS方法请求web服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。 DELETE请求服务器删除请求URL指定的资源 从浏览器地址栏输入url到显示页面的步骤(以HTTP为例) 在浏览器地址栏输入URL 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤 如果资源未缓存，发起新请求 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。 检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control： HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期 HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间 浏览器解析URL获取协议，主机，端口，path 浏览器组装一个HTTP（GET）请求报文 浏览器获取主机ip地址，过程如下： 浏览器缓存 本机缓存 hosts文件 路由器缓存 ISP DNS缓存 DNS递归查询（可能存在负载均衡导致每次IP不一样） 打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下： 客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包 客户端发送ACK=Y+1， Seq=Z TCP链接建立后发送HTTP请求 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作 服务器将响应报文通过TCP连接发送回浏览器 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下： 主动方发送Fin=1， Ack=Z， Seq= X报文 被动方发送ACK=X+1， Seq=Z报文 被动方发送Fin=1， ACK=X， Seq=Y报文 主动方发送ACK=Y， Seq=X报文 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同 如果资源可缓存，进行缓存 对响应进行解码（例如gzip压缩） 根据资源类型决定如何处理（假设资源为HTML文档） 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释 构建DOM树： Tokenizing：根据HTML规范将字符流解析为标记 Lexing：词法分析将标记转换为对象并定义属性和规则 DOM construction：根据HTML标记关系将对象组成DOM树 解析过程中遇到图片、样式表、js文件，启动下载 构建CSSOM树： Tokenizing：字符流转换为标记流 Node：根据标记创建节点 CSSOM：节点创建CSSOM树 根据DOM树和CSSOM树构建渲染树: 从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none 对每一个可见节点，找到恰当的CSSOM规则并应用 发布可视节点的内容和计算样式 js解析如下： 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素 当文档完成解析，document.readState变成interactive 所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write() 浏览器在Document对象上触发DOMContentLoaded事件 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件 显示页面（HTML解析过程中会逐步显示页面） 如何进行网站性能优化 content方面 减少HTTP请求：合并文件、CSS精灵、inline Image 减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询 避免重定向：多余的中间访问 使Ajax可缓存 非必须组件延迟加载 未来所需组件预加载 减少DOM元素数量 将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量 减少iframe数量 不要404 Server方面 使用CDN 添加Expires或者Cache-Control响应头 对组件使用Gzip压缩 配置ETag Flush Buffer Early Ajax使用GET进行请求 避免空src的img标签 Cookie方面 减小cookie大小 引入资源的域名不要包含cookie css方面 将样式表放到页面顶部 不使用CSS表达式 使用不使用@import 不使用IE的Filter Javascript方面 将脚本放到页面底部 将javascript和css从外部引入 压缩javascript和css 删除不需要的脚本 减少DOM访问 合理设计事件监听器 图片方面 优化图片：根据实际颜色需要选择色深、压缩 优化css精灵 不要在HTML中拉伸图片 保证favicon.ico小并且可缓存 移动方面 保证组件小于25k Pack Components into a Multipart Document 什么是渐进增强渐进增强是指在web设计时强调可访问性、语义化HTML标签、外部样式表和脚本。保证所有人都能访问页面的基本内容和功能同时为高级浏览器和高带宽用户提供更好的用户体验。核心原则如下: 所有浏览器都必须能访问基本内容 所有浏览器都必须能使用基本功能 所有内容都包含在语义化标签中 通过外部CSS提供增强的布局 通过非侵入式、外部javascript提供增强功能 end-user web browser preferences are respected $CSS部分CSS选择器有哪些 *通用选择器：选择所有元素，不参与计算优先级，兼容性IE6+ #X id选择器：选择id值为X的元素，兼容性：IE6+ .X 类选择器： 选择class包含X的元素，兼容性：IE6+ X Y后代选择器： 选择满足X选择器的后代节点中满足Y选择器的元素，兼容性：IE6+ X 元素选择器： 选择标所有签为X的元素，兼容性：IE6+ :link，：visited，：focus，：hover，：active链接状态： 选择特定状态的链接元素，顺序LoVe HAte，兼容性: IE4+ X + Y直接兄弟选择器：在X之后第一个兄弟节点中选择满足Y选择器的元素，兼容性： IE7+ X &gt; Y子选择器： 选择X的子元素中满足Y选择器的元素，兼容性： IE7+ X ~ Y兄弟： 选择X之后所有兄弟节点中满足Y选择器的元素，兼容性： IE7+ [attr]：选择所有设置了attr属性的元素，兼容性IE7+ [attr=value]：选择属性值刚好为value的元素 [attr~=value]：选择属性值为空白符分隔，其中一个的值刚好是value的元素 [attr|=value]：选择属性值刚好为value或者value-开头的元素 [attr^=value]：选择属性值以value开头的元素 [attr$=value]：选择属性值以value结尾的元素 [attr*=value]：选择属性值中包含value的元素 [:checked]：选择单选框，复选框，下拉框中选中状态下的元素，兼容性：IE9+ X:after, X::after：after伪元素，选择元素虚拟子元素（元素的最后一个子元素），CSS3中::表示伪元素。兼容性:after为IE8+，::after为IE9+ :hover：鼠标移入状态的元素，兼容性a标签IE4+， 所有元素IE7+ :not(selector)：选择不符合selector的元素。不参与计算优先级，兼容性：IE9+ ::first-letter：伪元素，选择块元素第一行的第一个字母，兼容性IE5.5+ ::first-line：伪元素，选择块元素的第一行，兼容性IE5.5+ :nth-child(an + b)：伪类，选择前面有an + b - 1个兄弟节点的元素，其中n&gt;= 0， 兼容性IE9+ :nth-last-child(an + b)：伪类，选择后面有an + b - 1个兄弟节点的元素其中n &gt;= 0，兼容性IE9+ X:nth-of-type(an+b)：伪类，X为选择器，解析得到元素标签，选择前面有an + b - 1个相同标签兄弟节点的元素。兼容性IE9+ X:nth-last-of-type(an+b)：伪类，X为选择器，解析得到元素标签，选择后面有an+b-1个相同标签兄弟节点的元素。兼容性IE9+ X:first-child：伪类，选择满足X选择器的元素，且这个元素是其父节点的第一个子元素。兼容性IE7+ X:last-child：伪类，选择满足X选择器的元素，且这个元素是其父节点的最后一个子元素。兼容性IE9+ X:only-child：伪类，选择满足X选择器的元素，且这个元素是其父元素的唯一子元素。兼容性IE9+ X:only-of-type：伪类，选择X选择的元素，解析得到元素标签，如果该元素没有相同类型的兄弟节点时选中它。兼容性IE9+ X:first-of-type：伪类，选择X选择的元素，解析得到元素标签，如果该元素是此此类型元素的第一个兄弟。选中它。兼容性IE9+ css sprite是什么,有什么优缺点概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案。 优点： 减少HTTP请求数，极大地提高页面加载速度 增加图片信息重复度，提高压缩比，减少图片大小 更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现 缺点： 图片合并麻烦 维护麻烦，修改一个图片可能需要从新布局整个图片，样式 display: none;与visibility: hidden;的区别联系：它们都能让元素不可见 区别： display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见 display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式 修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。 读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容 css hack原理及常用hack原理：利用不同浏览器对CSS的支持和解析结果不一样编写针对特定浏览器样式。常见的hack有1）属性hack。2）选择器hack。3）IE条件注释 IE条件注释：适用于[IE5, IE9]常见格式如下 123&lt;!--[if IE 6]&gt;Special instructions for IE 6 here&lt;![endif]--&gt; link与@import的区别 link是HTML方式， @import是CSS方式 link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUC link可以通过rel=&quot;alternate stylesheet&quot;指定候选样式 浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式 @import必须在样式规则之前，可以在css文件中引用其他文件 总体来说：link优于@import display: block;和display: inline;的区别block元素特点： 1.处于常规流中时，如果width没有设置，会自动填充满父容器2.可以应用margin/padding3.在没有设置高度的情况下会扩展高度以包含常规流中的子元素4.处于常规流中时布局时在前后元素位置之间（独占一个水平空间）5.忽略vertical-align inline元素特点 1.水平方向上根据direction依次布局2.不会在元素前后进行换行3.受white-space控制4.margin/padding在竖直方向上无效，水平方向上有效5.width/height属性对非替换行内元素无效，宽度由元素内容决定6.非替换行内元素的行框高由line-height确定，替换行内元素的行框高由height,margin,padding,border决定6.浮动或绝对定位时会转换为block7.vertical-align属性生效 PNG,GIF,JPG的区别及如何选参考资料： 选择正确的图片格式GIF: 8位像素，256色 无损压缩 支持简单动画 支持boolean透明 适合简单动画 JPEG： 颜色限于256 有损压缩 可控制压缩质量 不支持透明 适合照片 PNG： 有PNG8和truecolor PNG PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画 适合图标、背景、按钮 容器包含若干浮动元素时如何清理(包含)浮动 容器元素闭合标签前添加额外元素并设置clear: both 父元素触发块级格式化上下文(见块级可视化上下文部分) 设置容器元素伪元素进行清理推荐的清理浮动方法 1234567891011121314151617181920212223242526/*** 在标准浏览器下使用* 1 content内容为空格用于修复opera下文档中出现* contenteditable属性时在清理浮动元素上下的空白* 2 使用display使用table而不是block：可以防止容器和* 子元素top-margin折叠,这样能使清理效果与BFC，IE6/7* zoom: 1;一致**/.clearfix:before,.clearfix:after &#123; content: &quot; &quot;; /* 1 */ display: table; /* 2 */&#125;.clearfix:after &#123; clear: both;&#125;/*** IE 6/7下使用* 通过触发hasLayout实现包含浮动**/.clearfix &#123; *zoom: 1;&#125; 什么是FOUC?如何避免Flash Of Unstyled Content：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。解决方法：把样式表放到文档的head 如何创建块级格式化上下文(block formatting context),BFC有什么用创建规则： 根元素 浮动元素（float不是none） 绝对定位元素（position取值为absolute或fixed） display取值为inline-block,table-cell, table-caption,flex, inline-flex之一的元素 overflow不是visible的元素 作用： 可以包含浮动元素 不被浮动元素覆盖 阻止父子元素的margin折叠 display,float,position的关系 如果display为none，那么position和float都不起作用，这种情况下元素不产生框 否则，如果position值为absolute或者fixed，框就是绝对定位的，float的计算值为none，display根据下面的表格进行调整。 否则，如果float不是none，框是浮动的，display根据下表进行调整 否则，如果元素是根元素，display根据下表进行调整 其他情况下display的值为指定值总结起来：绝对定位、浮动、根元素都需要调整display 外边距折叠(collapsing margins)毗邻的两个或多个margin会合并成一个margin，叫做外边距折叠。规则如下： 两个或多个毗邻的普通流中的块元素垂直方向上的margin会折叠 浮动元素/inline-block元素/绝对定位元素的margin不会和垂直方向上的其他元素的margin折叠 创建了块级格式化上下文的元素，不会和它的子元素发生margin折叠 元素自身的margin-bottom和margin-top相邻时也会折叠 如何确定一个元素的包含块(containing block) 根元素的包含块叫做初始包含块，在连续媒体中他的尺寸与viewport相同并且anchored at the canvas origin；对于paged media，它的尺寸等于page area。初始包含块的direction属性与根元素相同。 position为relative或者static的元素，它的包含块由最近的块级（display为block,list-item, table）祖先元素的内容框组成 如果元素position为fixed。对于连续媒体，它的包含块为viewport；对于paged media，包含块为page area 如果元素position为absolute，它的包含块由祖先元素中最近一个position为relative,absolute或者fixed的元素产生，规则如下： 如果祖先元素为行内元素，the containing block is the bounding box around the padding boxes of the first and the last inline boxes generated for that element. 其他情况下包含块由祖先节点的padding edge组成 如果找不到定位的祖先元素，包含块为初始包含块 stacking context,布局规则z轴上的默认层叠顺序如下（从下到上）： 根元素的边界和背景 常规流中的元素按照html中顺序 浮动块 positioned元素按照html中出现顺序 如何创建stacking context： 根元素 z-index不为auto的定位元素 a flex item with a z-index value other than ‘auto’ opacity小于1的元素 在移动端webkit和chrome22+，z-index为auto，position: fixed也将创建新的stacking context 如何水平居中一个元素 如果需要居中的元素为常规流中inline元素，为父元素设置text-align: center;即可实现 如果需要居中的元素为常规流中block元素，1）为元素设置宽度，2）设置左右margin为auto。3）IE6下需在父元素上设置text-align: center;,再给子元素恢复需要的值 12345678910111213141516171819&lt;body&gt; &lt;div class=&quot;content&quot;&gt; aaaaaa aaaaaa a a a a a a a a &lt;/div&gt;&lt;/body&gt;&lt;style&gt; body &#123; background: #DDD; text-align: center; /* 3 */ &#125; .content &#123; width: 500px; /* 1 */ text-align: left; /* 3 */ margin: 0 auto; /* 2 */ background: purple; &#125;&lt;/style&gt; 如果需要居中的元素为浮动元素，1）为元素设置宽度，2）position: relative;，3）浮动方向偏移量（left或者right）设置为50%，4）浮动方向上的margin设置为元素宽度一半乘以-1 123456789101112131415161718192021&lt;body&gt; &lt;div class=&quot;content&quot;&gt; aaaaaa aaaaaa a a a a a a a a &lt;/div&gt;&lt;/body&gt;&lt;style&gt; body &#123; background: #DDD; &#125; .content &#123; width: 500px; /* 1 */ float: left; position: relative; /* 2 */ left: 50%; /* 3 */ margin-left: -250px; /* 4 */ background-color: purple; &#125;&lt;/style&gt; 如果需要居中的元素为绝对定位元素，1）为元素设置宽度，2）偏移量设置为50%，3）偏移方向外边距设置为元素宽度一半乘以-1 123456789101112131415161718192021&lt;body&gt; &lt;div class=&quot;content&quot;&gt; aaaaaa aaaaaa a a a a a a a a &lt;/div&gt;&lt;/body&gt;&lt;style&gt; body &#123; background: #DDD; position: relative; &#125; .content &#123; width: 800px; position: absolute; left: 50%; margin-left: -400px; background-color: purple; &#125;&lt;/style&gt; 如果需要居中的元素为绝对定位元素，1）为元素设置宽度，2）设置左右偏移量都为0,3）设置左右外边距都为auto 12345678910111213141516171819202122&lt;body&gt; &lt;div class=&quot;content&quot;&gt; aaaaaa aaaaaa a a a a a a a a &lt;/div&gt;&lt;/body&gt;&lt;style&gt; body &#123; background: #DDD; position: relative; &#125; .content &#123; width: 800px; position: absolute; margin: 0 auto; left: 0; right: 0; background-color: purple; &#125;&lt;/style&gt; 如何竖直居中一个元素参考资料：6 Methods For Vertical Centering With CSS。 盘点8种CSS实现垂直居中 需要居中元素为单行文本，为包含文本的元素设置大于font-size的line-height： 1234567&lt;p class=&quot;text&quot;&gt;center text&lt;/p&gt;&lt;style&gt;.text &#123; line-height: 200px;&#125;&lt;/style&gt; offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别 offsetWidth/offsetHeight返回值包含content + padding + border，效果与e.getBoundingClientRect()相同 clientWidth/clientHeight返回值只包含content + padding，如果有滚动条，也不包含滚动条 scrollWidth/scrollHeight返回值包含content + padding + 溢出内容的尺寸 XMLHttpRequest通用属性和方法 readyState:表示请求状态的整数，取值： UNSENT（0）：对象已创建 OPENED（1）：open()成功调用，在这个状态下，可以为xhr设置请求头，或者使用send()发送请求 HEADERS_RECEIVED(2)：所有重定向已经自动完成访问，并且最终响应的HTTP头已经收到 LOADING(3)：响应体正在接收 DONE(4)：数据传输完成或者传输产生错误 onreadystatechange：readyState改变时调用的函数 status：服务器返回的HTTP状态码（如，200， 404） statusText:服务器返回的HTTP状态信息（如，OK，No Content） responseText:作为字符串形式的来自服务器的完整响应 responseXML: Document对象，表示服务器的响应解析成的XML文档 abort():取消异步HTTP请求 getAllResponseHeaders(): 返回一个字符串，包含响应中服务器发送的全部HTTP报头。每个报头都是一个用冒号分隔开的名/值对，并且使用一个回车/换行来分隔报头行 getResponseHeader(headerName):返回headName对应的报头值 open(method, url, asynchronous [, user, password]):初始化准备发送到服务器上的请求。method是HTTP方法，不区分大小写；url是请求发送的相对或绝对URL；asynchronous表示请求是否异步；user和password提供身份验证 setRequestHeader(name, value):设置HTTP报头 send(body):对服务器请求进行初始化。参数body包含请求的主体部分，对于POST请求为键值对字符串；对于GET请求，为null focus/blur与focusin/focusout的区别与联系 focus/blur不冒泡，focusin/focusout冒泡 focus/blur兼容性好，focusin/focusout在除FireFox外的浏览器下都保持良好兼容性，如需使用事件托管，可考虑在FireFox下使用事件捕获elem.addEventListener(‘focus’, handler, true) 可获得焦点的元素： window 链接被点击或键盘操作 表单空间被点击或键盘操作 设置tabindex属性的元素被点击或键盘操作 mouseover/mouseout与mouseenter/mouseleave的区别与联系 mouseover/mouseout是标准事件，所有浏览器都支持；mouseenter/mouseleave是IE5.5引入的特有事件后来被DOM3标准采纳，现代标准浏览器也支持 mouseover/mouseout是冒泡事件；mouseenter/mouseleave不冒泡。需要为多个元素监听鼠标移入/出事件时，推荐mouseover/mouseout托管，提高性能 标准事件模型中event.target表示发生移入/出的元素,vent.relatedTarget对应移出/如元素；在老IE中event.srcElement表示发生移入/出的元素，event.toElement表示移出的目标元素，event.fromElement表示移入时的来源元素 sessionStorage,localStorage,cookie区别 都会在浏览器端保存，有大小限制，同源限制 cookie会在请求时发送到服务器，作为会话标识，服务器可修改cookie；web storage不会发送到服务器 cookie有path概念，子路径可以访问父路径cookie，父路径不能访问子路径cookie 有效期：cookie在设置的有效期内有效，默认为浏览器关闭；sessionStorage在窗口关闭前有效，localStorage长期有效，直到用户删除 共享：sessionStorage不能共享，localStorage在同源文档之间共享，cookie在同源且符合path规则的文档之间共享 localStorage的修改会促发其他文档窗口的update事件 cookie有secure属性要求HTTPS传输 浏览器不能保存超过300个cookie，单个服务器不能超过20个，每个cookie不能超过4k。web storage大小支持能达到5M javascript跨域通信同源：两个文档同源需满足 协议相同 域名相同 端口相同 跨域通信：js进行DOM操作、通信时如果目标与当前窗口不满足同源条件，浏览器为了安全会阻止跨域操作。跨域通信通常有以下方法 如果是log之类的简单单项通信，新建&lt;img&gt;,&lt;script&gt;,&lt;link&gt;,&lt;iframe&gt;元素，通过src，href属性设置为目标url。实现跨域请求 如果请求json数据，使用&lt;script&gt;进行jsonp请求 现代浏览器中多窗口通信使用HTML5规范的targetWindow.postMessage(data, origin);其中data是需要发送的对象，origin是目标窗口的origin。window.addEventListener(‘message’, handler, false);handler的event.data是postMessage发送来的数据，event.origin是发送窗口的origin，event.source是发送消息的窗口引用 内部服务器代理请求跨域url，然后返回数据 跨域请求数据，现代浏览器可使用HTML5规范的CORS功能，只要目标服务器返回HTTP头部Access-Control-Allow-Origin: *即可像普通ajax一样访问跨域资源 javascript有哪几种数据类型六种基本数据类型 undefined null string boolean number symbol(ES6) 一种引用类型 Object 什么闭包,闭包有什么用闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量。闭包作用域链通常包括三个部分： 函数本身作用域。 闭包定义时的作用域。 全局作用域。 闭包常见用途： 创建特权方法用于访问控制 事件处理程序及回调 应用程序存储和离线web应用HTML5新增应用程序缓存，允许web应用将应用程序自身保存到用户浏览器中，用户离线状态也能访问。1.为html元素设置manifest属性:&lt;html manifest=&quot;myapp.appcache&quot;&gt;，其中后缀名只是一个约定，真正识别方式是通过text/cache-manifest作为MIME类型。所以需要配置服务器保证设置正确2.manifest文件首行为CACHE MANIFEST，其余就是要缓存的URL列表，每个一行，相对路径都相对于manifest文件的url。注释以#开头3.url分为三种类型：CACHE:为默认类型。NETWORK：表示资源从不缓存。 FALLBACK:每行包含两个url，第二个URL是指需要加载和存储在缓存中的资源， 第一个URL是一个前缀。任何匹配该前缀的URL都不会缓存，如果从网络中载入这样的URL失败的话，就会用第二个URL指定的缓存资源来替代。以下是一个文件例子： 客户端存储localStorage和sessionStorage localStorage有效期为永久，sessionStorage有效期为顶层窗口关闭前 同源文档可以读取并修改localStorage数据，sessionStorage只允许同一个窗口下的文档访问，如通过iframe引入的同源文档。 Storage对象通常被当做普通javascript对象使用：通过设置属性来存取字符串值，也可以通过setItem(key, value)设置，getItem(key)读取，removeItem(key)删除，clear()删除所有数据，length表示已存储的数据项数目，key(index)返回对应索引的key cookie及其操作 cookie是web浏览器存储的少量数据，最早设计为服务器端使用，作为HTTP协议的扩展实现。cookie数据会自动在浏览器和服务器之间传输。 通过读写cookie检测是否支持 cookie属性有名，值，max-age，path, domain，secure； cookie默认有效期为浏览器会话，一旦用户关闭浏览器，数据就丢失，通过设置max-age=seconds属性告诉浏览器cookie有效期 cookie作用域通过文档源和文档路径来确定，通过path和domain进行配置，web页面同目录或子目录文档都可访问 通过cookie保存数据的方法为：为document.cookie设置一个符合目标的字符串如下 读取document.cookie获得’; ‘分隔的字符串，key=value,解析得到结果 12345678910document.cookie = &apos;name=qiu; max-age=9999; path=/; domain=domain; secure&apos;;document.cookie = &apos;name=aaa; path=/; domain=domain; secure&apos;;// 要改变cookie的值，需要使用相同的名字、路径和域，新的值// 来设置cookie，同样的方法可以用来改变有效期// 设置max-age为0可以删除指定cookie//读取cookie，访问document.cookie返回键值对组成的字符串，//不同键值对之间用&apos;; &apos;分隔。通过解析获得需要的值 javascript有哪些方法定义对象 对象字面量： var obj = {}; 构造函数： var obj = new Object(); Object.create(): var obj = Object.create(Object.prototype); ===运算符判断相等的流程是怎样的 如果两个值不是相同类型，它们不相等 如果两个值都是null或者都是undefined，它们相等 如果两个值都是布尔类型true或者都是false，它们相等 如果其中有一个是NaN，它们不相等 如果都是数值型并且数值相等，他们相等， -0等于0 如果他们都是字符串并且在相同位置包含相同的16位值，他它们相等；如果在长度或者内容上不等，它们不相等；两个字符串显示结果相同但是编码不同==和===都认为他们不相等 如果他们指向相同对象、数组、函数，它们相等；如果指向不同对象，他们不相等 ==运算符判断相等的流程是怎样的 如果两个值类型相同，按照===比较方法进行比较 如果类型不同，使用如下规则进行比较 如果其中一个值是null，另一个是undefined，它们相等 如果一个值是数字另一个是字符串，将字符串转换为数字进行比较 如果有布尔类型，将true转换为1，false转换为0，然后用==规则继续比较 如果一个值是对象，另一个是数字或字符串，将对象转换为原始值然后用==规则继续比较 其他所有情况都认为不相等 对象到字符串的转换步骤 如果对象有toString()方法，javascript调用它。如果返回一个原始值（primitive value如：string number boolean）,将这个值转换为字符串作为结果 如果对象没有toString()方法或者返回值不是原始值，javascript寻找对象的valueOf()方法，如果存在就调用它，返回结果是原始值则转为字符串作为结果 否则，javascript不能从toString()或者valueOf()获得一个原始值，此时throws a TypeError 对象到数字的转换步骤1. 如果对象有valueOf()方法并且返回元素值，javascript将返回值转换为数字作为结果 2. 否则，如果对象有toString()并且返回原始值，javascript将返回结果转换为数字作为结果 3. 否则，throws a TypeError &lt;,&gt;,&lt;=,&gt;=的比较规则所有比较运算符都支持任意类型，但是比较只支持数字和字符串，所以需要执行必要的转换然后进行比较，转换规则如下: 如果操作数是对象，转换为原始值：如果valueOf方法返回原始值，则使用这个值，否则使用toString方法的结果，如果转换失败则报错 经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的16位unicode值的大小） 否则，如果有一个操作数不是字符串，将两个操作数转换为数字进行比较 +运算符工作流程 如果有操作数是对象，转换为原始值 此时如果有一个操作数是字符串，其他的操作数都转换为字符串并执行连接 否则：所有操作数都转换为数字并执行加法 函数内部arguments变量有哪些特性,有哪些属性,如何将它转换为数组 arguments所有函数中都包含的一个局部变量，是一个类数组对象，对应函数调用时的实参。如果函数定义同名参数会在调用时覆盖默认对象 arguments[index]分别对应函数调用时的实参，并且通过arguments修改实参时会同时修改实参 arguments.length为实参的个数（Function.length表示形参长度） arguments.callee为当前正在执行的函数本身，使用这个属性进行递归调用时需注意this的变化 arguments.caller为调用当前函数的函数（已被遗弃） 转换为数组：var args = Array.prototype.slice.call(arguments, 0); DOM事件模型是如何的,编写一个EventUtil工具类实现事件管理兼容 DOM事件包含捕获（capture）和冒泡（bubble）两个阶段：捕获阶段事件从window开始触发事件然后通过祖先节点一次传递到触发事件的DOM元素上；冒泡阶段事件从初始元素依次向祖先节点传递直到window 标准事件监听elem.addEventListener(type, handler, capture)/elem.removeEventListener(type, handler, capture)：handler接收保存事件信息的event对象作为参数，event.target为触发事件的对象，handler调用上下文this为绑定监听器的对象，event.preventDefault()取消事件默认行为，event.stopPropagation()/event.stopImmediatePropagation()取消事件传递 老版本IE事件监听elem.attachEvent(‘on’+type, handler)/elem.detachEvent(‘on’+type, handler)：handler不接收event作为参数，事件信息保存在window.event中，触发事件的对象为event.srcElement，handler执行上下文this为window使用闭包中调用handler.call(elem, event)可模仿标准模型，然后返回闭包，保证了监听器的移除。event.returnValue为false时取消事件默认行为，event.cancleBubble为true时取消时间传播 通常利用事件冒泡机制托管事件处理程序提高程序性能。 W3C标准万维网联盟标准。 万维网联盟（外语缩写：W3C）标准不是某一个标准，而是一系列标准的集合。网页主要由三部分组成： 结构(Structure) 表现（Presentation） 行为（Behavior） 对应的标准也分三方面： 结构化标准语言主要包括XHTML和XML， 表现标准语言主要包括CSS， 行为标准主要包括对象模型（如W3C DOM）、ECMAScript等。这些标准大部分由W3C起草和发布，也有一些是其他标准组织制订的标准，比如ECMA（European Computer Manufacturers Association）的ECMAScript标准。 网页通过W3C标准的步骤： 图片的alt=””属性必须每张图片都加上,而且对齐属性用CSS来定义。不加不能通过XHTML1.0验证。 每个文档必须加上DTD声明1&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTDXHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; 去掉后能通过验证，但有警告：No DOCTYPE found! Checking with default XHTML 1.0 Transitional Document Type。 RSS的XML通过时其中的域名地址必须与检测的地址一致,否则报错. 标签的链接属性加上JAVASCRIPT事件时必须为#空链,不能为javascript:;或javascript:void(null); 同一个页面当中，同名的ID会产生冲突。所以以ID定义样式的必须改成类引用。 1&lt;div id=&quot;a1&quot;&gt;111&lt;/div&gt; &lt;div id=&quot;a1&quot;&gt;222&lt;/div&gt; 如果不用W3C来检测的话，在CSS设计里是允许这样做的。 那是程序的角度不能相同，CSS上是可以相同的! 之前就是相同的产生问题，后面就改成类引用了!(简单的说就是id必须要是单一的不能重复 如果重复就使用class) 不可以省略双引号或者单引号 标签之间不可错位嵌套。123456&lt;div class=&quot;CaseDetaListSS&quot;&gt;原文链接：&lt;a href=&apos;/html/cases/cases_61.html&apos;&gt;官方网站&lt;/div&gt;&lt;/a&gt; 不允许这样。 所有标签必须都使用小写 FLASH的标签代码中不能含有,必须采用其它的方法实现。 所有的标签中含有的属性必须有值(官方的说法)。 标签必须配对完成,单标签必须以/关闭 JS和CSS外部引入文件必须加上类型定义: 12&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;style type=&apos;text/css&apos;&gt;&lt;/style&gt; 所有的样式全部写在外部文件。用类名定义。在使用的地方引用。 页面上的一些特殊字符必须用HTML代码来标识.如“&amp;”写成“&amp;“ 显示结果 说明 Entity Name Entity Number 空格 | ```&#160;``` |123456789101112131415161718192021| &lt; | 小于 | ```&amp;lt;``` | ```&amp;#60;``` || &gt; | 大于 | ```&amp;gt;``` | ```&amp;#62;``` || &amp; | &amp;符号 | ```&amp;amp;``` | ```&amp;#38;``` || &quot; | 双引号 | ```&amp;quot;``` | ```&amp;#34;``` || x | 乘号 | ```&amp;times;``` | ```&amp;#215;``` || ÷ | 除号 | ```&amp;divide;``` | ```&amp;#247;``` |## HTML5的备忘录##### HTML5是现在前端开发人员必备技能。&gt; HTML本来不会活过21世纪的。网页规范的制定者W3C组织，早在1998年就已经对HTML撒手不管了。W3C把未来都寄托在**XHTML**这个更具现代特色的后续规范上，XHTML被视为HTML的严肃整洁版，但XHTML举步维艰。当XHTML举步维艰的时候，有那么一群人\\(来自欧朋\\(OPera\\)\\/火狐\\(fireFox\\)\\/苹果\\(safari\\)的一些具有开发者自行组建了WHATWG\\(Web Hypertext Application Technology Working Group超文本应用技术工作组\\)\\)开始寻找新的解决方案，这就奠定了HTML5的的前身。**HTML5诞生于2004年****HTML5的规范正式公布于2014年**### 首先是HTML5的结构* 文档类型声明 &lt;!DOCTYPE HTML&gt; //相比于html4除去了约束和版本号 12* 字符编码 //声明字符集的编码 12345678910111213141516171819202122232425262728293031* HTML5的语法规则相比较HTML4更加松散* 总结： * 如何区分HTML和HTML5？ **html5的文档声明去除了约束和版本号，html5的字符编码更加简洁** * DOCTYPE是什么？ **DOCTYPE是文档类型声明** * HTML5有哪些新特性？ **新增了语义化标签,多媒体,地理定位,离线存储,canvas**#### 在开始H5的新特性之前先提一下腻子脚本(polyfill)以及IE版本条件注释 * **IE条件注释功能是条件注释是IE特有的一种功能，能对IE系列产品进行单独的XHTML代码处理，注意，主要是针对XHTML,而非CSS。条件注释功能非常强大，可以进行true和false判断。** * **主要是针对ie6 7 8对支持和让老浏览器支持html5+css3的一些js脚本** **所以这两个东西肯定都是为了兼容老版本的IE浏览器的**语法如下：lte：就是Less than or equal to的简写，也就是小于或等于的意思。lt ：就是Less than的简写，也就是小于的意思。gte：就是Greater than or equal to的简写，也就是大于或等于的意思。gt ：就是Greater than的简写，也就是大于的意思。! ：就是不等于的意思，跟javascript里的不等于判断符相同 123456789101112131415161718192021222324252627282930313233343536373839404142### 然后下面开始是HTML5的新特性：* 新的语义化标签 * 语义化标签的含义？ **答:通过标签就能明白标签中所包含的内容的这样的标签** * 使用语义化标签的好处 1. **可以让文档更加清晰简洁** 2. **可以让开发者更加容易修改和维护** 3. **可以让索搜引擎和残障人士更好的获取网页信息*** 新增了哪些语义化标签 * 主要的： **Headerd** 定义section或page的页眉-----页面的头部 **Nav** 定义导航链接.一般定义导航 **main** 定义主要区域 **section** 定义文档中的节 **aside** 定义内容之外的内容，侧边栏 **footer** 定义section或者page的页脚 * 提问使用这些新的语义化标签跟我们之前使用div有什么区别？ **为了被搜索引擎更好的检索** **为了浏览器实现特定功能（比如阅读功能）** **便于编程人员理解（即使是html5，光靠标签的语义也不够，还是要靠id、name甚至class的css命名来综合体现）** * 次要的： Article 定义文章 Mark 定义有记号的文本 Figure 定义媒介内容的分组,以及它们的标题 figcaption 定义figure元素的标题 details 定义元素的细节 summary 定义可见的&amp;lt;details&amp;gt;元素标题 progress 定义任何类型的任务的进度====&amp;gt;进度条* 新的表单**input 类型 -email邮箱类型 ** ; ; 12**input 类型 -url 网址** ; ;12** input 类型 -search 搜索框** ; t;12input 类型 - number\\(value,max,min,step\\(数字的间隔\\)\\) &lt;lable&gt; &lt;input type=&quot;number&quot; name = &quot;number&quot; class = &quot;number&quot; min=&quot;0&quot; max = &quot;100&quot; step = &quot;2&quot;&gt; &lt;/lable&gt; 12input 类型 -range\\(value,max,min,step\\)滑块 &lt;lable&gt; &lt;input type=&quot;range&quot; name = &quot;range&quot; class = &quot;range&quot; min=&quot;2&quot; max=&quot;100&quot; step=&quot;2&quot;&gt; &lt;/lable&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613**Input 类型 - Date Pickers（time, date, month, week, datetime-local）*** 多媒体（视频与音频）* Canvas绘图* 数据存储* 离线应用* 地理定位* 酷炫狂拽屌炸天的CSS特效### SGML HTML XML 之间有什么关系？ SGML:（标准通用标记语言） SGML 是一个标准，告诉我们怎么去指定文档标记。他是只描述文档标记应该是怎么样的元语言，HTML是被用SGML描述的标记语言。 现在解析SGML是一件痛苦的事情，所以创建了XML使事情更好。XML使用了SGML， 例如：在SGML中你必须使用起始和结束标签，但是在XML你可以有自动关闭的结束标签。 XHTML创建于XML，他被使用在HTML4.0中。你可以参考下面代码片段中展示的XML DTD 总之，SGML是所有类型的父类，较旧的HTML利用SGML，HTML4.0使用派生自XML的XHTML 因此利用SGML创建了HTML参照和必须共同遵守的DTD，你会经常在HTML页面的头部发现“DOCTYPE”属性， 用来定义用于解析目标DTD HTML5:（超文本标记语言） HTML5是最新的HTML标准，他的主要目标是提供所有内容而不需要任何的像flash，silverlight等的额外插件， 这些内容来自动画，视频，富GUI等 HTML5是万维网联盟（W3C）和网络超文本应用技术工作组（WHATWG）之间合作输出的 XHTML xhtml与html严格意义上其实没什么区别，xhtml1.0的开发实际上是作为html4.01与xml2.0的一个过渡的网页版本而存在的， 因为xml的解析语法过于苛刻，简单一句话就是：只要网页中出现一处错误，则浏览器停止解析。 XML:（可扩展标记语言） 自定义XML+XSLT=&gt;HTML，最常见的文档型应用之一。XML存放整个文档的XML数据，然后XSLT将XML转换、 解析，结合XSLT中的HTML标签，最终成为HTML，显示在浏览器上。典型的...### xhtml和html有什么区别 HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言 最主要的不同： XHTML 元素必须被正确地嵌套。 XHTML 元素必须被关闭。 标签名必须用小写字母。 XHTML 文档必须拥有根元素。### Canvas和SVG 异同 相同: 1 都是html5支持的两种可视化技术。基于这两种技术，诞生了很多可视化工具 2 这两种方式在功能上是等同的，任何一种都可以用另一种来模拟。它们都是有效的图形工具， 可用来快速创建在网页中显示的轻型图形；它们都使用 JavaScript 和 HTML；它们都遵守万维网联合会 (W3C) 标准 3 都允许您在浏览器中创建图形，但是它们在根本上是不同的。它们很不相同，他们各有强项和弱点 不同: 1 Canvas 通过JavaScript来绘制2D图形。Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。 如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象 SVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形 2 Canvas 是基于像素的即时模式图形系统，最适合较小的表面或较大数量的对象，Canvas不支持鼠标键盘等事件。 SVG 是基于形状的保留模式图形系统，更加适合较大的表面或较小数量的对象。Canvas和SVG在修改方式上还存在着不同。 绘制Canvas对象后，不能使用脚本和 CSS 对它进行修改。因为 SVG 对象是文档对象模型的一部分，所以可以随时使用脚本和 CSS 修改它们。 3 Canvas 1)依赖分辨率 2)不支持事件处理器 3)弱的文本渲染能力 4)能够以 .png 或 .jpg 格式保存结果图像 5)最适合图像密集型的游戏，其中的许多对象会被频繁重绘 SVG 1)不依赖分辨率 2)支持事件处理器 3)最适合带有大型渲染区域的应用程序（比如谷歌地图） 4)复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快） 5)不适合游戏应用### 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ 行内元素：a b span img input select strong 块级元素：div ul ol li dl dt dd h1 h2 h3 h4 p 空元素：&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;link&gt; &lt;meta&gt;### 页面导入样式时，使用link和@import有什么区别？ 1）link属于XHTML标签，而@import是css提供的； 2）页面被加载时，link会同时被加载，而@import引用的css会等到页面被加载完再加载； 3）@import只在IE5以上才能识别，而link是XHTML标签，无兼容问题； 4）link方式的样式的权重高于@import的权重。### html5 新增和移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？ 新特性，新增元素： 1）内容元素：article、footer、header、nav、section 2）表单控件：calendar、date、time、email、url、search 3）控件元素：webworker，websockt，Geolocation 移除元素： 1）显现层元素：basefont，big，center，font，s，strike，tt，u 2）性能较差元素：frame，frameset，noframes 处理兼容问题有两种方式： 1）IE6/IE7/IE8支持通过document方法产生的标签，利用这一特性让这些浏览器支持HTML5新标签。 2）使用是html5shim框架 另外，DOCTYPE声明的方式是区分HTML和HTML5标志的一个重要因素，此外，还可以根据新增的结构，功能元素来加以区分。### 如何区分 HTML 和 HTML5？ 1）在文档类型声明上不同： HTML是很长的一段代码，很难记住，遵守dtd约束 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt; 而HTML5却只有简简单单的声明，方便记忆。只需要DOCTYPE来规范浏览器的行为 &lt;!DOCTYPE html&gt; 2）在结构语义上不同： HTML：没有体现结构语义化的标签，通常都是这样来命名的&lt;div id=&quot;header&quot;&gt;&lt;/div&gt;，这样表示网站的头部。 HTML5：在语义上却有很大的优势。提供了一些新的标签，比如：&lt;header&gt;&lt;article&gt;&lt;footer&gt; 一个典型的WEB页面包含头部，脚部，导航，中心区域，侧边栏。现在如果我们想在在HTML4的HTML区域中呈现这些内容，我们可能要使用DIV标签。 但是在HTML5中通过为这些区域创建元素名称使他们更加清晰，也使得你的HTML更加可读### html5有哪些新特性 canvas(画布) audio 定义音频内容 video 定义视频（video 或者 movie） 地理定位 web存储 :localStorage 拖拽控制: draggable=&quot;true&quot; 使元素可拖动，把 draggable 属性设置为 true ： 表单 &lt;datalist&gt; 定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。 &lt;keygen&gt; 规定用于表单的密钥对生成器字段。 &lt;output&gt; 定义不同类型的输出，比如脚本的输出。### 请解释一下什么是语义化的HTML。 1 含义:内容使用特定标签，通过标签就能大概了解整体页面的布局结构（在什么情况下我可以使用这个标签才合理） 2 为什么使用语义化标签? 1）用正确的标签做正确的事情； 2）html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析； 3）即使在没有css样式情况下也以一种文档格式显示，并且是容易阅读的； 4）搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO； 5）使于读源代码的人对网站更容易将网站分块，便于阅读维护理解。 3 html语义标签 p 段落 strong和em 加粗 (但strong字面含义更强 推荐 见名知意 也是语义化标签的含义之所在) ul 有序列表用 ol 无序列表用... 4 html5 新增语义话标签 1)header(页眉): 标签:定义文档的页面组合，通常是一些引导和导航信息 2)footer(页脚): 标签:定义 section(章节) 或 document 的页脚。 3)nav(导航): 标签:导航链接放在nav标签里。 4)article(文章): 装载显示一个独立的文章内容 内层的artilce对外层的article标签有隶属的关系 &lt;article&gt; &lt;h1&gt;文章标题&lt;/h1&gt; 这是一篇文章 &lt;article&gt;评论1...&lt;/article&gt; &lt;article&gt;评论2...&lt;/article&gt; &lt;/article&gt; 5)section(章节): 使用内部article去定义区域或者把分组内容放到区域里 &lt;section&gt; &lt;h1&gt;章节一&lt;/h1&gt; &lt;p&gt;详细内容...&lt;/p&gt; &lt;/section&gt; &lt;section&gt; &lt;h1&gt;章节二&lt;/h1&gt; &lt;p&gt;详细内容...&lt;/p&gt; &lt;/section&gt; 6)mark(标记): 标签:定义带有记号的文本。请在需要突出显示文本时使用 &lt;mark&gt; 标签.... 7)&lt;aside&gt;：代表页面的侧边栏内容 总结:1 让对方知道你清楚语义化标签含义 2 让对方知道你清楚为什么用语义化标签 5 让对方知道你了解html5新增了一些语义化标签(举几个语义化标签就行不用全说 因为实际开发也不一定用 ) 是否是新手 回答问题就能听出来 新手问啥答啥 老鬼 会测出一堆相关问题 这也是他们为什么能聊那么长时间### DOCTYPE作用? 严格模式与混杂模式如何区分？它们有何意义? 1）&lt;!Doctype&gt;作用是告诉浏览器 我的html使用的那个版本的html协议写的 让浏览器按照声明的协议执行 2）严格模式的排版和JS运作模式是以该浏览器支持的最高标准运行。 3）混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 4）DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。 ### iframe有那些缺点？ iframe的优点： 1.iframe能够原封不动的把嵌入的网页展现出来。 2.如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。 3.网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的复用性。 4.如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。 iframe的缺点： 1.会产生很多页面，不容易管理。 2.iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条， 会分散访问者的注意力，用户体验度差。 3.代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容， 所以使用iframe会不利于搜索引擎优化。 4.很多的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。 5.iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。 总结:分析了这么多，现在基本上都是用Ajax来代替iframe，所以iframe已经渐渐的退出了前端开发。###常见兼容性问题？ 1）png24位的图片在IE6浏览器上出现背景； 解决方案是：做成PNG8； 2）浏览器默认的 margin 和 padding 不同。 解决方案是：加一个全局的*&#123;margin:0;padding:0;&#125;来统一。 3）IE6双边距bug：块属性标签float后，又有横行的 margin 情况下，在 IE6 显示 margin 比设置的大。 浮动IE产生的双倍距离 #box&#123;float:left;width:10px;margin:0 0 0 100px;&#125; 这种情况下IE6会产生200px的距离。 解决方法：加上_display：inline，使浮动忽略 4）IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute()获取自定义属性； 使用获取常规属性的方法来获/取自定义属性：getElementbyId(&quot;#box&quot;).Attributes[&quot;属性名&quot;] Firefox下，只能使用getAttribute()获取自定义属性。 解决方法：统一通过getAttribute()获取自定义属性。 5）IE下，even对象有x，y属性，但是没有pageX，pageY属性， 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。 6）Chrome中文界面下默认会将小于 12px 的文本强制按照 12px 显示 解决方法：可通过加入 CSS 属性 -webkt-text-size-adjust:none;解决 7）超链接访问过后 hover 样式就不出现了，被点击访问过的超链接样式不在具有 hover 和 active ； 解决方法：改变CSS属性的排列顺序：L-V-H-A: a:link&#123; &#125; a:visited&#123; &#125; a:hover&#123; &#125; a:active&#123; &#125; ### 支持HTML5新标签 1)IE8/IE7/IE6支持通过 document.createElement 方法产生的标签， 可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式； 2)当然最好的方式是直接使用成熟的框架、使用最多的是 html5shim 框架 针对IE浏览器比较好的解决方案是html5shiv。html5shiv主要解决HTML5提出的新的元素不被IE6-8识别， 这些新元素不能作为父节点包裹子元素，并且不能应用CSS样式。让CSS 样式应用在未知元素上只需执行 document.createElement(elementName) 即可实现。html5shiv就是根据这个原理创建的。 html5shiv的使用非常的简单，考虑到IE9是支持html5的，所以只需要在页面head中添加如下代码即可： &lt;!--[if lt IE 9]&gt; &lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; &lt;![endif]--&gt;### 简述一下src与href的区别： href: &lt;link href=”common.css” rel=”stylesheet”/&gt; 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。 src: &lt;script src =”js.js”&gt;&lt;/script&gt; 是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内， 例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理， 直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。 这也是为什么将js脚本放在底部而不是头部。### 浏览器的内核分别是什么? IE: trident 内核 Firefox：gecko内核 Safari：webkit内核 (苹果浏览器) Opera：以前是presto内核，Opera现已改用Google Chrome的Blink内核 Chrome：Blink(基于webkit，Google与Opera Software共同开发)### HTML5 中如何嵌入音频？ HTML5 支持 MP3、Wav 和 Ogg 格式的音频，下面是在网页中嵌入音频的简单示例： &lt;audio controls&gt; &lt;source src=”jamshed.mp3″ type=”audio/mpeg”&gt; Your browser does’nt support audio embedding feature. &lt;/audio&gt; ### HTML5 中如何嵌入视频？ HTML5 支持 MP4、WebM 和 Ogg 格式的视频，下面是简单示例： &lt;video width=”450″ height=”340″ controls&gt; &lt;source src=”jamshed.mp4″ type=”video/mp4″&gt; Your browser does’nt support video embedding feature. &lt;/video&gt; ### HTML5 存储类型有什么区别？ HTML5 能够本地存储数据，在之前都是使用 cookies。 HTML5 提供了下面两种本地存储方案： localStorage 用于持久化的本地存储，数据永远不会过期，关闭浏览器也不会丢失。 sessionStorage 同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储### HTML5 标准提供了哪些新的 API？ HTML5 提供的应用程序 API 主要有： Media API Text Track API Applocation Cache API User Interaction Data Transfer API Command API Constraint Validation API History API### 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ cookie: Cookie是在你浏览网页的时候，网站服务器放在客户端（Client End，就是你的电脑）里面的一个小小的TXT文件。 这个文件里面存储了一些与你访问的这个网站有关的一些东西，当你下一次访问这个网站的时候， Cookie就会记住你上次访问时候的一些状态或者设置，让服务器针对性的发送页面的相关内容。 Cookie里面包含的信息并没有一个标准的格式，各个网站服务器的规范都可能不同，但一般会包括： 所访问网站的域名（domain name），访问开始的时间，访问者的IP地址等客户端信息，访问者关于这个网站的一些设置等等 sessionStorage: 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。 因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储 localStorage: 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 web storage和cookie的区别: Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的， 并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。 除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。 但是Cookie也是不可或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生### 为什么利用多个域名来存储网站资源会更有效？ CDN缓存更方便 cnd：服务器 突破浏览器并发限制 节约cookie带宽 节约主域名的连接数，优化页面响应速度 防止不必要的安全问题### img的alt与title有何异同？ strong与em的异同？ alt 是图片加载失败时，显示在网页上的替代文字； title 是鼠标放上面时显示的文字。 strong:粗体强调标签，强调，表示内容的重要性 em:斜体强调标签，更强烈强调，表示内容的强调点### 你能描述一下渐进增强和优雅降级之间的不同吗? 渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始， 并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。 优雅降级: 观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段， 并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。 渐进增强: 观点则认为应关注于内容本身。 内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作， 还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。 这也是它立即被 Yahoo! 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在### 知道的网页制作会用到的图片格式有哪些？ png-8，png-24，jpeg，gif，svg。 但是上面的那些都不是面试官想要的最后答案。面试官希望听到是Webp。（是否有关注新技术，新鲜事物） 科普一下Webp：WebP格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3， 并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。 在质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小40%### 介绍一下 CSS 的盒子模型？ 1）有两种，IE 盒子模型、标准 W3C 盒子模型； IE 的 content 部分包含了 border 和 padding； 2）盒模型：内容（content）、填充（padding）、边界（margin）、边框（border）。### CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3 新增伪类有哪些？ 1）id 选择器（#myid） 2）类选择器（.myclassname） 3）标签选择器（div，h1，p） 4）相邻选择器（h1 + p） 5）子选择器（ul &gt; li） 6）后代选择器（li a） 7）通配符选择器（* ） 8）属性选择器（ a[rel = &quot;external&quot;]） 9）伪类选择器（a: hover, li: nth - child）### 可继承的样式： font-size font-family color, UL LI DL DD DT### 不可继承的样式： border padding margin width height### 载入样式以最后载入的定位为准; 优先级为: !important &gt; id &gt; class &gt; tag ； important 比 内联优先级高 ### 如何居中div？ 给div 设置一个宽度，然后添加 margin:0 auto 属性；div&#123;width:200px; margin:0 auto; &#125;### 如何居中一个浮动元素？ 确定容器的宽高 宽500 高300的层，设置层的外边距(走自己的一半 1/2宽高) .div&#123;width:500px;height:300px;margin:-150px 0 0 -250px; position:relative;background:green；left：50%；top：50%&#125;### css3有哪些新特性？ CSS3 实现圆角（border-radius:8px;）， 阴影（box-shadow:10px）, 对文字加特效（text-shadow）, 线性渐变（gradient）， 旋转（transform） transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转，缩放，定位，倾斜 增加了更多的 css 选择器 多背景 rgba### display:inline-block 什么时候会显示间隙？ display:inline-block布局的元素在chrome下会出现几像素的间隙， 原因是因为我们在编辑器里写代码的时候，同级别的标签不写在同一行以保持代码的整齐可读性， 即inline-block布局的元素在编辑器里不在同一行，即存在换行符， 因此这就是著名的inline-block“换行符/空格间隙问题”。 如果inline-block元素间有空格或是换行产生了间隙，那是正常的，应该的。 如果没有空格与间隙才是不正常的（IE6/7 block水平元素）。 1.给 li 写font-size:0 2.把li标签写到一行，不要在编辑器里敲回车换行，但是这种写法对于标签很多的情况可读性太差， 适用与例如&lt;a&gt;&lt;/a&gt;&lt;a&gt;&lt;/a&gt;这样简单的结构 3.把li的标签改成这样的写法 &lt;li&gt; &lt;span&gt;...&lt;/span&gt; &lt;/li&gt;&lt;li&gt; &lt;span&gt;...&lt;/span&gt; &lt;/li&gt; 移除空格，使用margin 负值、使用 font-size:0、letter-spacing 、word-spacing ### 什么是盒子模型？ 在网页中，一个元素占有空间的大小由几个部分构成，其中包括 元素的内容（content） 元素的内边距（padding） 元素的边框（border） 元素的外边距（margin） 四个部分。 box-sizing: border-box;/*无论是加 border 还是padding 盒子的总体大小都不会改变*/ 这四个部分占有的空间中，有的部分可以显示相应的内容， 而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。### px和em的区别 px: 的值是固定的，指定是多少就是多少，计算比较容易。 em: 得值不是固定的，并且em会继承父级元素的字体大小。 浏览器的默认字体高都是16px。 所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em rem: 是相对于根元素文字大小的一个尺寸单位； 例如：html&#123;font-size：50px;&#125; div&#123;font-size:0.5rem;&#125;/*div中字体大小为：25；### rgba() 和 opacity的透明度效果有什么不同? opacity作用于元素, 以及元素内所有的内容. raba()只作用与元素的颜色或背景色(子元素不会继承透明度效果)### css设置dom元素不显示浏览器可视范围 基本方式: 1 display:none 2 visibility:hidden 技巧性: 3 宽高0 4 透明度0 5 z-index:-100 6 定位出浏览器可视范围### 行内node与块级node区别 行内node是否可以设置padding和maring 行内:display:inline 同站一行 宽高 内外边距的top/bottom都不可以设置, 但是 内外边距的left/right可以设置 块级:display:block 独占一行 可以设置 可以设置宽高 内外边距... 行内块:inline-block 拥有内在尺寸 可设置宽高 单依然不会自动换行 行内快标签: input,img,button,texterea,label### 去除a标签跳转效果 &lt;a href =&quot;javascript:return false;&quot;&gt;这个链接不能点击 &lt;/a&gt; &lt;a href =&quot;javascript:volid(0);&quot;&gt;### css那些属性可以继承 可以: font-size, font-family, color, ul, li, dl, dd, dt 不行: border, padding, margin, width, height### css优先级算法如何计算 !important &gt; id &gt; class &gt; 标签 !important 比 内联优先级高 *优先级就近原则 样式定义最近者为准 *以最后载入的样式为准 1：直接设置 color：red; 2：十六进制方式 color：#00ff; 3: rgb设置 color：rgb(0-255,0-255,0-255); red green blue 4: rgba color:rgba(0-255,0-255,0-255,0-255,0.1);### css有3种书写方式 1 ：外联式：：新建css 内部引用 &lt;link href=&quot;css 文件路径&quot; rel=&quot;&quot;&gt; （主要写法 推荐） 1）：该写法影响范围比较广，整个站点 2）：完全实现了html结构与样的分离（代码可维护性比较好） 2 ：内嵌式 ：在头部的style 中书写 1）：只会影响当前页面样式的改变 2）：没有实现html结构与样式的完全分离 3 ：行内式写法 ：直接在标签内些style 1）：影响只有当前标签 2）：没有实现html结构与样式的分离### css的特性： 1 层叠行： 当同一个标签（权重一样）的样式发生冲突的时候，最后定义的样式会将前面定义的样式覆盖掉（层叠性）。 与样式定义的顺序有关，和样式调用的顺序无关 2 继承性：标签之间的关系属于嵌套关系 可以被继承的属性：有关文字的相关属性都可以被集成 如 颜色 大小 行高 字体 注意：1 a标签不能直接使用父元素中的文字颜色。 2 标题标签不能直接使用父元素中的文字大小。 ### 伪类 ：用来向选择器定义样式或添加特定的效果.常用的伪类还有focus nth-child等 1 a:link &#123;属性: 值;&#125; 设置a标签默认样式 2 a:visited &#123;属性: 值;&#125; 链接访问过后的样式 3 a:hover &#123;属性: 值;&#125; 鼠标移动到超链接上的样式 4 a:active &#123;属性: 值;&#125; 链接激活状态下的样式 注意:link :visited :hover :active（L oVe H A te顺序）爱 与 恨 (顺序书写) 可以解决 a标签在四种状态中出现的小问题 5 a:focus&#123;属性: 值;&#125; 获取光标焦点的样式 6 :first-child 向元素的第一个子元素添加样式 7 :last-child 向元素的最后一个子元素添加样式### CSS3新增伪类举例： p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素； p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素； p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素； p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素； p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素； :enabled :disabled 控制表单控件的禁用状态； :checked 单选框或复选框被选中。### 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）：输入地址1.浏览器查找域名的 IP 地址2.这一步包括 DNS 具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存…3.浏览器向 web 服务器发送一个 HTTP 请求4.服务器的永久重定向响应5.浏览器跟踪重定向地址6.服务器处理请求7.服务器返回一个 HTTP 响应8.浏览器显示 HTML9.浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）10.浏览器发送异步请求 ### Overflow的用法 1 overflow：hidden 将超出盒子部分的内容隐藏 2 overflow：scorll 添加滚动条 3 overflow：auto 自适应 ### 定位(position) : 定位的元素常与具体的方位名称配合使用 left top right bottom 1 静态定位(static) 页面中的标准流下的盒子，都是静态定位的盒子 2 绝对定位(absolute) （看脸型） ---- 脱标------ 不占位 ----- 实现模式转换 1 父元素没有设置定位，子元素设置绝对定位，子元素是以浏览器左上角为基准设置定位。 2 父元素设置了定位，子元素设置绝对定位会以父元素左上角为基准设置定位 3 元素设置了绝对定位后，该元素不占位置（脱离标准流） 4 绝对定位可以实现模式转换 3 相对定位 (relative) （自恋型）---- 未脱标------ 占位 ----- 不能实现模式转换 1 如果一个元素设置了相对定位，那么该元素会以自己原来的位置为基准设置定位 2 设置了相对定位的元素，该元素占位置（没有脱标） 3 设置了相对定位的元素，不能实现模式转换 4 一般情况下，设置子绝父相 4 固定定位(fixed) ---- 脱标------ 不占位 ----- 实现模式转换 1 设置了固定位的元素 只会看浏览器的左上角 2 设置了固定位的元素 脱离了标准流 不占位置 3 固定定位的元素实现了模式转换### Z-index(层级) 1 元素与元素之间的层级关系 2 在css2中，只有定位的元素才有z-index 3 默认情况下，定位的元素z-index的值auto (0) Z-index可以取正数还可以取负数。 特点: 1 如果两个元素都设置了定位，那么后面定位的元素会覆盖前面定位的元素（后来居上） 2 如果想让一个盒子压另一个盒子，可以设置z-index值。 3 如果元素的父元素设置了z-index值，那么程序会以父元素的z-index值为准### vue生命周期钩子 1.beforcreate 2.created 3.beformount 4.mounted 5.beforeUpdate 6.updated 7.actived 8.deatived 9.beforeDestroy 10.destroyed### js跨域请求的方式，能写几种是几种 1、通过jsonp跨域 2、通过修改document.domain来跨子域 3、使用window.name来进行跨域 4、使用HTML5中新引进的window.postMessage方法来跨域传送数据（ie 67 不支持） 5、CORS 需要服务器设置header ：Access-Control-Allow-Origin。 6、nginx反向代理 这个方法一般很少有人提及，但是他可以不用目标服务器配合，不过需要你搭建一个中转nginx服务器，用于转发请求 ### 对前端工程化的理解 开发规范 模块化开发 组件化开发 组件仓库 性能优化 项目部署 开发流程 开发工具 ### js设计模式 总体来说设计模式分为三大类： 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模### iframe有那些缺点？ iframe会阻塞主页面的Onload事件； 搜索引擎的检索程序无法解读这种页面，不利于SEO; iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。### css容易混淆属性 text-indent: 2em; /* 设置首行缩进两个汉字 Logo优化内容移除*/ text-align: center; /* text-align给块级元素设置，其文本会水平居中 */ text-decoration: none; /*去掉下划线*/ font-style: italic ; /* 文字斜体显示*/ font-weight: 700; /* 文字加粗显示*/ line-height: 20px; /* 设置文字的行高*/ line-break: normal; /*应用日文文本的默认换行规则*/ list-style: none; /* 去除列表前面的图标*/ disabled:true; /*禁用文本框*/ disabled:false; /*解禁文本框*/ outline-style: none; /* 去掉输入框的默认轮库线*/ overflow: hidden; /*1 触发元素的bfc(格式化上下文) 解决外边距塌陷问题 2 将多余部分隐藏 可设置 水平 垂直方向的如 ： overflow-x: hidden; overflow-y: hidden; 3 给父元素这是 可以清楚浮动 * * */ overflow: auto; /*给添加滚动条 可设置水平 */ overflow：hidden； /*超出的部分隐藏 */ visibility：hidden； /*元素隐藏 该属性隐藏元素后，元素占位置*/ display：none: ; /*元素隐藏 隐藏元素不占位置*/ display: block; /*显示元素*/ display: inline; /* 转化为 行*/ display: block; /* 转化为 块*/ vertical-align: baseline /*只对img/img4和表格起作用*/ vertical-align: middle; /*垂直居中对齐*/ border-collapse: collapse; /* 合并边框 与 表格属性中的 cellspacing=&quot;0&quot; 一样*/ white-space: nowrap; /*将行内快元素在一行上显示*/**备注：** 前端的路上我们一起携手共进！如果转载，请标注本链接地址。` ​MIT ©杨方涛 Email:58267980@qq.com","categories":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://lzws0931.cn/categories/面试宝典/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://lzws0931.cn/tags/面试/"}]},{"title":"法门扫地僧的第一篇博文","slug":"hello-world","date":"2018-03-15T16:21:00.000Z","updated":"2018-03-19T13:54:23.732Z","comments":true,"path":"2018/03/16/hello-world/","link":"","permalink":"https://lzws0931.cn/2018/03/16/hello-world/","excerpt":"","text":"Welcome to Hexo! 纪念1234567经过三天的踩坑，走弯路，我终于把自己的技术博客搭建起来了，本博客用的是 hexo+github page 搭建起来的。买了两个域名，目前正在备案中，等审核通过，那么我就正式拥有自己的个人博客了，还没规划好做什么类型网站，等有想法初成，一定打造好自己的小窝！ 对MD文档的书写规范还不是很熟练，慢慢摸索，慢慢成长。感谢miho主题开源者: MinHow我在原来模版基础之上进行了DIY部分修改。 感谢您的到访。","categories":[{"name":"博客制作","slug":"博客制作","permalink":"https://lzws0931.cn/categories/博客制作/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://lzws0931.cn/tags/生活/"}]}]}