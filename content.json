{"meta":{"title":"法门扫地僧的一亩三分地的前端开发工程师H5开发HTML5CSSJavascript","subtitle":null,"description":null,"author":"扫地僧","url":"https://lzws0931.cn"},"pages":[{"title":"关于我","date":"2018-03-19T11:07:48.000Z","updated":"2018-03-21T16:35:35.038Z","comments":true,"path":"about/index.html","permalink":"https://lzws0931.cn/about/index.html","excerpt":"","text":"关于我我用了10年的网名和头像【法门扫地僧】嗯呢，我目前属于半个程序员，注意技术点是偏向前端开发，主要开发语言 前端洗剪吹，熟悉使用 HTML、CSS 和javascript等技术。对后端、前端、运营等技能有所了解。 热爱开源项目、热爱新技术、热爱新事物。 关于工作城市：长安 关于学习学海无涯，不要回头。 关于目标 减肥，挣钱，技术牛逼。 关于爱好没有什么嗜好，爱好也不是很广泛，有时候有点宅。 联系我 Email: 58267980@qq.com Blog: www.lzws0931.cn GitHub: 法门扫地僧 WeiBo: 法门扫地僧 博客园: 法门扫地僧"}],"posts":[{"title":"法门扫地僧前端简历经验分享","slug":"法门扫地僧前端简历经验分享","date":"2018-09-13T14:35:09.000Z","updated":"2019-01-24T04:54:48.882Z","comments":true,"path":"2018/09/13/法门扫地僧前端简历经验分享/","link":"","permalink":"https://lzws0931.cn/2018/09/13/法门扫地僧前端简历经验分享/","excerpt":"","text":"Front-End前端开发工程师面试宝典！ （本文部分有转载，不定期更新！） 前言（README.md）12本仓库是我整理的前端常见面试题，大部分由我整理，其中个别部分参考网上其他资料，感谢！ 本资料仅供大家学习参考使用！欢迎大家Star和提交issues。 NO.1 READMENO.2 简历经验分享NO.3 angular常见问题NO.4 前端面试宝典第一版NO.5 前端笔记版本第二版NO.6 前端笔记版本第三版NO.7 前端笔记版本第四版NO.8 vue常见问题 欢迎大家一起交流提高简历经验分享1、简历的重要性找工作，难吗？并不难，但是简单吗？并不简单，因为面试，从你投递简历的那一刻已经开始了。面对日趋激烈的就业压力,准备就业的你，做好心理准备了吗？找工作之前，我想请问你一句话，如果你是一家公司，你会招聘你这样的人才吗？ 2、言简意赅面试，首先就是要有一个像样的简历，能拿的出手的简历，要让面试官知道你是谁，你来干什么，你能做什么，你能给我带来什么？这是最基本的，除此之外，简历是我们必不可少的，简历，简单的履历。不需要长篇大论，也不要一张纸敷衍了事。找工作！最开始竞争的就是简历！因为你到任何一个招聘单位要做的第一件事情就是要投递简历，而简历就是那些单位了解你的第一扇窗口。因此简历就成了你和单位沟通的第一通道，往往是招聘人员了解你的第一个途径，适度的引起用人单位对你的兴趣才是最重要的。一份好的简历，可以在众多求职简历中脱颖而出，给招聘人员留下深刻的印象，然后决定给你面试通知，它是帮助你应聘成功的敲门砖。 3、基本信息个人信息：根据不同情况，个人信息由必要和可选之分：必有信息：姓名、联系方式（手机、固定电话、Email、邮寄地址）。可选信息：性别、年龄、政治面貌、籍贯、民族、照片等。注意，自己根据自己需求进行填写，比如面试外企，就尽量不用写政治面貌，还有尽量写年龄，而不是写生日或者出生年月日，写年龄是为了面试官的体验，他直观的就能推测你多少岁大学毕业，几年经验，等等，还有手机号码采用344格式：132-1234-1234等等 4、教育经历 教育经历和工作经历还有项目经验一般按照时间逆序的写法来写，也就是说把最近的教育经历写在前面，比如你自考本科，那么把本科写在前面，当然，大专阶段可以写，也可以不写。如果要写的话，时间上需要衔接。最近的学历放在最前面，即如果你现在是即将硕士毕业，那么要先写硕士再写本科。大学以前高中阶段、初中阶段经历一般不写。 ​ 每段教育经历都应有起止日期的时间段，有助于让HR了解你的毕业日期或者看到你接受教育的成长轨迹。学校：便于HR能迅速识别你的学历，如果就读的是名校，校名可能对你应聘有所帮助，这种情况下，建议将学校校名加粗显示。如果你就读的是非名校，则可以不用加粗显示、专业：如果是应聘专业对口的职位，那么专业一定要加粗强调。若你是跨专业求职，有双学位或者有相关的辅修经历，那么辅修的专业要加粗强调。 ​ 如果你的学校是非名校，主专业也与职位要求不对口，且没有学习过相关的课程或者辅修经历，那么在这种严峻的教育硬伤下，你可能需要在简历中将教育背景往下调，弱化教育背景，转而强调其他与职位相关的实习经历或者社会实践经历。总而言之，应根据职位和自身情况做到突出优势，规避劣势。相关课程：不建议写，因为你学过和你会是两个概念，你可以把你的会的东西当做专业技能来展示。 5、工作经历工作经历：一般来说是简历的重点内容，如果有相关著名公司的话，那通过简历筛选的几率很大。因为相关的工作经历最能够体现与职位要求的技能。而对于应届毕业生来说，可以把自己的实习经历写上去，实习经历、兼职经历可以有效地弥补这一软肋。 工作经历一般就是说你在那家公司待了多长时间，什么岗位，你干了那些事情，或者说负责哪方面。 6、项目经验 项目经验：一般来说，项目经历往往反映的是求职者某个方面的实际动手能力、对某个领域或某种技能的掌握程度。一般在应聘IT类职位项目经历的描述是比较重要的。对于面试计算机的人来说，简历中项目的含义一般包含两个层面： （1）相关研究课题项目。课程设计，或者毕业论文都可以，或者你在大学期间实习做的项目都可以展示出来，如果自己做过的项目获得过奖项，那更好了，而毕业论文的内容中一般会有对应的研究背景、相关的调研、实验、数据统计及分析。做课题、写毕业论文的过程就是一个解决问题的过程，在这个过程中，我们必须学会获取大量信息、筛选有用信息，掌握分析问题、解决问题的方法，这样才能完成毕业论文。在这个过程中所锻炼的信息分析处理、某种软件的应用技能、书面表达等能力，也是你的求职砝码，可以在简历中呈现给HR。 而对于有些人没有太多的项目经验，那么你就应该把你自己自学或者做的项目适度的经历去阐述给面试官，面试中甚至可以带上自己的作品或者上次到github，展示给面试官也是很加分的，例如：在公司实习的经历中，曾经有过负责或参与公司某个项目的调研、立项或者实施，自己在项目中扮演着很重要的角色或者做了很重要的工作、贡献，那么可以单独将在这个公司实习的这段项目经历提取出来，重点描写，从而突出自己的相关技能水平。 7、自我评价自我评价，就是简单的夸夸自己，低调的告诉面试官，你很牛逼，但是要适度哦。 8、咋投递捏？招聘条件并非绝对限制，不要被招聘要求上面写到的专业，户口，工作经验或者211,985所吓到，和公司的规定条件不吻合还是有任用的机会的，有些东西往往只是一个限制标准而已，如果职业适性非常相合，也有丰富的经验，出线机会仍是非常浓厚。不管如何，如果你对该公司真的很有兴趣，不妨先试试看。 9、简历写作的原则：​ 1.关键词说话，HR平均浏览一份简历的时间不超过30秒，在这么短的时间内，HR主要是通过查看简历中是否有相关的关键词来进行判断。关键词的作用尤其在网申简历中更为明显。如果你是应聘互联网行业相关度的职位，HR可能会对简历中的“网站”、“流量”、“×××××.com”（网址域名）等关键词比较敏感； ​ 2.行为词说话，在描述过去经历的时候，无论是实习兼职经历还是工作经历，都需要把自己做的事情用清楚详细的、表示动作的词语（即行为词）叙述出来，形式上一般建议采用行为词开头的短句群。同样一段经历，是否掌握行为词的描述方法，其经历描述的效果也大相径庭。 ​ 3.用数字说话，不要说用户访问量大大提高，大大是多大？也不要说网页性能有了显著提高，有多显著？简历里的数字更能凸显个人亮点，吸引HR眼球，比如你自己封装了一个小插件，使你们项目进程提高了一周。 ​ 4.结果说话，想达到一份优秀简历的水平，你必须在简历中学会用客观的结果说话。这也就是在之前介绍工作实习经历描述中提到的“PAR法则”中的“R(Results)”，即结果，一般指业绩、成绩等。我们不仅要在简历中告诉HR，我们做过什么，而且通过描述我们做得怎么样，来向HR证明我们具备相关的素质、能力、经验。 ​ 5.真实性原则，没有必须要捏造一些四级或者六级或者一些证书，实事求是，我们干技术的，是凭借技术来征服的，证书只是锦上添花的事，不要为了提高简历的含金量去弄虚作假，但是我们可以适度的去活学活用，或者借鉴，比如，我面试的时候有人事问我，你大学当过学生会干部吗，我没当过，但是我宿舍哥们当过，那我是不是可以把他的经历说一下，这不叫欺骗，这是叫适度包装。 ​ 6.独特性原则，面试之前，我们应该考虑一下，我们比别人的优势在那里，同一个岗位，凭什么要你，不要别人？对于HR而言，对于简历中不同的履历，技能都能让HR眼前一亮，而这些比其他都东西更能让面试官记住你。 ​ 还有一点需要注意，创业经历，一般请适度表达，因为有时候会给面试官一些你不太稳定的感觉，所以问道这方面问题，请慎重回答，要让面试官知道你是一个安分守己的好员工。 10、优秀简历的特点言简意赅，强调成功的经验 简历内容要真实，重点突出 传递有效信息，使用有影响力词汇 突出自己技能，适当引用专业术语 11、简历和求职信有些公司比较喜欢自荐，这个时候最好写个求职信，求职信就是你找工作的时候，写给这家公司人事部对这个公司和这个岗位的一些看法，但是切忌指手画脚。一般自荐信建议手写，一百来字就可以，而在这百字之间你就要强调你很适合这个岗位。 求职信是针对个人来写的，简历是针对岗位来写的，而求职信更要突出个人的特征和求职意向，打动招聘者的心，求职信带有私人信件的性质，应有一定的感情色彩，行文要流畅，晓之以理，动之以情，既有说服力，又有感染力，让人相信你的资质，人品和能力。 12、求职信一般由三部分组成：开头、主体与结尾。 1、开头部分。包括称呼与引言。称呼一般是姓加职衔或官衔。一般以其高者尊者称呼。 2、主体部分。是求职信的重点，要简洁而有针对性地概述自己简历的内容。要突出自己的长处和优势，使对方觉得你的各方面情况与招聘条件相一致，与有关职位要求、特点相吻合。写作的具体内容，有关专家概括为如下5个方面： (1)简述你的主要求职资格、工作经验、参加过的有关社会活动、个人的兴趣和爱好。 (2)表述你具备的教育资历、工作经验和个人素质。①谈谈你为这项目标工作做了哪些教育准备，即你所受的哪些教育与目标工作的任职资格有关;②谈谈你过去所受的专业训练和工作经验以及和目标工作的相关性;③以事实证明你具有目标工作要求的个人素质;④举例说明你具有对做好目标工作的其他有利条件。 (3)要以成熟而务实的语气叙述。①切勿夸大其辞、自吹自擂;②提供你在学业上和工作中取得的重要成就，来证明所声言的资格和能力;③谈论一下目标单位的有关情况，表明你对其已有了解，并愿意为之效劳。 (4)重申你的求职动机，简要说明你对未来的设想。 (5)提示说明你在求职信后的有关附录或附件。 3、结语部分。要令人回味而记忆深刻。要把你想得到工作的迫切心情表达出来，请用人单位能尽快答复你，以恰当恳切的方式请求安排面谈。内容要具体简明，语气要热情，诚恳，有礼貌，别忘了向对方表示感谢。 求职信应该体现出自己的特色，在遵循上述一般原则的前提下，要开动脑筋，以自己的方式来赢得招聘者的青睐。​​ 求职信写作要求 求职信文字一定要简洁，字数最好不要超过1000字，它一般由几部分组成： 1)你所申请的职位和招聘信息来源; 2)表述你对该职位产生浓厚兴趣，并说明这种兴趣与你的理想追求或专长有关; 3)与申请职位有关的资历和经验和成绩都是非常重要的证明材料，说明你适合这个职位的原因; 4)表示如能得偿所愿，自信必能胜任此项工作; 5)提醒收信人留意你附呈的个人简历，并请求对方作进一步回应，如及早答复、予以安排面试等。 求职信的第一句话是最重要的，也是最难写的。其实有许多可取的写法，你可以说明是从什么渠道得知公司招聘信息，也可以叙述自己最有利的条件，不过最不稳妥的办法是参照广告的内容作自我介绍。第一句话(不包括称呼)的作用有二：一是吸引对方阅读你的信件;二是引导对方自然而然地进入你所突出的正题而不感到突然。 归纳起来，求职信的第一句话有以下几种形式： 1)概述式。用一句话概括你具备的最重要的求职资格和工作能力。 2)提名式。提及一为建议你到用人单位求职且为用人单位所熟悉和尊崇的人(记住连名带写上，后面可称呼其职衔或官衔，也可以称“先生”或“女士”)。 3)提问式。针对用人单位的需求和目标，提出一个设问，然后表示你真诚希望自己能够帮助他们实现目标。 4)赞扬式。赞扬用人单位近期取得的显著成就或发生的明显变化，然后表示渴望为其效力。但记住语气不要过度热情。 5)应征式。说明你通过什么途径看到用人单位的招聘广告，并肯定自己的条件基本满足广告提出的要求。 6)独创式。用一个新奇的、能表现你在某些方面才华的句子开头，但申请的职位必须是那种需要丰富想像力的类型，如广告文案、平面设计、装潢设计等。 13、如何让你的简历更加精彩1.回顾过去，表面目标，职业OR成就，还有最重要的事简历的格式，有些人连行间距字间距都不会调整。 2.放大你的卖点，在简历中需要求职意向要避免含糊笼统、毫无针对性。 在我们的求职意向中，我们应该体现出我们能为雇主做些什么，而不是雇主能给我们什么。 14、提高网申简历的投递技巧1.采用行业招聘网站求职 2.简历要与大公司沾边 3.经常刷新简历 4.不要只应聘最近三天的职位 5.让你的邮件永远在最前面 6.新颖的邮件标题 7.自己要学会让简历与职位匹配（不要太在乎对方职位要求的描述，很多职位描述只是写写，连经理都不知道要招什么样的人，如果你看到对方职位要求本科，你是专科就不敢投递简历，那就失去机会了。如果你看到对方要求有5年经验，你只有3年经验，你也不敢投，那完全没有必要。因为人事经理们对职位的描述只是例行公事随便写写而已，你千万不要当真！） 15、简历成功的要素1.态度端正，当你填写个人简历时，选一个可以静下心来的场所，梳理好自己的头绪：你要什么样的工作？你有什么样的优势？你有什么样的发展计划？而不是不经过思考简单将自己的经历和信息全部填进各种表格，让HR来判断你能做什么。你需要思考，提炼和总结，给出一个肯定和结论性的答案。像高考作文一样慎重对待你的简历，HR一定感受得到。 2.强调技能，把你的专业技能要表现出来，你会什么，用过什么，用什么技术点做过那些项目？ 16、简历中避免的错误1.打字或者语法错误，或者专业术语运用不当。 2.缺乏细节 3.没有用心，网上随便找一个简历改个名字就投递。 4.缺乏吸引的动词。 5.简历模版视觉上太花哨或者太low 6.联系方式错误，如果你的简历联系方式都错误，那你在工作种肯定也细心不到哪里去。 17、简历整体1234561.写好的简历，和同桌相互交换，检查已成文的个人简历，绝对不能出现错别字、语法和标点符号方面的低级错误。2.个人简历字体最好采用宋体或微软雅黑,尽量不要用花里呼哨的艺术字体和彩色字, 排版要简洁明快，切忌标新立异。3.简历一定要言简意赅，不用的信息不要写，而对你申请的工作有意义的经历和经验绝不能漏掉。4.你的个人简历越短越好（2-3页，最后一张不要弄个半页），招聘人不愿意花太多的时间阅读一篇冗长空洞的个人简历。5.你的个人经历顺序应该从现在开始倒过去叙诉，这样可使招聘单位在最短的时间内了解你最近的经历。6.在结构严谨的前提下，要使你的个人简历富有创造性，使阅读者能产生很强的阅读兴趣。 18、前端的职业技能展示（其实，你可以去招聘平台看公司的招聘要求，他要求会什么，你把自己会的技能点写上即可。） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151首先，你得精通这些技术单词的拼写吧！！！格式要统一，细节决定成败JavaScript、HTML、CSS、、jQuery、Zepto.jsHTML5、CSS3、移动Web、Ajax、BootStrap、LESS、SASS、CanvasJSON、JSONPRequireJS、SeaJSGrunt、GulpAngular.js、React.jsNode.js______________1.git属于分布式版本控制系统，是用于方便合作和版本控制的2.sublime是编辑器，类似于nodepad++,ultraEdit，是增强版的文本编辑器。3.sass和compass是css预处理器，可以变量、嵌套、混入(Mixin)、继承、导入、函数和操作符等，使css更具模块化和更加方便，基于ruby4.node是javascript的运行环境，基于google的V8 javascript引擎写的，可以将javascript扩展到服务器端。5.npm是包管理工具，类似的有bower，homebrew等（Bower – Js库依赖管理工具。当你需要jquery时，不需要手动下载，只需要执行 bower install jquery，自动安装依赖组件、组件依赖检测、版本兼容自动检测）6.gulp是自动化构建工具______________1.熟练使用HTML/CSS，能够书写符合W3C标准的页面，能够兼容主流浏览器，可以精确还原设计图.2.熟练使用JavaScript，可以脱离类库，用原生JS代码编写常见的网页特效，熟知DOM结构，可以实现代码优化，书写高质量代码3.熟练使用HTML5和CSS3相关技术开发手机等移动端和PC端前端应用;4.熟练使用jQuery库，了解Bootstrap进行网站开发,5.熟练使用zepto.js进行移动web开发；6.对Ajax交互、json和Jsonp交互有较好的理解和应用，了解http协议7.能够使用面向对象封装自己的框架，实现常用的功能，了解组件化开发，设计模式 8.熟练使用git、grunt/gulp对代码进行管理和构建，npm、bower等依赖管理工具；9.熟练使用angular熟悉MVC/MVVM框架模式；可以运用seajs，requirejs进行项目开发10.熟练使用ionic 进行移动app开发；11.可以运用seajs，requirejs进行项目开发，了解less、sass、React Native、node.js____________1.熟练使用HTML、CSS构建页面，有良好的代码编写能力，能精准还原符合3WC标准的页面。2.熟练使用JQuery和原生的JavaScript实现页面交互功能。3.掌握Ajax，能够实现前后端数据的交互，实现页面的异步加载。4.掌握并能够运用HTML5+CSS3的新功能。5.理解并掌握DOM、BOM、XML、JSON等。6.了解面向对象思想、能进行实际运用。7.了解bootstrap，能够用其搭建页面，实现响应式网站开发。8.了解node.js、angular.js，了解MVC思想。9.了解git、glup、npm等管理工具的使用方法。 ————————————熟练掌握html、div+css布局，手写符合w3c标准规范的页面代码；熟练javaScript，掌握常用的插件以提高工作效率。可根据项目需求用原生js写针对特定问题的库。熟练运用html5、css3进行移动端的页面开发。熟悉运用ajax技术处理后台数据，熟悉浏览器和服务器交互机制，依据接口文档与后台进行交互。熟悉js面向对象中的继承、封装、单体模式、工厂模式、原型模式等，坚持降低程序耦合度、提高代码复用性的设计理念，使代码高度模块化。能使用jQuery,bootstrap等框架实现轮播图等特效功能的加载机制，了解angularJS的相关应用;熟练使用sublime ，WebstromPhotoshop等开发工具————————————1.熟悉使用Fireworks、photoShop等软件切图并使用html与css精准还原设计稿并保持良好结构。2.熟悉javaScript并封装过小型类jQuery框架。3.可使用CSS3与HTML5实现3D旋转以及炫酷动画效果、熟悉canvas开发，能独立处理主流浏览器的兼容性问题。4.熟练使用JavaScript、jQuery，可以脱离类库，用原生JS代码编写常见的网页特效，并熟知DOM结构5.能熟练运用Ajax和模板引擎与后台进行数据交互，可利用JSONP实现跨域调取各个开放平台提供的API。6.有Bootstrap，requireJs，angularJs等前端主流框架的使用经验。7.熟悉NODE.js网络编程、MVC框架、MVVM框架，理解http基本原理，熟悉使用npm命令行工具及包管理工具开发项目并发布到npm生态圈。8.了解PHP基本API的使用，能与后台人员友好的交流。————————————1、 精通HTML和CSS ,能够书写语义合理、结构清晰、易维护的页面结构,高度还原设计图;2、 熟悉原生JavaScript ,完成页面交互和功能的实现 ,同时对jQuery能够熟练使用;3、 熟练使用HTML5和CSS3技术,熟悉bootstrap框架能够编写移动端网页制作和响应式布局 ,实现一个页面适配多种终端;4、 熟练掌握HTTP协议相关知识 、Ajax、php等相关技术,能够完成对页面的渲染,与后台开发人员一起完成交互程序;5、 熟悉面向对象编程、DOM编程;6、 对前端模块化开发有一定的了解 ,了解前端MVC框架、AngularJs;7、 可使用git管理代码;————————————1、掌握面向对象的特性，了解闭包、原型链、this等概念。2、掌握框架封装原理，能够通过原生的方式，对框架实现的基本理念有自己的理解；深刻理解移动App的开发模式和技术选型3、能够熟练使用前端工作流工具；4、理解MVC/MVVM设计思想，熟悉移动App的开发模式，能够基于流行的技术进行前端App开发；5、熟悉nodejs的全栈式解决方案，能够根据业务需求在众多框架中进行技术选型；6、熟悉软件开发中整个项目的生命周期，了解主流的后台开发技术以及相应的前后端协作方式。7、掌握前端MVC/MVVM框架实现机制，通过angularjs的实践深刻理解MVC的开发模式，理解双向数据绑定等相关概念。8、掌握移动端混合开发模式，通过ionic/angular的结合，理解使用html5css3/js实现APP开发的整体流程和实现机制。9、掌握移动端ReactNative的开发模式，通过实例展示框架在app开发上的独特之处。————————————1. 熟练使用HTML/CSS，能够书写符合W3C标准的页面，能够兼容主流浏览器，可以精确还原设计图；2. 熟悉W3C标准与ES规范，编写易读、易维护、高质量、高效率的代码；3. 熟练使用JavaScript，可以脱离类库，用原生JS代码编写常见的网页特效，熟知DOM结构，可以实现代码优化，书写高质量代码； 4. 掌握jquery、zepto库的使用；5. 熟悉Angular 框架，熟悉MVC/MVVM框架模式； 6. 熟悉AJAX、JSON数据处理机制，了解前后端的交互；7. 擅长HTML5，CSS3方面的应用，熟悉移动端开发，对手机终端的适配问题可以解决；8. 理解MVC/MVVM设计思想 ，了解HTTP网络通信协议；9. 热衷于web开发技术，对node有一定的使用经验；10.熟练使用git、github/gutlub对代码进行管理和构建，npm、bower等依赖管理工具；11.能够使用面向对象封装自己的框架，实现常用的功能，了解组件化开发———————————1、熟练掌握HTML、CSS等网页布局技术，能熟练运用DIV+CSS来制作静态页面。2、熟练掌握JavaScript技术，能用原生js封装特定功能模块。3、熟练掌握jQuery库，能够熟练运用jQuery API实现网页特效。4、熟练运用CSS3、HTML5制作炫酷的页面特效。5、掌握angular等流行框架的使用，充分了解了angularjs的双向数据绑定，路由，模块化，依赖注入等功能。6、熟悉ajax、Json实现页面的异步加载及前后端数据处理机制，了解前后端数据的交互机制能够熟练使用bootstrap模板，制作响应式网页。7、熟悉了解MVC的设计模式，了解HTTP网络通信协议。8、热衷于前端开发工作，对nodejs有一定的使用与了解。————————————1.熟练使用HTML,CSS构建页面，有良好的代码编写习惯2.理解并掌握DOM,BOM,XML,JSON3.熟练使用JavaScript实现动态网页的交互，熟练jQuery框架完成各项工作4.掌握Ajax技术，能够实现前后端的数据交互，实现页面的异步加载5.熟练运用CSS3的新特性，熟悉HTML5的新功能6.了解面向对象思想，并且能实际运用7.精通bootstrap，能够搭建页面实现响应式网站开发8.精通angularJS框架，了解MVC思想，实现todo单页面应用案例9.了解git gulp npm等管理工具的使用——————————————————1. 精通html,css,可合理利用语义化标签搭建结构清晰，易于维护的页面；2. 能够处理主流浏览器兼容性问题3. 熟练掌握原生JavaScript，能够熟练进行页面交互功能实现。4. 掌握 webstroms, sublime, photoshop， fireworks等开发软件的使用； 5. 熟练html5与css3 ;6. 熟练掌握Ajax，json等技术，实现与后台交互，实现页面异步数据加载；7. 熟悉面向对象编程,可进行常用功能插件开发；8. 了解git、npm等管理工具的使用方法;9. 拥有较强的学习能力和理解能力，能够独立解决和分析问题————————————————1.熟练使用html，css构建静态页面，有良好的代码注释和编写习惯2.熟练使用JQuery和原生Javascript实现页面特效和交互功能3.掌握Ajax，能实现前后端数据的交互，实现页面数据的异步加载4.掌握并能运用html5和CSS3的新功能5.了解面向对象思想，能运用于实际编程中6.了解bootstrap，能够用其搭建响应式网站7.了解git，gulp管理工具的使用8.了解nodejs后端基础，了解MVC思想，实现增删改查的网页应用9.掌握Photoshop使用，能完成成简单的设计任务————————————————————1.熟练使用HTML/CSS制作目标网页，并能做好主流浏览器的兼容性，能够使用HTML5和CSS3开发移动端、PC端页面应用；2.熟练使用JavaScript，可脱离类库，编写原生JS代码实现网页特效，并能进行代码优化；3.熟练运用jQuery实现常用网页特效，掌握Bootstrap进行响应式网站开发，了解Zepto.js进行移动web开发；4.理解并能应用Ajax交互，以及JSON/JSONP以及http协议；5.能够使用面向对象封装自己的框架，实现常用功能，了解组件化开发；6.能够使用git/gulp对团队代码进行管理和构建，了解npm、bower等包依赖管理工具；7.熟练使用angular开发，熟悉MVC框架模式，了解Node.js开发；——————————————————1.熟练DIV+CSS网页制作技术，熟悉W3C各标准，能根据设计图制作符规范的静态页面。2.熟悉jQuery框架，熟练掌握JQuery、DOM操作及事件处理，了解动态绑定事件的原理。3.熟练掌握HTML5+CSS3的新特性，并熟练应用到移动页面开发中以及能解决大部分浏览器兼容问题。4.熟练CSS3动画、过渡效果展示以及Cavas动画制作并实现页面交互。5.有基于Ajax的应用开发经验，DOM、BOM、JSON等相关技术，能与后台开发协作，完成操作交互、数据展示。6.能够使用Zepto、iScroll swape等技术构建页,了解面向对象编程思想。7.熟悉弹性布局及响应式布局，自适应，能有效解决和改善各种移动端的适配问题。也了解一些后端语言PHP、sql8.了解一些前端框架如：Bootstrap、Zepto、Less、流行框架等。9.了解模块化开发思想可用node.js，Seajs、Requirejs及Angularjs进行简单的模块化开发。 后期有时间了会持续细化和整理，面试的经验分享敬请期待、 备注： 1前端的路上我们一起携手共进！如果转载，请标注本链接地址。 ​MIT ©杨方涛 Email:58267980@qq.com","categories":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://lzws0931.cn/categories/面试宝典/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://lzws0931.cn/tags/面试/"}]},{"title":"付费_极客时间one","slug":"法门扫地僧付费_极客时间one","date":"2018-08-07T11:43:32.000Z","updated":"2019-01-24T05:04:19.432Z","comments":true,"path":"2018/08/07/法门扫地僧付费_极客时间one/","link":"","permalink":"https://lzws0931.cn/2018/08/07/法门扫地僧付费_极客时间one/","excerpt":"","text":"极客时间_one本文来自极客时间个人记录笔记。 任何工作不能是“我的部分做完了，其他的事情我不管”… 验证码有可能是个有效设计，但是他并不是一个好设计，因为挡住机器这件事本应该是服务提供方的责任，而服务方却将其成本转嫁给了用户 未完成的功能键要想加入一个新的功能，为了测试用户是否真的想对这个功能感兴趣，暂时不设置功能，而是通过用户的点击率看来验证用户的动机和需求。。 用最少的资源给你的产品试试水。","categories":[{"name":"技术","slug":"技术","permalink":"https://lzws0931.cn/categories/技术/"}],"tags":[{"name":"产品","slug":"产品","permalink":"https://lzws0931.cn/tags/产品/"}]},{"title":"法门扫地僧angular常见问题","slug":"法门扫地僧angular常见问题","date":"2018-06-14T03:45:09.000Z","updated":"2019-01-24T05:04:44.893Z","comments":true,"path":"2018/06/14/法门扫地僧angular常见问题/","link":"","permalink":"https://lzws0931.cn/2018/06/14/法门扫地僧angular常见问题/","excerpt":"","text":"Front-End前端开发工程师面试宝典！ （本文部分有转载，不定期更新！） 前言（README.md）12本仓库是我整理的前端常见面试题，大部分由我整理，其中个别部分参考网上其他资料，感谢！ 本资料仅供大家学习参考使用！欢迎大家Star和提交issues。 NO.1 READMENO.2 简历经验分享NO.3 angular常见问题NO.4 前端面试宝典第一版NO.5 前端笔记版本第二版NO.6 前端笔记版本第三版NO.7 前端笔记版本第四版NO.8 vue常见问题 欢迎大家一起交流提高angularjs的几大特性是什么？双向数据绑定、依赖注入、模板、指令、MVC/MVVM 列举几种常见的设计模式，写出没个代表的含义？MVC ：model view controllerMVVM ：model view viewModel 请描述angularjs的运行过程？angularjs编译所有的HTML元素标签，然后在里面查找angular程序的入口 ng-app 每个元素上的指令是把所有指令收集起来根据优先级依次编译 ng-bind和ng-model的区别是什么？ng-bind只能展示数据 ng-model可以操作数据 请描述$scope的特点还有其最大的父类？随创建作用域创建的一个变量，就代表controller所代表的作用域，其持有的对象和方法可在当前及其子作用域生效 原生js的延迟或回调在angularjs里能完美运行吗？怎么解决？可以用例子？不能 需要用$apply来进行传播 自定义过滤创建后返回的是一个什么对象？返回一个函数对象 并且函数内要返回最后返回的对象 ng-repeat循环[1,3,2,4,3,4]数组会报错吗？如果会怎么解决？会因为有重复的内容 track by $index angular常用的服务中value和constant最大的区别是什么？constant的创建要早于value 并且其可以在config配置中使用 value不行 常用服务中factory和service的最大区别是什么？factory返回的对象当我们使用它的时候手动初始化并返回，而service是当我们第一次使用的时候angular帮我们初始化一次，然后以后使用的时候返回的都是这个对象，factory创建的服务是代表的是其后面函数的返回值，这个返回值可以是任意类型，service不用返回，直接操作的就是自己 怎么拦截服务？在config配置里注入需要拦截的服务的名字+Provider来拦截 decorator的作用是什么？和拦截服务的区别是什么？装饰器不仅可以应用在我们自己的服务上，也可以对angularjs核心服务进行拦截、中断甚至替换功能的操作，事实上angularjs的很多测试就是借助$provide.decorator()建立的、请写一个配置路由的代码段（只需要写怎么声明一个路由和其常用属性的代码段） resolve的作用是什么？如果设置了resolve属性，angularjs会将列表中的元素都注入到控制器中，列表对象可以是键(键值是会被注入到控制器中依赖的名字)，也可以是工厂(即可以是一个服务的名字) ngRoute默认查找的路由是什么？$routeProvider.otherwise(’/index’)是什么作用？是/ 设置路由的意外指向到/index ###常使用的跨域方案就哪两种？分别描述其利用的原理？ jsonp; post请求设置请求头 ； jsonp利用的是script可以访问外部信息的原理发送请求并且利用jsonp协议进行数据交互 post设置请求头跳过预请求来实现跨域 ng-repeat迭代数组的时候，如果数组中有相同值，会有什么问题，如何解决？会提示 Duplicates in a repeater are not allowed.加 track by $index 可解决。当然，也可以 trace by 任何一个普通的值，只要能唯一性标识数组中的每一项即可（建立 dom 和数据之间的关联）。 ng-click 中写的表达式，能使用 JS 原生对象上的方法吗？ 不止是 ng-click 中的表达式，只要是在页面中，都不能直接调用原生的 JS 方法，因为这些并不存在于与页面对应的 Controller 的 $scope 中。 会发现，什么也没有显示。但如果在 $scope 中添加了这个函数：$scope.parseInt = function(x){ return parseInt(x);}这样自然是没什么问题了。 angular 应用常用哪些路由库，各自的区别是什么？Angular1.x 中常用 ngRoute 和 ui.router，还有一种为 Angular2 设计的 new router（面向组件）。后面那个没在实际项目中用过，就不讲了。无论是 ngRoute 还是 ui.router，作为框架额外的附加功能，都必须以 模块依赖 的形式被引入。区别ngRoute 模块是 Angular 自带的路由模块，而 ui.router 模块是基于 ngRoute模块开发的第三方模块。ui.router 是基于 state （状态）的， ngRoute 是基于 url 的，ui.router模块具有更强大的功能，主要体现在视图的嵌套方面。使用 ui.router 能够定义有明确父子关系的路由，并通过 ui-view 指令将子路由模版插入到父路由模板的 中去，从而实现视图嵌套。而在 ngRoute 中不能这样定义，如果同时在父子视图中 使用了 会陷入死循环。 如果通过angular的directive规划一套全组件化体系，可能遇到哪些挑战？没有自己用 directive 做过一全套组件，讲不出。能想到的一点是，组件如何与外界进行数据的交互，以及如何通过简单的配置就能使用吧。分属不同团队进行开发的 angular 应用，如果要做整合，可能会遇到哪些问题，如何解决？可能会遇到不同模块之间的冲突。比如一个团队所有的开发在 moduleA 下进行，另一团队开发的代码在 moduleB 下angular.module(‘myApp.moduleA’, []) .factory(‘serviceA’, function(){ … }) angular.module(‘myApp.moduleB’, []) .factory(‘serviceA’, function(){ … }) angular.module(‘myApp’, [‘myApp.moduleA’, ‘myApp.moduleB’]) 会导致两个 module 下面的 serviceA 发生了覆盖。貌似在 Angular1.x 中并没有很好的解决办法，所以最好在前期进行统一规划，做好约定，严格按照约定开发，每个开发人员只写特定区块代码。angular 的缺点有哪些？强约束导致学习成本较高，对前端不友好。但遵守 AngularJS 的约定时，生产力会很高，对 Java 程序员友好。不利于 SEO因为所有内容都是动态获取并渲染生成的，搜索引擎没法爬取。一种解决办法是，对于正常用户的访问，服务器响应 AngularJS 应用的内容；对于搜索引擎的访问，则响应专门针对 SEO 的HTML页面。性能问题作为 MVVM 框架，因为实现了数据的双向绑定，对于大数组、复杂对象会存在性能问题。可以用来 优化 Angular 应用的性能 的办法：减少监控项（比如对不会变化的数据采用单向绑定） 主动设置索引（指定 track by，简单类型默认用自身当索引，对象默认使用 $$hashKey，比如改为 track by item.id） 降低渲染数据量（比如分页，或者每次取一小部分数据，根据需要再取） 数据扁平化（比如对于树状结构，使用扁平化结构，构建一个 map 和树状数据，对树操作时，由于跟扁平数据同一引用，树状数据变更会同步到原始的扁平数据） 另外，对于Angular1.x ，存在 脏检查 和 模块机制 的问题。移动端可尝试 Ionic，但并不完善。 补充对于一个 DI 容器，必须具备三个要素：依赖项的注册，依赖关系的声明和对象的获取。在 AngularJS 中，module 和 $provide 都可以提供依赖项的注册；内置的 injector 可以获取对象（自动完成依赖注入）；依赖关系的声明，就是前面问题中提到的那样。下面是个栗子// 对于 module，传递参数不止一个，代表新建模块，空数组代表不依赖其他模块// 只有一个参数（模块名），代表获取模块// 定义 myApp，添加 myApp.services 为其依赖项angular.module(‘myApp’, [‘myApp.services’]);// 定义一个 services module，将 services 都注册在这个 module 下面angular.module(‘myApp.services’, [])// $provider 有 factory, service, provider, value, constant// 定义一个 HttpServiceangular.module(‘myApp.services’).service(‘HttpService’, [‘$http’, function($http){ …}]) 如何看待angular2相比 Angular1.x，Angular2的改动很大，几乎算是一个全新的框架。基于 TypeScript（可以使用 TypeScript 进行开发），在大型项目团队协作时，强语言类型更有利。组件化，提升开发和维护的效率。还有 module 支持动态加载，new router，promise的原生支持等等。迎合未来标准，吸纳其他框架的优点，值得期待，不过同时要学习的东西也更多了（ES next、TS、Rx等） angularjs 是 mvc 还是 mvvm 框架?首先阐述下你对mvc和mvvm的理解首先为什么我们会需要MVC？因为随着代码规模越来越大，切分职责是大势所趋，还有为了后期维护方便，修改一块功能不影响其他功能。还有为了复用，因为很多逻辑是一样的。而MVC只是手段，终极目标是模块化和复用。mvvm的优点: 低耦合：View可以独立于Model变化和修改，同一个ViewModel可以被多个View复用；并且可以做到View和Model的变化互不影响可重用性：可以把一些视图的逻辑放在ViewModel，让多个View复用独立开发：开发人员可以专注与业务逻辑和数据的开发（ViewModemvvmdi计人员可以专注于UI(View)的设计可测试性：清晰的View分层，使得针对表现层业务逻辑的测试更容易，更简单在angular中MVVM模式主要分为四部分： View：它专注于界面的显示和渲染，在angular中则是包含一堆声明式Directive的视图模板。ViewModel：它是View和Model的粘合体，负责View和Model的交互和协作，它负责给View提供显示的数据，以及提供了View中Command事件操作Model的途径；在angular中$scope对象充当了这个ViewModel的角色；Model：它是与应用程序的业务逻辑相关的数据的封装载体，它是业务领域的对象，Model并不关心会被如何显示或操作，所以模型也不会包含任何界面显示相关的逻辑。在web页面中，大部分Model都是来自Ajax的服务端返回数据或者是全局的配置对象；而angular中的service则是封装和处理这些与Model相关的业务逻辑的场所，这类的业务服务是可以被多个Controller或者其他service复用的领域服务。Controller：这并不是MVVM模式的核心元素，但它负责ViewModel对象的初始化，它将组合一个或者多个service来获取业务领域Model放在ViewModel对象上，使得应用界面在启动加载的时候达到一种可用的状态。 angular 核心？AngularJS是为了克服HTML在构建应用上的不足而设计的。 AngularJS有着诸多特性，最为核心的是： MVC模块化自动化双向数据绑定语义化标签、依赖注入等等factory 和 service，provider是什么关系？factory 把 service 的方法和数据放在一个对象里，并返回这个对象；service 通过构造函数方式创建 service，返回一个实例化对象；provider 创建一个可通过 config 配置的 service。 从底层实现上来看，service 调用了 factory，返回其实例；factory 调用了 provider，将其定义的内容放在 $get 中返回。factory 和 service 功能类似，只不过 factory 是普通 function，可以返回任何东西（return 的都可以被访问，所以那些私有变量怎么写你懂的）；service 是构造器，可以不返回（绑定到 this 的都可以被访问）；provider 是加强版 factory，返回一个可配置的 factory。 ###ng-if 跟 ng-show/hide的区别有哪些？ng-if 在后面表达式为 true 的时候才创建这个 dom 节点，ng-show 是初始时就创建了，用 display:block 和 display:none 来控制显示和不显示。ng-if 会（隐式地）产生新作用域，ng-switch 、 ng-include 等会动态创建一块界面的也是如此。 ng-repeat迭代数组的时候，如果数组中有相同值，会有什么问题，如何解决？会提示 Duplicates in a repeater are not allowed. 加 track by $index 可解决。当然，也可以 trace by 任何一个普通的值，只要能唯一性标识数组中的每一项即可（建立 dom 和数据之间的关联）。 在写controlloer逻辑的时候 你需要注意什么？简化代码（这个是所有开发人员都要具备的）坚决不能操作dom节点 这个时候可能会问 为什么不能啊你的回答是：DOM操作只能出现在指令（directive）中。最不应该出现的位置就是服务（service）中。Angular倡导以测试驱动开发，在service或者controller中出现了DOM操作，那么也就意味着的测试是无法通过的。当然，这只是一点，重要的是使用Angular的其中一个好处是啥，那就是双向数据绑定，这样就能专注于处理业务逻辑，无需关系一堆堆的DOM操作。如果在Angular的代码中还到处充斥着各种DOM操作，那为什么不直接使用jquery去开发呢。 测试驱动开发是什么呢？普及一下：测试驱动开发，英文全称Test-Driven Development，简称TDD，是一种不同于传统软件开发流程的新型的开发方法。它要求在编写某个功能的代码之前先编写测试代码，然后只编写使测试通过的功能代码，通过测试来推动整个开发的进行。这有助于编写简洁可用和高质量的代码，并加速开发过程。 单页应用有哪些优缺点？单页Web应用（single page web application，SPA），就是只有一张Web页面的应用。单页应用程序 (SPA) 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。 浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。因此，对单页应用来说模块化的开发和设计显得相当重要。 速度：更好的用户体验，让用户在web app感受native app的速度和流畅，MVC：经典MVC开发模式，前后端各负其责。ajax：重前端，业务逻辑全部在本地操作，数据都需要通过AJAX同步、提交。路由：在URL中采用#号来作为当前视图的地址,改变#号后的参数，页面并不会重载。单页Web应用（single page web application，SPA）是当今网站开发技术的弄潮儿，很多传统网站都在或者已经转型为单页Web应用，新的单页Web应用网站（包括移动平台上的）也如雨后春笋般涌现在人们的面前，如Gmail、Evernote、Trello等。如果你是一名Web开发人员，却还没开发过或者甚至是没有听说过单页应用，那你已经Out很久了。单页Web应用和前端工程师们息息相关，因为主要的变革发生在浏览器端，用到的技术其实还是HTML+CSS+JavaScript，所有的浏览器都原生支持，当然有的浏览器因为具备一些高级特性，从而使得单页Web应用的用户体验更上一层楼。关于单页应用的优点和缺点，网上讲解的文章有很多，这里就不展开论述了。 单页Web应用，顾名思义，就是只有一张Web页面的应用。浏览器一开始会加载必需的HTML、CSS和JavaScript，之后所有的操作都在这张页面上完成，这一切都由JavaScript来控制。因此，单页Web应用会包含大量的JavaScript代码，复杂度可想而知，模块化开发和设计的重要性不言而喻。 优点： 分离前后端关注点，前端负责界面显示，后端负责数据存储和计算，各司其职，不会把前后端的逻辑混杂在一起；减轻服务器压力，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍；同一套后端程序代码，不用修改就可以用于Web界面、手机、平板等多种客户端；缺点： SEO问题，现在可以通过Prerender等技术解决一部分；前进、后退、地址栏等，需要程序进行管理；书签，需要程序来提供支持； angular 的数据绑定采用什么机制？详述原理脏检查机制。 双向数据绑定是 AngularJS 的核心机制之一。当 view 中有任何数据变化时，会更新到 model ，当 model 中数据有变化时，view 也会同步更新，显然，这需要一个监控。 原理就是，Angular 在 scope 模型上设置了一个 监听队列，用来监听数据变化并更新 view 。每次绑定一个东西到 view 上时 AngularJS 就会往 $watch 队列里插入一条 $watch，用来检测它监视的 model 里是否有变化的东西。当浏览器接收到可以被 angular context 处理的事件时，$digest 循环就会触发，遍历所有的 $watch，最后更新 dom。举个栗子12&lt;button ng-click=&quot;val=val+1&quot;&gt;increase 1&lt;/button&gt;click 时会产生一次更新的操作（至少触发两次 $digest 循环） 按下按钮 浏览器接收到一个事件，进入到 angular context$digest 循环开始执行，查询每个 $watch 是否变化 由于监视 $scope.val 的 $watch 报告了变化，因此强制再执行一次 $digest 循环 新的 $digest 循环未检测到变化 浏览器拿回控制器，更新 $scope.val 新值对应的 dom $digest 循环的上限是 10 次（超过 10次后抛出一个异常，防止无限循环）。 angular 的缺点有哪些？强约束导致学习成本较高，对前端不友好。 但遵守 AngularJS 的约定时，生产力会很高，对 Java 程序员友好。 不利于 SEO因为所有内容都是动态获取并渲染生成的，搜索引擎没法爬取。 一种解决办法是，对于正常用户的访问，服务器响应 AngularJS 应用的内容；对于搜索引擎的访问，则响应专门针对 SEO 的HTML页面。 性能问题作为 MVVM 框架，因为实现了数据的双向绑定，对于大数组、复杂对象会存在性能问题。 可以用来 优化 Angular 应用的性能 的办法： 减少监控项（比如对不会变化的数据采用单向绑定） 主动设置索引（指定 track by，简单类型默认用自身当索引，对象默认使用 $$hashKey，比如改为 track by item.id） 降低渲染数据量（比如分页，或者每次取一小部分数据，根据需要再取） 数据扁平化（比如对于树状结构，使用扁平化结构，构建一个 map 和树状数据，对树操作时，由于跟扁平数据同一引用，树状数据变更会同步到原始的扁平数据） 另外，对于Angular1.x ，存在 脏检查 和 模块机制 的问题。 ng-repeat迭代数组的时候，如果数组中有相同值，会有什么问题，如何解决？会提示 Duplicates in a repeater are not allowed. 加 track by $index 可解决。当然，也可以 trace by 任何一个普通的值，只要能唯一性标识数组中的每一项即可（建立 dom 和数据之间的关联） Observables和Promises的核心区别是什么？从堆栈溢出就是一个区别： 当异步操作完成或失败时，Promise会处理一个单个事件。 Observable类似于（在许多语言中的）Stream，当每个事件调用回调函数时，允许传递零个或多个事件。通常Observable比Promise更受欢迎，因为它不但提供了Promise特性，还提供了其它特性。使用Observable可以处理0,1或多个事件。你可以在每种情况下使用相同的API。Observable是可取消的，这相比于Promise也具有优势。如果服务器的HTTP请求结果或其它一些异步操作不再需要，则Observable的订阅者可以取消订阅，而Promise将最终调用成功或失败的回调，即使你不需要通知或其提供的结果。Observable提供像map，forEach，reduce之类的类似于数组的运算符，还有强大的运算符，如retry（）或replay（）等，使用起来是相当方便的。 Promises vs Observables Promises：返回单个值不可取消Observables：可以使用多个值可取消支持map，filter，reduce和类似的操作符ES 2016提议的功能使用反应式扩展（RxJS）根据时间的变化，数组成员可以异步获取 优化 Angular 应用的性能减少监控项（比如对不会变化的数据采用单向绑定）主动设置索引（指定 track by，简单类型默认用自身当索引，对象默认使用 $$hashKey，比如改为 track by item.id）降低渲染数据量（比如分页，或者每次取一小部分数据，根据需要再取）数据扁平化（比如对于树状结构，使用扁平化结构，构建一个 map 和树状数据，对树操作时，由于跟扁平数据同一引用，树状数据变更会同步到原始的扁平数据） 详述 angular 的 “依赖注入”赖注入是一种软件设计模式，目的是处理代码之间的依赖关系，减少组件间的耦合。原理：AngularJS是通过构造函数的参数名字来推断依赖服务名称的，通过 toString() 来找到这个定义的 function 对应的字符串，然后用正则解析出其中的参数（依赖项），再去依赖映射中取到对应的依赖，实例化之后传入。 备注： 1前端的路上我们一起携手共进！如果转载，请标注本链接地址。 ​MIT ©杨方涛 Email:58267980@qq.com","categories":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://lzws0931.cn/categories/面试宝典/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://lzws0931.cn/tags/面试/"}]},{"title":"浏览器渲染原理(本文转载)","slug":"浏览器渲染原理","date":"2018-05-10T05:51:00.000Z","updated":"2019-01-24T05:04:33.411Z","comments":true,"path":"2018/05/10/浏览器渲染原理/","link":"","permalink":"https://lzws0931.cn/2018/05/10/浏览器渲染原理/","excerpt":"","text":"从输入 URL 到页面加载完成发生了什么事DNS解析 TCP连接 发送HTTP请求 服务器处理请求并返回HTTP报文 浏览器解析渲染页面 浏览器应该有的功能网络;资源管理;网页浏览;多页面管理;插件与管理;账户和同步;安全机制;开发者工具 浏览器的主要功能总结起来就是一句话: 将用户输入的url转变成可视化的图像 浏览器的内核(渲染引擎)在浏览器中有一个最重要的模块，它主要的作用是将页面转变为可视化的图像结果。这个模块就是浏览器内核，通常它也被称为渲染引擎。 IE-----&gt;Trident Safari------&gt;WebKit Chrome;Opera-----&gt;Blink Firefox------&gt;Gecko 渲染引擎一个渲染引擎主要包括：HTML解析器，CSS解析器，布局layout模块，javascript引擎，绘图模块 渲染过程1.网页URL到构建DOM树的整个过程 1) 当用户输入URL的时候，Webkit调用资源加载器加载URL对应的网页 2) 加载器依赖网络模块建立连接，发送请求并接收答复 3) Webkit接收到各种网页或者资源的数据，其中某些资源可能是同步的或异步获取的 4) 网页被交给HTML解析器转变一系列的词语（Token） 5) 解析器根据词语构建节点（node），形成DOM树 6) 如果节点需要依赖于其他资源， 例如js css 图片 视频等，调用资源加载器来加载他们，但是这些都是异步的， 不会阻碍dom树的继续创建；顺序执行 并发加载 如果资源是css的话 调用CSS解析器解释将CSS解释成内部表示结构(CSSDOM) 如果资源是javascript的话 调用Javascript引擎解释并执行， 7）阻塞 css阻塞 css 在head中通过link的形式引入会阻塞页面的渲染 为什么？ 避免闪屏现象 js阻塞 直接引入的js会阻塞页面的渲染 为什么？ Javascript代码可能会修改DOM树的结构 8) 预解析 WebKit 和 Firefox 都进行了这项优化。在执行js脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理； 预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。 2.从DOM树到可视化图像 1) CSS文件被CSS解析器解释成内部表示结构(CSSDOM) 2) CSS解析器工作完成之后，在DOM树上附加解释后的样式信息，这就是RenderObject树 3) RenderObject在创建的同时，Webkit会根据网页的结构创建RenderLayer，同时构建一个绘图上下文 4) 根据绘图上下文生成最终的图像（这一过程需要依赖图形库） 3.上面介绍的是一个完整的渲染过程，但现代网页很多都是动态的，这意味着在渲染完成之后，由于网页的动画或者用户的交互， 浏览器其实一直在不停地重复执行渲染过程。（重绘重排），以上的数字表示的是基本顺序，这不是严格一致的， 这个过程可能重复也可能交叉。浏览器是一个边解析边渲染的过程 css图层浏览器在渲染一个页面时，会将页面分为很多个图层，图层有大有小，每个图层上有一个或多个节点。 在渲染DOM的时候，浏览器所做的工作实际上是： 1. 获取DOM后分割为多个图层 2. 对每个图层的节点计算样式结果 （Recalculate style--样式重计算） 3. 为每个节点生成图形和位置 （Layout--重排,回流） 4. 将每个节点绘制填充到图层位图中 （Paint--重绘） 5. 图层作为纹理上传至GPU 6. 符合多个图层到页面上生成最终屏幕图像 （Composite Layers--图层重组） 图层创建的条件Chrome中满足以下任意情况就会创建图层： 1. 拥有具有3D变换的CSS属性 2. 使用加速视频解码的&lt;video&gt;节点 3. &lt;canvas&gt;节点 4. CSS3动画的节点 5. 拥有CSS加速属性的元素(will-change) 6. 元素有一个z-index较低且包含一个复合层的兄弟元素（换句话说就是该元素在复合层上面渲染） 重绘(Repaint)重绘是一个元素外观的改变所触发的浏览器行为，例如改变outline、背景色等属性。浏览器会根据元素的新属性重新绘制， 使元素呈现新的外观。重绘不会带来重新布局，所以并不一定伴随重排。 需要注意的是，如果图层中某个元素需要重绘，那么整个图层都需要重绘。 比如一个图层包含很多节点，其中有个gif图，gif图的每一帧，都会重回整个图层的其他节点，然后生成最终的图层位图。 所以这需要通过特殊的方式来强制gif图属于自己一个图层（translateZ(0)或者translate3d(0,0,0) CSS3的动画也是一样（好在绝大部分情况浏览器自己会为CSS3动画的节点创建图层） 重排(Reflow 回流)渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排 &quot;重绘&quot;不一定需要&quot;重排&quot;，比如改变某个网页元素的颜色，就只会触发&quot;重绘&quot;，不会触发&quot;重排&quot;，因为布局没有改变。 但是，&quot;重排&quot;必然导致&quot;重绘&quot;，比如改变一个网页元素的位置，就会同时触发&quot;重排&quot;和&quot;重绘&quot;，因为布局改变了。 触发重绘的属性* color * background * outline-color * border-style * background-image * outline * border-radius * background-position * outline-style * visibility * background-repeat * outline-width * text-decoration * background-size * box-shadow 触发重排(回流)的属性盒子模型相关属性会触发重布局 定位属性及浮动也会触发重布局： 改变节点内部文字结构也会触发重布局： * width * top * text-align * height * bottom * overflow-y * padding * left * font-weight * margin * right * overflow * display * position * font-family * border-width * float * line-height * border * clear * vertival-align * min-height * white-space 常见的触发重排的操作Reflow 的成本比 Repaint 的成本高得多的多。DOM Tree 里的每个结点都会有 reflow 方法， 一个结点的 reflow 很有可能导致子结点，甚至父点以及同级结点的 reflow。在一些高性能的电脑上也许还没什么， 但是如果 reflow 发生在手机上，那么这个过程是非常痛苦和耗电的。 所以，下面这些动作有很大可能会是成本比较高的。 当你增加、删除、修改 DOM 结点时，会导致 Reflow , Repaint。 当你移动 DOM 的位置 当你修改 CSS 样式的时候。 当你 Resize 窗口的时候（移动端没有这个问题） 当你修改网页的默认字体时。 获取某些属性时(width,height...) 注：display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发生位置变化。 优化如果我们需要使得动画或其他节点渲染的性能提高，需要做的就是减少浏览器在运行时所需要做的工作（减少1234中的步骤） 1. 计算需要被加载到节点上的样式结果（Recalculate style--样式重计算） 2. 为每个节点生成图形和位置（Layout--回流和重布局） 3. 将每个节点填充到图层中（Paint Setup和Paint--重绘） 4. 组合图层到页面上（Composite Layers--图层重组） 1.元素位置移动变换时尽量使用CSS3的transform来代替对top left等的操作 变换（transform）和透明度（opacity）的改变仅仅影响图层的组合 2.使用opacity来代替visibility 透明度竟然不会触发重绘？ 透明度的改变时，GPU在绘画时只是简单的降低之前已经画好的纹理的alpha值来达到效果，并不需要整体的重绘。 不过这个前提是这个被修改opacity本身必须是一个图层，如果图层下还有其他节点，GPU也会将他们透明化 3.不要使用table布局 4.将多次改变样式属性的操作合并成一次操作 不要一条一条地修改DOM的样式，预先定义好class，然后修改DOM的className 5.将DOM离线后再修改 由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。 如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。 6.利用文档碎片 7.不要把某些DOM节点的属性值放在一个循环里当成循环的变量 当你请求向浏览器请求一些 style信息的时候，就会让浏览器flush队列，比如： 1. offsetTop, offsetLeft, offsetWidth, offsetHeight 2. scrollTop/Left/Width/Height 3. clientTop/Left/Width/Height 4. width,height 当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要flush队列， 因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近发生或改变的布局信息无关， 浏览器都会强行刷新渲染队列。 8.动画实现过程中，启用GPU硬件加速 9.为动画元素新建图层,提高动画元素的z-index","categories":[{"name":"技术","slug":"技术","permalink":"https://lzws0931.cn/categories/技术/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://lzws0931.cn/tags/浏览器/"}]},{"title":"成都三日游","slug":"法门扫地僧成都三日游","date":"2018-04-26T05:21:00.000Z","updated":"2019-01-24T05:04:57.017Z","comments":true,"path":"2018/04/26/法门扫地僧成都三日游/","link":"","permalink":"https://lzws0931.cn/2018/04/26/法门扫地僧成都三日游/","excerpt":"","text":"我一个人去成都逛了一圈123嗯，带的班结课了。不到一周，就业率70%，挺好的。都是大家努力的成果。希望最后大家都能百分百就业吧，拿到自己期望的工资。不过，有好些人上班了，也有不少压力，感觉掌握的东西还是比较欠缺，知识面窄，还有就是掌握的深度不够到位，慢慢熬吧。都一样，知识永远也学不完呀。趁着周末没事干，我觉得来一场说走就走的旅行，哈哈，成都一圈。散散心。 晒一波照片。哈哈，其实我拍了好多，这里只是晒部分，因为之前有次上次的照片看不到了，估计是之前的图床发生故障了。所以以后的照片上传到七牛云上去了。自己摸索的。啦啦 成都一个小哥哥让我很暖4月21日，成都，小雨因为雨不是很大，我就没打伞，有时候还是很享受在雨中漫步的感觉。然后，过马路，等红灯，旁边一个小哥哥。穿着西装，长的有点像最强大脑里面的王峰。看我没打伞，然后把伞往我这边靠了一下，说“躲躲雨”瞬间，我就被暖到了。陌生的城市，一个小小的举动。一看就是有素养的人然后他在回微信。过了马路走了一段路，我说我朝这边走，他说，那不好意思了。不能帮你了。我说谢谢。 感谢，一个人让我改变了一座城的看法。","categories":[{"name":"旅游","slug":"旅游","permalink":"https://lzws0931.cn/categories/旅游/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://lzws0931.cn/tags/生活/"}]},{"title":"前端面试宝典第三版","slug":"前端面试宝典第三版","date":"2018-04-10T13:45:00.000Z","updated":"2019-01-24T05:08:54.995Z","comments":true,"path":"2018/04/10/前端面试宝典第三版/","link":"","permalink":"https://lzws0931.cn/2018/04/10/前端面试宝典第三版/","excerpt":"","text":"Front-End前端开发工程师面试宝典！ （本文部分有转载，不定期更新！） 前言（README.md）12本仓库是我整理的前端常见面试题，大部分由我整理，其中个别部分参考网上其他资料，感谢！ 本资料仅供大家学习参考使用！欢迎大家Star和提交issues。 NO.1 READMENO.2 简历经验分享NO.3 angular常见问题NO.4 前端面试宝典第一版NO.5 前端笔记版本第二版NO.6 前端笔记版本第三版NO.7 前端笔记版本第四版NO.8 vue常见问题 欢迎大家一起交流提高HTML HTML5 ，以及与html的差别​​ 1. 语义化标签​ 2. 支持视频和音频​ 3. Doctype类型－简单，它能在每一个浏览器中正常工作即使是名声狼藉的IE6。​ 4. 离线存储 － localStorage和sessionStorage​ 5. 互动效果​ a. canvas​ b. 更多API支持更好的用户体验－ 拖拽、地图、利用Native​ 6. 丰富的表单控件 如 calendar、date、time、email、url、search​ 7. 移动端－摆脱对平台依赖 doctype(文档类型) 的作用是什么 现代浏览器包括不同的呈现模式，目的是既支持遵循标准的网页，也支持为老式浏览器而设计的网页。其中， Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks （包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。另外，注意Mozilla/Netscape 6新增了一种 Almost Standards （近似标准）模式，用于支持为标准的某个老版本而设计的网页。 doctype声明指出阅读程序应该用什么规则集来解释文档中的标记。在Web文档的情况下，“阅读程序”通常是浏览器或者校验器这样的一个程序，“规则”则是W3C所发布的一个文档类型定义（DTD）中包含的规则。 localStorage和sessionStorage localStorage有效期为永久，sessionStorage有效期为顶层窗口关闭前同源文档可以读取并修改localStorage数据，sessionStorage只允许同一个窗口下的文档访问，如通过iframe引入的同源文档。 Storage对象通常被当做普通javascript对象使用：通过设置属性来存取字符串值，也可以通过setItem(key, value)设置，getItem(key)读取，removeItem(key)删除，clear()删除所有数据，length表示已存储的数据项数目，key(index)返回对应索引的key 应用程序存储和离线web应用​​ HTML5新增应用程序缓存，允许web应用将应用程序自身保存到用户浏览器中，用户离线状态也能访问。 1.为html元素设置manifest属性:，其中后缀名只是一个约定，真正识别方式是通过text/cache-manifest作为MIME类型。所以需要配置服务器保证设置正确 2.manifest文件首行为CACHE MANIFEST，其余就是要缓存的URL列表，每个一行，相对路径都相对于manifest文件的url。注释以#开头 3.url分为三种类型：CACHE:为默认类型。NETWORK：表示资源从不缓存。 FALLBACK:每行包含两个url，第二个URL是指需要加载和存储在缓存中的资源， 第一个URL是一个前缀。任何匹配该前缀的URL都不会缓存，如果从网络中载入这样的URL失败的话，就会用第二个URL指定的缓存资源来替代。以下是一个文件例子： 简述一下你对HTML语义化的理解 用正确的标签做正确的事情。 html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析; 及时在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 CSS 盒子模型​ 标准盒子模型：盒子模型范围包括了margin\\border\\padding\\content.但content(width)不包括其他部分。 IE的盒子模型的content(width)包括了border和padding 目前css3中属性box-sizing可以解决IE7以上的问题。 重新定义盒子大小，解决盒模型在不同的浏览器中表现不一致的问题。 box-sizing: content-box | border-box; content-box : 定义的width和height就直接是内容的宽度 border-box: 内容的宽度是 width -边框的宽度－padding CSS定位 定位机制 CSS 有三种基本的定位机制：普通流、浮动和绝对定位。 普通流：元素的位置由它在HTML中的位置决定的。 块级框：从上到下，一个接一个，垂直距离由框的垂直空白边决定的 行内框：水平布置。可使用水平填充，边框可调节水平间距。 position属性 相对定位的盒子仍在标准流中，相对于它原本的位置，通过偏移（left、right）指定的距离，到达新的位置。它对父块没有任何影响。 使用绝对定位的盒子以它的“最近”的一个“已经定位”的“祖先元素”为基准进行偏移。如果没有已经定位的祖先元素，那么会以浏览器窗口为基准进行定位。 元素选择器，优先级及匹配原理 ​ css匹配原理 ​ 从最右边的选择符开始向左进行匹配规则。只要当前选择符的左边还有其他选择符，样式系统就会继续向左移动，直到找到和规则匹配的元素，或者因为不匹配而退出。所以在使用less的时候要防止层叠过多。 ​ css权重 通配选择符的权值 0,0,0,0 标签的权值为 0,0,0,1 类的权值为 0,0,1,0 属性选择的权值为 0,0,1,1(0,0,1,0) 伪类选择的权值为 0,0,1,0 伪对象选择的权值为 0,0,0,1 ID的权值为 0,1,0,0 important的权值为最高 1,0,0,0 使用的规则也很简单，就是 选择器的权值加到一起，大的优先；如果权值相同，后定义的优先 从上面我们可以得出两个关键的因素： 1.权值的大小跟选择器的类型和数量有关 2.样式的优先级跟样式的定义顺序有关 总结：比较同一级别的个数，数量多的优先级高，如果相同即比较下一级别的个数 ，至于各级别的优先级，大家应该已经很清楚了，就是： !important &gt; 内联 &gt; ID &gt; 类 &gt; 标签 | 伪类 | 属性选择 &gt; 伪对象 &gt; 继承 &gt; 通配符 通配符 &gt; 继承 ID选择器的效率是最高，而伪类选择器的效率则是最低 Css水平居中​​ 基础布局对以后的开发很有作用。 1. 自动空白边居中 缺点：IE5/6不支持，需要hack，并需要对两个元素添加样式 &lt;body&gt; &lt;div id=&quot;wrapper&quot;&gt; &lt;/div&gt;&lt;/body&gt; body{ text-align: center; /*text-align:center让IE中的元素居中*/ min-width: 760px; } .wrapper{ margin: 0 auto; width: 720px; text-align: left; /* 防止继承父类 */ } 2. 使用定位和负值空白边 .wrapper{ position: relative; width: 720px; left: 50%; margin-left: -360px; //对应的垂直居中也好处理了 top: 50%; } 3. 神奇的弹性盒子 flex IE10+，Android2.1+ ,IOS safire3.2(添加-webkit-)兼容，所以目前移动端可以大量使用。 body{ display: flex; justify-content: center; //水平居中 //垂直居中 align-items: center; //当然需要设置容器的高度值 } BFC BFC(box , formatting context)，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个 BFC 中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的 margin 会发生折叠。它决定了元素如何对其内容进行布局，以及与其他元素的关系和相互作用。 BFC布局规则 1.内部的Box会在垂直方向，一个接一个地放置。 2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 3.每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 4.BFC的区域不会与float box重叠。(所以有左边宽度自适应) 5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 6.计算BFC的高度时，浮动元素也参与计算 &lt;b&gt;哪些元素会触发BFC&lt;/b&gt; 根元素 float属性不为none position为absolute或fixed display为 inline-block, table-cell, table-caption, flex, inline-flex overflow不为visible &lt;b&gt;IE如何解决？Layout &lt;/b&gt; position:absolute; float: left|right; display: inline-block; width: value; height: value; zoom:value(非normal); //通常zoom:1; 具有以上优点，BFC实际中的作用 自适应布局、清除浮动、防止margin重叠。 布局问题 响应式布局原理 ​ 检测设备，根据不同的设备采用不同的css，而且css都是采用的百分比的，而不是固定的宽度。 因为大屏幕的移动设备越来越普及。而自适应布局已经无法胜任各种浏览需求。响应式设计的目的是尽可能以最好的布局显示您的数据，以实现用户友好的 Web 页面。 现在CSS3有了个更为实用的 media query。而移动终端的浏览器（都是基于webkit内核的浏览器）基本已经完全支持了css3.他可以为你获取各种终端的数据。 栅栏系统（响应式） 响应式图片 浏览器获取用户终端的屏幕尺寸、分辨率逻辑处理后输出适应的图片，如屏幕分辨率320*480，那么我们匹配给它的是宽度应小于320px的图片。如果终端屏幕的DPI(device pixels)DPI详解值很高，也就是高清屏，那么我们就得输出2倍分辨率的图形(宽:640px)；以保证在高清屏下图形的清晰度。各种移动终端的屏幕参数可通过 http://screensiz.es/phone查询。 解决方案：响应式图形的草案：新定义标签。 2）静态、自适应、流式、响应式四种网页布局有什么区别 ​ 自适应布局（Adaptive Layout） 自适应布局（Adaptive）的特点是分别为不同的屏幕分辨率定义布局。布局切换时页面元素发生改变，但在每个布局中，页面元素不随窗口大小的调整发生变化。 ​ 流式布局（Liquid Layout） 流式布局（Liquid）的特点（也叫”Fluid”) 是页面元素的宽度按照屏幕进行适配调整，主要的问题是如果屏幕尺度跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示。 响应式布局（Responsive Layout） 分别为不同的屏幕分辨率定义布局，同时，在每个布局中，应用流式布局的理念，即页面元素宽度随着窗口调整而自动适配。 把响应式布局看作是流式布局和自适应布局设计理念的融合 CSS3新特性 选择器，文本、多列布局、渐变效果、css盒子、边框、背景、动画、转换 CSSHack​ 1.什么是CSS hack​ 由于不同厂商的流览器或某浏览器的不同版本（如IE6-IE11,Firefox/Safari/Opera/Chrome等），对CSS的支持、解析不一样，导致在不同浏览器的环境中呈现出不一致的页面展现效果。这时，我们为了获得统一的页面效果，就需要针对不同的浏览器或不同版本写特定的CSS样式，我们把这个针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack! 2.方式 1).一般是针对IE浏览器处理 只在IE下生效 &lt;!--[if IE]&gt; 这段文字只在IE浏览器显示 &lt;![endif]--&gt; 只在IE6下生效 &lt;!--[if IE 6]&gt; 这段文字只在IE6浏览器显示 &lt;![endif]--&gt; 只在IE6以上版本生效 &lt;!--[if gte IE 6]&gt; 这段文字只在IE6以上(包括)版本IE浏览器显示 &lt;![endif]--&gt; 只在IE8上不生效 &lt;!--[if ! IE 8]&gt; 这段文字在非IE8浏览器显示 &lt;![endif]--&gt; 非IE浏览器生效 &lt;!--[if !IE]&gt; 这段文字只在非IE浏览器显示 &lt;![endif]--&gt; 2).类内属性前缀法 | hack | 写法 ||——|——|| |color|| + |+color ||- |-color ||_ |_color || # |#color ||\\0 |color:red\\0 ||\\9\\0 |color:red\\9\\0 ||!important|color:blue !important;color:green; | link与@import的区别​​ 1. link是HTML方式， @import是CSS方式​ 2. link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUC​ 3. link可以通过rel=”alternate stylesheet”指定候选样式​ 4. 浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式​ 5. @import必须在样式规则之前，可以在css文件中引用其他文件​ 总体来说：link优于@import display 属性 主要把以下值区别开 display: inline | block | inline-block | inherit ; 1.inline ​ a) 元素显示方式：”文本方式”，1个挨着1个，不独自占有1行；高，行高及顶和底边距不可改变；宽度就是它的文字或图片的宽度，不可改变。 ​ b) 内嵌的元素也必须是内联元素：如,不能在里面嵌入等块级元素 c) 常用的标签有：&lt;a&gt;、&lt;input&gt;、&lt;label&gt;、&lt;img&gt; 2.block a) 元素显示方式：每个元素独自占有1行，相当于前后都带有换行符； b) 内嵌的元素可以是内联或块级元素； c) 常用的元素有：&lt;h1&gt;~&lt;h6&gt;、&lt;div&gt;、&lt;hr&gt;等等； 3.inline-block(IE8+) ​ 对象呈递为内联对象，但是对象的内容作为块对象呈递。旁边的内联对象会被呈递在同一行内，允许空格 display: none;与visibility: hidden;的区别​ 共性： 都能隐藏元素​ 特性： 1. display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见 2. display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式 3. 修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。 4. 读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容 CSS reset 浏览器样式重置。HTML标签在浏览器中都有默认的样式，例如p标签有上下边距，strong标签有字体加粗样式等。不同浏览器的默认样式之间存在差别，例如ul默认带有缩进样式，在IE下，它的缩进是由margin实现的，而在Firefox下却是由padding实现的。开发时浏览器的默认样式可能会给我们带来多浏览器兼容性问题，影响开发效率。现在很流行的解决方法是一开始就将浏览器的默认样式全部覆盖掉，这就是CSS reset。 YUI为我们提供了一个很好的CSS reset，可以直接下载使用，这段代码很成熟，推荐大家使用。YUI的CSS reset主要做了下面几点： • 白色背景，黑色字体 • margin和padding设为0 • 去掉table的边框 • 去掉列表样式（ol，ul，dl） • 所有文字字号设为100% • font-style和font-weight设为normal • 更好（但不完全）的表格字体继承 • 减小sup和sub对line-height的影响 瀑布流 实现方式： 1. 传统多列浮动 * 各列固定宽度，并且左浮动； * 一列中的数据块为一组，列中的每个数据块依次排列即可； * 更多数据加载时，需要分别插入到不同的列上； 优点: 布局简单，应该说没啥特别的难点； 不用明确知道数据块高度，当数据块中有图片时，就不需要指定图片高度。 缺点: 列数固定，扩展不易，当浏览器窗口大小变化时，只能固定的x列，如果要添加一列，很难调整数据块的排列； 滚动加载更多数据时，还要指定插入到第几列中，还是不方便。 2. CSS3 定义,多列布局 #container { -webkit-column-count: 5； /*-webkit-column-gap: 10px； -webkit-column-rule: 5px solid #333； -webkit-column-width: 210px；*/ -moz-column-count: 5； /*-moz-column-gap: 20px； -moz-column-rule: 5px solid #333； -moz-column-width: 210px；*/ column-count: 5； /*column-gap: 10px； column-rule: 5px solid #333； column-width: 210px；*/ } column-count 为列数； column-gap 为每列间隔距离； column-rule 为间隔边线大小； column-width 为每列宽度； 当只设置 column-width 时，浏览器窗口小于一列宽度时，列中内容自动隐藏； 当只设置 column-count 时，平均计算每列宽度，列内内容超出则隐藏； 都设了 column-count 和column-width，浏览器会根据 count 计算宽度和 width 比较，取大的那个值作为每列宽度，然后当窗口缩小时，width 的值为每列最小宽度。 优点: 直接 CSS 定义，最方便了； 扩展方便，直接往容器里添加内容即可。 缺点: 只有高级浏览器中才能使用； 还有一个缺点，他的数据块排列是从上到下排列到一定高度后，再把剩余元素依次添加到下一列，这个本质上就不一样了； 鉴于这两个主要缺点，注定了该方法只能局限于高端浏览器，而且，更适合于文字多栏排列。 3.绝对定位（最优方案） 方便添加数据内容，窗口变化，列数/数据块会自动调整 缺点: 需要实现知道数据块高度，如果其中包含图片，需要知道图片高度； JS 动态计算数据块位置，当窗口缩放频繁，可能会狂耗性能。 什么是FOUC?如何避免 Flash Of Unstyled Content：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。同时加载css文件会阻塞文件下载，在FF下，添加&lt;script&gt; &lt;/script&gt;(中间有空格) 解决方法：把样式表放到文档的head 渐进增强和优雅降级 渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 JavaScript 数据类型 基础数据类型：null、undefined、boolean、string、number 引用数据类型：Object 、Array 、Date、RegExp 、Function、自定义对象 undefined与null JavaScript 有两个表示‘空’的值，其中比较有用的是 undefined。 undefined 的值 undefined 是一个值为 undefined 的类型。 这个语言也定义了一个全局变量，它的值是 undefined，这个变量也被称为 undefined。 但是这个变量不是一个常量，也不是一个关键字。这意味着它的值可以轻易被覆盖。 ES5 提示: 在 ECMAScript 5 的严格模式下，undefined 不再是 可写的了。 但是它的名称仍然可以被隐藏，比如定义一个函数名为 undefined。 下面的情况会返回 undefined 值： 1.访问未修改的全局变量 undefined。 2.由于没有定义 return 表达式的函数隐式返回。 3.return 表达式没有显式的返回任何内容。 4.访问不存在的属性。 5.函数参数没有被显式的传递值。 6.任何被设置为 undefined 值的变量。 7.处理 undefined 值的改变 由于全局变量 undefined 只是保存了 undefined 类型实际值的副本， 因此对它赋新值不会改变类型 undefined 的值。 然而，为了方便其它变量和 undefined 做比较，我们需要事先获取类型 undefined 的值。 为了避免可能对 undefined 值的改变，一个常用的技巧是使用一个传递到匿名包装器的额外参数。 在调用时，这个参数不会获取任何值。 var undefined = 123; (function(something, foo, undefined) { // 局部作用域里的 undefined 变量重新获得了 `undefined` 值 })(&apos;Hello World&apos;, 42); 另外一种达到相同目的方法是在函数内使用变量声明。 var undefined = 123; (function(something, foo) { var undefined; ... })(&apos;Hello World&apos;, 42); 这里唯一的区别是，在压缩后并且函数内没有其它需要使用 var 声明变量的情况下，这个版本的代码会多出 4 个字节的代码。 null 的用处 JavaScript 中的 undefined 的使用场景类似于其它语言中的 null，实际上 JavaScript 中的 null 是另外一种数据类型。 它在 JavaScript 内部有一些使用场景（比如声明原型链的终结 Foo.prototype = null），但是大多数情况下都可以使用 undefined 来代替。 继承 js继承方式 1、原型链继承 2、借用构造函数继承 3、组合继承(原型+借用构造) 4、原型式继承 5、寄生式继承 6、寄生组合式继承 闭包 闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量。闭包作用域链通常包括三个部分： * 函数本身作用域。 * 闭包定义时的作用域。 * 全局作用域。 闭包常见用途： * 创建特权方法用于访问控制 * 事件处理程序及回调 * 模块化代码，减少全局污染 缺点： 1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对像（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 模块化 使用模块化的原因？恼人的命名冲突,烦琐的文件依赖 通过匿名函数的形式来模仿模块化 (function(){ //块级作用域 })( ); 对象形式 var module1 = new Objec({ name : &apos;xhay&apos;, m1 : function(){ ... }, m2 : function(){ ... } return{ m1:m1, m2:m2 } }); 可扩展的写法 var module1 = (function(mod){ mod.m3 = function(){ ... } return mod； })(window.module1||{}); CMD 与AMD &amp; CommonJs ​ AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。 ​ CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 ​ 类似的还有 CommonJS Modules/2.0 规范，是 BravoJS 在推广过程中对模块定义的规范化产出。还有不少⋯⋯ ​ 这些规范的目的都是为了 JavaScript 的模块化开发，特别是在浏览器端的。 ​ 目前这些规范的实现都能达成浏览器端模块化开发的目的。 ​ commonJs是应用在NodeJs，是一种同步的模块机制. 大致写法： var firstModule = require(&quot;firstModule&quot;); //your code... module.export = anotherModule npm成为主流的JavaScript组件发布平台，也越来越多会依赖。 ​ 区别： 1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible. 2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码： // CMD define(function(require, exports, module) { var a = require(&apos;./a&apos;) a.doSomething() // 此处略去 100 行 var b = require(&apos;./b&apos;) // 依赖可以就近书写 b.doSomething() // ... }) // AMD 默认推荐的是 define([&apos;./a&apos;, &apos;./b&apos;], function(a, b) { // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() ... }) 虽然 AMD 也支持 CMD 的写法，同时还支持将 require 作为依赖项传递，但 RequireJS 的作者默认是最喜欢上面的写法，也是官方文档里默认的模块定义写法。 3. AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。 原型链 在 javaScript 中，每个对象都有一个指向它的原型（prototype）对象的内部链接。这个原型对象又有自己的原型，直到某个对象的原型为 null 为止（也就是不再有原型指向），组成这条链的最后一环。这种一级一级的链结构就称为原型链（prototype chain）。 作用域与作用域链​​ 简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，变量的作用域有全局作用域和局部作用域两种。 全局作用域 （1）最外层函数和在最外层函数外面定义的变量拥有全局作用域。 （2）所有末定义直接赋值的变量自动声明为拥有全局作用域 （3）所有window对象的属性拥有全局作用域 局部作用域 ​ 局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部。也为函数作用域。 作用域链 ​ 函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]]，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链。​ 每个执行环境都有一个与之关联的变量对象，而每个函数都有自己的执行环境。 事件模型与实现机制 在传递到目标元素后，如果它有子元素并不会停还是会往下传。 事件模型： 原生事件模型、标准事件模型、IE事件模型 1.基础事件处理 a).HTML标签的事件 &lt;div onmouseover = &quot;f(this,event)&quot;&gt; b).javascript事件处理 element.onmouseover = function(){} 2.高级事件 事件传播：事件冒泡，事件捕获 标准事件：既能冒泡传播也能捕获传播 addEventListener(&quot;click&quot;,f,false/true); //可以注册多个事件处理函数 IE事件模型 只支持事件冒泡传播 attachEvent(&quot;onclick&quot;,f); 同时IE的Event对象是window的全局对象，只有事件发生时可以访问。 事件冒泡是否想起了冒泡算法，即由最具体的元素（文档嵌套最深节点）接收，然后逐步上传至document。 事件捕获会由最先接收到事件的元素然后传向最里边（我们可以将元素想象成一个盒子装一个盒子，而不是一个积木堆积） DOM事件流 DOM2级事件规定事件包括三个阶段： ① 事件捕获阶段 ② 处于目标阶段 ③ 事件冒泡阶段 停止冒泡，阻止事件的默认行为 不冒泡的事件：load, change, submit, focus, blur 跨域 同源策略 所谓同源是指，域名，协议，端口相同。限制了一个源(origin)中加载文本或脚本与来自其它源(origin)中资源的交互方式。 当一个浏览器的两个tab页中分别打开来 百度和谷歌的页面 当浏览器的百度tab页执行一个脚本的时候会检查这个脚本是属于哪个页面的， 即检查是否同源，只有和百度同源的脚本才会被执行。 JSONP​​ 原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。​ 由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。 function handleResponse(response){ alert(&quot;You’ re at IP address &quot; + response.ip + &quot;, which is in &quot; + response.city + &quot;, &quot; + response.region_name); } var script = document.createElement(&quot;script&quot;); script.src = &quot;http://freegeoip.net/json/?callback=handleResponse&quot;; document.body.insertBefore(script, document.body.firstChild); 优点是兼容性好，简单易用，支持浏览器与服务器双向通信。 缺点是只支持GET请求,JSONP 是从其他域中加载代码执行，安全不能保证。 *Window.name+iframe* 原理：在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。 跨域数据即由iframe的window.name从外域传递到本地域类似src属性，则绕过了跨域。 限制：window.name的值只能是字符串的形式，这个字符串的大小最大能允许2M左右，取决于浏览器， IE和firefox下可以大至32M左右 优点：安全（可以销毁iframe，不被其他域frame js访问），比FIM更快 总结：iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 使用方式： a.com/app.html：应用页面。 a.com/proxy.html：代理文件，一般是一个没有任何内容的html文件，需要和应用页面在同一域下。 b.com/data.html：应用页面需要获取数据的页面，可称为数据页面。 *通过修改document.domain来跨子域* *动态创建script* 原理：浏览器并不禁止在页面中引用其他域的JS文件，并可以自由执行引入的JS文件中的function。可以方便地通过创建script节点的方法来实现完全跨域的通信。 注意：ie只能通过script的readystatechange属性，其它浏览器是script的load事件。以下是部分判断script加载完毕的方法。 js.onload = js.onreadystatechange = function() { if (!this.readyState || this.readyState === &apos;loaded&apos; || this.readyState === &apos;complete&apos;) { // callback在此处执行 js.onload = js.onreadystatechange = null; } }; 扩展： a.使用了Ajax，如何解决跨域问题 1. 通过修改document.domain和隐藏的IFrame来实现跨域请求。这种方案可能是最简单的一种跨域请求的方案，但是它同样是一种限制最大的方 案。首先，它只能实现在同一个顶级域名下的跨域请求；另外，当在一个页面中还包含有其它的IFrame时，可能还会产生安全性异常，拒绝访问。 2.通过请求当前域 的代理，由服务器 代理去访问另一个域的资源。XMLHttpRequest通过请求本域内的一个服务器资源 ，将要访问的目标资源提供给服务器，交由服务器 去代理访问目标资源。这种方案，可以实现完全的跨域访问，但是开发，请求过程的消费会比较大。 3.jQuery的ajax有jsonp这样的属性可以用来解决跨域的问题。 4. 一个专门用来解决跨域问题的jQuery插件-jquery-jsonp。 内存泄漏 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） （1）、内存溢出：当你运行一个程序的时候，程序所需要的内存系统无法满足（系统的内存空间不够），造成内存溢出。 在IE下的JS编程中，以下的编程方式都会造成即使关闭IE也无法释放内存的问题给DOM对象添加的属性是一个对象的引用。 范例 1： var MyObject = {}; document.getElementById(&apos;myDiv&apos;).myProp = MyObject; 解决方法： 在window.onunload事件中写上: document.getElementById(&apos;myDiv&apos;).myProp = null; DOM对象与JS对象相互引用。 范例 2： function Encapsulator(element) { this.elementReference = element; element.myProp = this; } new Encapsulator(document.getElementById(&apos;myDiv&apos;)); } 解决方法： 在onunload事件中写上: document.getElementById(&apos;myDiv&apos;).myProp = null; 给DOM对象用attachEvent绑定事件。 范例 3： function doClick() {} element.attachEvent(&quot;onclick&quot;, doClick); 解决方法： 在onunload事件中写上: element.detachEvent(&apos;onclick&apos;, doClick); 范例4: 从外到内执行appendChild。这时即使调用removeChild也无法释放。范例： var parentDiv = document.createElement(&quot;div&quot;); var childDiv = document.createElement(&quot;div&quot;); document.body.appendChild(parentDiv); parentDiv.appendChild(childDiv); 解决方法：从内到外执行appendChild: var parentDiv = document.createElement(&quot;div&quot;); var childDiv = document.createElement(&quot;div&quot;); parentDiv.appendChild(childDiv); document.body.appendChild(parentDiv); 范例5：反复重写同一个属性会造成内存大量占用(但关闭IE后内存会被释放)。 for(i = 0; i &lt; 5000; i++) { hostElement.text = &quot;zchubyoyo&quot;; } 这种方式相当于定义了5000个属性！ （2）.内存泄漏：当运行程序的时候，系统会按照所需分配给内存，当程序运行之后，这些内存空间没有办法被收回，就是造成了内存的泄漏。 常见的内存溢出--循环引用 function fun(){ var element = document.getElementById(“id”); element.onclick = function(){ alert(element.id); } } 这个是我们在js中经常写的一个方法，它将导致内存的泄漏，你想到了吗？ 解决方案： function fun(){ var element = document.getElementById(“id”); var id = element.id; element.onclick = function(){ alert(id); } element = null; } Ajax 1.干掉了Back和History功能，浏览器后退机制的破坏 解决方式：Gmail (通过创建或使用一个隐藏的IFRAME来重现页面上的变更),它在一个隐藏的IFRAME中进行搜索，然后将搜索结果反映到Ajax元素上，以便将应用程序状态恢复到当时的状态 缺点：开发成本是非常高的 2.安全问题 ajax的逻辑可以对客户端的安全扫描技术隐藏起来，允许黑客从远端服务器上建立新的攻击 优点 1.页面无刷新，在页面内与服务器通信，给用户的体验非常好 2.使用异步方式与服务器通信，不需要打断用户的操作 3.前端和后端负载平衡。减轻服务器的负担，可以最大程度的减少冗余请求，和响应对服务器造成的负担。 Ajax的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。 Ajax其核心有JavaScript、XMLHTTPRequest、DOM对象组成，通过XmlHttpRequest（get与post方式）对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据 XMLHttpRequest是ajax的核心机制 ajax所包含的技术 大家都知道ajax并非一种新的技术，而是几种原有技术的结合体。它由下列技术组合而成。 1.使用CSS和XHTML来表示。 2. 使用DOM模型来交互和动态显示。 3.使用XMLHttpRequest来和服务器进行异步通信。 4.使用javascript来绑定和调用。 NodeJs 适用场景：高并发、聊天、实时消息推送 优点：因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。 缺点：Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。 jQuery​​ jquery缺点​ 安全问题：由于JavaScript在客户端运行，可能被用于黑客目的。​ 冲突问题：有多个插件容易引起冲突。尤其是这些插件依赖相同事件或selector时最为明显。​ 插件兼容性。在最新版jQuery版本下，现有插件可能无法正常使用。​ 不能向后兼容。每一个新版本不能兼容早期的版本。这可能会影响到开发者已经编写好的代码或插件。​ 优点：​ 1.强大的选择器​ 许开发者使用从CSS1到CSS3几乎所有的选择器或自定义的选择器​ 2.DOM操作的封装​ JQuery封装了大量常用的DOM操作，使开发者在编写DOM操作相关程序的时候能够得心应手​ 3.不污染顶级变量​ JQuery只建立一个名为JQuery的对象，其所有的函数方法都在这个对象之下。其别名$也可以随时交流控制权，绝对不会污染其他的对象。​ 4.链式操作方式​ JQuery中最有特色的莫过于它的链式操作方式——即对发生在同一个JQuery对象上的一组动作，可以直接接连写无需要重复获取对象。这一特点使得JQuery的代码无比优雅。 HTML DOM 操作​​ （1）创建新节点​ createDocumentFragment() //创建一个DOM片段​ createElement() //创建一个具体的元素​ createTextNode() //创建一个文本节点​ （2）添加、移除、替换、插入​ appendChild()​ removeChild()​ replaceChild()​ insertBefore()​ （3）查找​ getElementsByTagName() //通过标签名称​ getElementsByName() //通过元素的Name属性的值​ getElementById() //通过元素Id，唯一性​ querySelector(“.class”); //返回文档中匹配指定的CSS选择器的第一元素​ querySelectorAll(); //返回文档中匹配的CSS选择器的所有元素节点列表​ （4）复制​ importNode(node,deep)//如果为 true，还要递归复制node的所有子孙节点。 ajax过程 (1)创建`XMLHttpRequest`对象,也就是创建一个异步调用对象. (2)创建一个新的`HTTP`请求,并指定该`HTTP`请求的方法、`URL`及验证信息. (3)设置响应`HTTP`请求状态变化的函数. (4)发送`HTTP`请求. (5)获取异步调用返回的数据. (6)使用JavaScript和DOM实现局部刷新. var xmlHttp = new XMLHttpRequest(); xmlHttp.open(&apos;GET&apos;,&apos;demo.php&apos;,&apos;true&apos;); xmlHttp.send() xmlHttp.onreadystatechange = function(){ if(xmlHttp.readyState === 4 &amp; xmlHttp.status === 200){ } } MVC和MVVM的理解 MVC代表： backboneJs Controller/Presenter负责逻辑的处理，Model提供数据，View负 责显示。在MVC中View会从直接Model中读取数据。 组成部分： View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈 MVVM : AngularJs,Avalon 是真正将页面与数据逻辑分离的模式，在开发方式上，它是真正将前台代码开发者（JS+HTML）与后台代码开发者分离的模式。 组成部分Model、View、ViewModel： View：UI界面 ViewModel：它是View的抽象，负责View与Model之间信息转换，将View的Command传送到Model； Model：数据访问层 ES6了解​​ 语言语法 – 语法解析规则、关键字、语句、声明、运算符等。​ 类型 – 布尔型、数字、字符串、对象等。​ 原型和继承​ 内建对象和函数的标准库 – JSON、Math、数组方法、对象自省方法等。 浏览器访问页面发生了什么－详述​​ 第一步，解析域名，找到主机IP （1）浏览器会缓存DNS一段时间，一般2-30分钟不等。如果有缓存，直接返回IP，否则下一步。 （2）缓存中无法找到IP，浏览器会进行一个系统调用，查询hosts文件。如果找到，直接返回IP，否则下一步。（在计算机本地目录etc下有一个hosts文件，hosts文件中保存有域名与IP的对应解析，通常也可以修改hosts科学上网或破解软件。） （3）进行了（1）（2）本地查询无果，只能借助于网络。路由器一般都会有自己的DNS缓存，ISP服务商DNS缓存，这时一般都能够得到相应的IP。如果还是无果，只能借助于DNS递归解析了。 （4）这时，ISP的DNS服务器就会开始从根域名服务器开始递归搜索，从.com顶级域名服务器，到baidu的域名服务器。 到这里，浏览器就获得了IP。在DNS解析过程中，常常会解析出不同的IP。比如，电信的是一个IP，网通的是另一个IP。这是采取了智能DNS的结果，降低运营商间访问延时，在多个运营商设置主机房，就近访问主机。电信用户返回电信主机IP，网通用户返回网通主机IP。当然，劫持DNS，也可以屏蔽掉一部分网点的访问，某防火长城也加入了这一特性。 第二部，浏览器与网站建立TCP连接 浏览器利用IP直接与网站主机通信。浏览器发出TCP（SYN标志位为1）连接请求，主机返回TCP（SYN，ACK标志位均为1）应答报文，浏览器收到应答报文发现ACK标志位为1，表示连接请求确认。浏览器返回TCP（）确认报文，主机收到确认报文，三次握手，TCP链接建立完成。 第三部分，浏览器发起GET请求 浏览器向主机发起一个HTTP-GET方法报文请求。请求中包含访问的URL，也就是http://www.baidu.com/ ，还有User-Agent用户浏览器操作系统信息，编码等。值得一提的是Accep-Encoding和Cookies项。Accept-Encoding一般采用gzip，压缩之后传输html文件。Cookies如果是首次访问，会提示服务器建立用户缓存信息，如果不是，可以利用Cookies对应键值，找到相应缓存，缓存里面存放着用户名，密码和一些用户设置项。 第四部分，显示页面或返回其他 返回状态码200 OK，表示服务器可以相应请求，返回报文，由于在报头中Content-type为“text/html”，浏览器以HTML形式呈现，而不是下载文件。 但是，对于大型网站存在多个主机站点，往往不会直接返回请求页面，而是重定向。返回的状态码就不是200 OK，而是301,302以3开头的重定向码，浏览器在获取了重定向响应后，在响应报文中Location项找到重定向地址，浏览器重新第一步访问即可。 补充一点的就是，重定向是为了负载均衡或者导入流量，提高SEO排名。利用一个前端服务器接受请求，然后负载到不同的主机上，可以大大提高站点的业务并发处理能力；重定向也可将多个域名的访问，集中到一个站点；由于baidu.com，www.baidu.com会被搜索引擎认为是两个网站，照成每个的链接数都会减少从而降低排名，永久重定向会将两个地址关联起来，搜索引擎会认为是同一个网站，从而提高排名。 DNS解析过程详解 1、在浏览器中输入www.example.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 2、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13组根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(example.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找example.com域服务器，重复上面的动作，进行查询，直至找到www.example.com主机。 6、如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 cookie及其操作​​ 目前还是很多登陆的方式还是通过cookie的方式来处理的。 cookie是web浏览器存储的少量数据，最早设计为服务器端使用，作为HTTP协议的扩展实现。cookie数据会自动在浏览器和服务器之间传输。 通过读写cookie检测是否支持 cookie属性有名，值，max-age，path, domain，secure； cookie默认有效期为浏览器会话，一旦用户关闭浏览器，数据就丢失，通过设置max-age=seconds属性告诉浏览器cookie有效期 cookie作用域通过文档源和文档路径来确定，通过path和domain进行配置，web页面同目录或子目录文档都可访问 通过cookie保存数据的方法为：为document.cookie设置一个符合目标的字符串如下 读取document.cookie获得&apos;; &apos;分隔的字符串，key=value,解析得到结果。 document.cookie = &apos;name=qiu; max-age=9999; path=/; domain=domain; secure&apos;; document.cookie = &apos;name=aaa; path=/; domain=domain; secure&apos;; // 要改变cookie的值，需要使用相同的名字、路径和域，新的值 // 来设置cookie，同样的方法可以用来改变有效期 // 设置max-age为0可以删除指定cookie //读取cookie，访问document.cookie返回键值对组成的字符串， //不同键值对之间用&apos;; &apos;分隔。通过解析获得需要的值 HTTP请求头了解​​ HTTP请求信息由3部分组成：​ 请求方法URI协议/版本​ 请求头(Request Header)​ 请求正文​​ date：请求时间​ expires:过期时间​​ referer:关联连接​ Referer可以记录访问的来源，统计访问量，可以用来防盗链。​ 利用Referer防止图片盗链​ 但是referer可以被修改​ 1.服务器端修改Referer，通过webClient，直接设置访问可以达到修改目的。​ 2.可以使用Fiddler修改Referer。​ If- Modified-Since：与客户端缓存相关，如果有，服务器返回304 TCP 三次握手与四次挥手 三次握手： 第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 四次握手 与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。 CDN CDN的全称是Content Delivery Network，即内容分发网络。 构建目的：是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。 CDN（内容《对象》，分发《方法》，网络《载体》） 内容：主要是静态资源，页面，图片，脚本等。 分发：（主动）去源站抓取数据和提供用户上传的接口，（被动）缓存设备和软件 网络：基础（电信），专营（卫通） 作用：本地cache加速，镜像服务，远程加速，宽带优化，集群抗攻击 Cdn的技术原理 ​ 负载均衡分布，网络传送上利用缓存技术，就近获取资源。 ​ 减少网络中冗余数据的重复传输，使之最小化，将广域传输转为本地或就近访问。互联网上传递的内容，大部分为重复的Web/FTP数据。（Cache服务器具有缓存，优化数据链路性能，大部分为网页对象：（web Page object,html 等页面文件，图片文件。但要通过简单的认证）） 多台Cache加速服务器且分布在不同地域，需要通过有效地机制管理Cache网络，引导用户就近访问，全局负载均衡流量。复制到网络“边缘”，缩小“请求点”与”交互点“。 内容发布网络(CDN)是一个经策略性部署的整体系统，包括分布式存储、负载均衡、网络请求的重定向和内容管理４个要件。 内容服务基于缓存服务器（代理缓存）,离用户只有“一跳”。而（城域网，域内网络快主要是Internet的内容高速缓存到本地，cache放在各POP点上） 工作原理：CDN中间添加了Cache层，然后通过接管DNS来引导数据获得源服务器的数据。 ​ 常用的技术手段：高速缓存、镜像服务器。适用于(静态和准动态数据同步) 全局负载均衡DNS通过一组预先定义好的策略，将当时最接近用户的节点地址提供给用户，使用户能够得到快速的服务。 负载均衡设备负责每个节点中各个Cache的负载均衡，保证节点的工作效率；同时，负载均衡设备还负责收集节点与周围环境的信息，保持与全局负载DNS的通信，实现整个系统的负载均衡。 高速缓存服务器（Cache）负责存储客户网站的大量信息，就像一个靠近用户的网站服务器一样响应本地用户的访问请求。 简单地说，内容分发网络是一个经策略性部署的整体系统，包括分布式存储、负载均衡、网络请求的重定向和内容管理4个要求，而内容管理和全局的网络流量管理是CDN的核心所在。通过用户就近性和服务器负载的判断，CDN确保内容以一种极为高效的方式为用户的请求提供服务。 分发服务系统：最基本的工作单元就是Cache设备，cache（边缘cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用户。同时cache还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache设备的数量、规模、总服务能力是衡量一个CDN系统服务能力的最基本的指标 负载均衡系统：主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本地负载均衡（SLB）。GSLB主要根据用户就近性原则，通过对每个服务节点进行“最优”判断，确定向用户提供服务的cache的物理位置。SLB主要负责节点内部的设备负载均衡。 使用CDN的好处，优点 ​ 1. 不用担心自己网站访客，在任何时间，任何地点，任何网络运营商，都能快速打开网站。 ​ 2. 各种服务器虚拟主机带宽等采购成本，包括后期运维成本都会大大减少。 ​ 3. 给网站直接带来的好处就是：流量，咨询量，客户量，成单量，都会得到大幅度提升。 HTTPS HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容请看SSL。 SSL的工作原理 握手协议（Handshake protocol） 记录协议（Record protocol） 警报协议（Alert protocol） HTT82.0​​ 相比HTTP1.1优点集中在：​ 异步连接多路复用​ HEAD 压缩​ 压缩HTTP头；​ 服务器推送流（即Server Push技术）；​ 优先级请求​ 请求/响应管线化； 网络七层模型​​ 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）​ 数据链路层：将比特组装成帧和点到点的传递（帧Frame）​ 网络层：负责数据包从源到宿的传递和网际互连（包PackeT）​ 传输层：提供端到端的可靠报文传递和错误恢复（段Segment）​ 会话层：建立、管理和终止会话（会话协议数据单元SPDU）​ 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）​ 应用层：允许访问OSI环境的手段（应用协议数据单元APDU） 域名收敛 因为DNS使用UDP不稳定，随时可能丢在保证了域名收敛之后，同样域名下的资源请求将可以完全复用第一次的DNS建连和SSL握手， 第一个就是减少 DNS 的请求，第二个就是缩短 DNS 解析路径。 第一个就是做域名收敛的主要原因，相比于 PC 是对于域名的并发限制，无线上来说对并发的要求会弱很多（一般尽量是第一屏，后面使用懒加载）。 第二个就是缩短解析路径，这里所说的缩短解析路径其实就说各级的缓存：本机的缓存，LocalDNS 的缓存，不过他们或多或少也不靠谱，尤其是运营商的 LocalDNS 给你劫持一下，篡改一下都是常有的事情，于是这个情况下，就有了 HttpDNS。 HttpDNS 是为了解决移动端 DNS 解析请求而生的，顺便解决 DNS 劫持，合并请求和缓存结果进而提高解析质量。 而在我们访问网络中 DNS解析过程（域名 --&gt; 运营商（localDNS）—-&gt; 权威DNS） Web浏览器安全 XSS xss(cross site script)跨站脚本攻击通过属性”src”加载来执行代码在获取网站或者网站服务器的部分或者全部权限后，在网页文件中插入一段恶意代码，来实现攻击。 1.DOM—based XSS 该漏洞是基于文档对象模型Document Objeet Model,DOM)触发的。 &lt;div id=&quot;print&quot;&gt;&lt;/div&gt; //javascript var text = document.getElementById(&quot;print&quot;); print.innerHTML = text.value; 解决方式： * 编码方式 //将要转换的字符串设置为这个元素的innerText(ie支持)或者textContent(火狐，google支持) (temp.textContent != undefined ) ? (temp.textContent = html) : (temp.innerText = html); //返回这个元素的innerHTML，即得到经过HTML编码转换的字符串了 var output = temp.innerHTML; * 解码方式 //将要转换的字符串设置为这个元素的innerHTML(ie，火狐，google都支持) temp.innerHTML = text; //返回这个元素的innerText(ie支持)或者textContent(火狐，google支持)，即得到经过HTML解码的字符串了。 var output = temp.innerText || temp.textContent; 2.存储型xss 即通常我们在录入数据时通过闭合标签的方式把数据存储到数据库中，再次显示的时候触发。 解决方式：转义标签 如： &lt; 转义为 &amp;lt； &gt; 转义为 &amp;gt； ​​ 3.反射型xss​​ 仍然来自于直接的用户输入，是在通过url控制了页面的输出（处理：转义字符）根据浏览器去bypass各种过滤，易用性稍微差一些。但最后在页面中显示出来，并需要用户自己去点击链接才能触发XSS的是反射型XSS。​ http://www.jpl.nasa.gov/about_JPL /maps.cfm?departure=lax%22 %3Cimg%20src=k.png%20onerror=alert(%22XSSed%20by%20sH%22)%20/%3E​​ 总结：反射型xss和dom-xss都需要在url加入js代码才能够触发。 CSRF[cross site request fork] 跨站请求伪造,攻击者盗用了你的身份，以你的名义发送恶意请求。 如何防御 ​ 一般网站有三种防御CSRF攻击的方案。 ​ （1）验证token值。 ​ 在每个HTTP请求里附加一部分信息是一个防御CSRF攻击的很好的方法，因为这样可以判断请求是否已经授权。这个“验证token”应该不能轻易的被未登录的用户猜测出来。如果请求里面没有这个验证token或者token不能匹配的话，服务器应该拒绝这个请求。 ​ （2）验证HTTP头的Referer。 ​ 大多数情况下，当浏览器发起一个HTTP请求，其中的Referer标识了请求是从哪里发起的。如果HTTP头里包含有Referer的时候，我们可以区分请求是同域下还是跨站发起的，因为Referer离标明了发起请求的URL。网站也可以通过判断有问题的请求是否是同域下发起的来防御CSRF攻击。 ​ 缺点：通常Referer会包含有一些敏感信息，可能会侵犯用户的隐私 ​ （3）用XMLHttpRequest附加在header里。以上三种方法都在广泛使用，但是他们的效果都不是那么的令人满意。 ​ 在使用这种方法来防御CSRF攻击的时候，网站必须在所有的请求里使用XMLHttpRequest并附加一个自定义头（比如X-Requested-By），并且拒绝所有没有自定义头的的请求。例如，为了防御登陆CSRF的攻击，网站必须通过XMLHttpRequest的方式发送用户的身份验证信息到服务器。在我们的实验里，在服务器接收到的请求里面，大约有99.90–99.99%的请求是含有X-Requested-By头的，这表明这一方法适用于绝大多数的用户。 ​ ​ 推荐：Origin字段 ​ 修改浏览器在发送POST请求的时候加上一个Origin字段，这个Origin字段主要是用来标识出最初请求是从哪里发起的。如果浏览器不能确定源在哪里，那么在发送的请求里面Origin字段的值就为空。 ​ 隐私上：方式比Referer更人性化，因为它尊重了用户的隐私 sql注入​​ sql注入是攻击者把SQL命令插入到Web表单的输入域或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令。在某些表单中，用户输入的内容直接用来构造（或者影响）动态SQL命令，或作为存储过程的输入参数，这类表单特别容易受到SQL注入式攻击。​​ 需要注意点：​​ 1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双”-“进行转换等。​ 2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。 3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。 4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。 前端工程化前端构建工具目的就是为了开始开发。让前端开发真正达到工程化。先明确几个概念。​​ 包管理工具（package manager）：npm、bower、jspm、cnpm 等等​ 模块加载器（module loader）: requirejs、modjs、seajs 等等，模块加载器又主要遵循AMD、CMD、Commonjs三种规范​ 打包工具（bundler）：r.js、browserify、webpack​ 版本仓库： gitlab,coding,github​ 构建工具：gulp(基于stream的构建工具)、grunt gulp gulp.js 是一种基于流的，代码优于配置的新一代构建工具。gulp.js 是一个自动化构建工具,开发者可以使用它在项目开发过程中自动执行常见任务。是基于 Node.js 构建的,利用 Node.js 流的威力,你可以快速构建项目 gulp有很多插件－而这些插件就赋予了gulp众多的功能 ​ 编译Sass (gulp-ruby-sass) ​ Autoprefixer (gulp-autoprefixer) ​ 缩小化(minify)CSS (gulp-minify-css) ​ JSHint (gulp-jshint) ​ 拼接 (gulp-concat) ​ 丑化(Uglify) (gulp-uglify) ​ 图片压缩 (gulp-imagemin) ​ 即时重整(LiveReload) (gulp-livereload) ​ 清理档案 (gulp-clean) ​ 图片快取，只有更改过得图片会进行压缩 (gulp-cache) ​ 更动通知 (gulp-notify)​ 优点： ​ 易于使用: 通过代码优于配置的策略，Gulp 让简单的任务简单，复杂的任务可管理。 ​ 构建快速:利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。 ​ 插件高质:Gulp 严格的插件指南确保插件如你期望的那样简洁高质得工作。 webpack + tree-shaking Webpack 是德国开发者 Tobias Koppers 开发的模块加载器,在 Webpack 当中, 所有的资源都被当作是模块, js, css, 图片等等..因此, Webpack 当中 js 可以引用 css, css 中可以嵌入图片 dataUrl module: { loaders: [ { test: /\\.coffee$/, loader: &apos;coffee-loader&apos; }, { test: /\\.js$/, loader: &apos;jsx-loader?harmony&apos; } // loaders can take parameters as a querystring ] }, 我理解就是：你在开发的过程中，需要通过AMD、CMD的方式引入其他文件，这时就需要webpack把它们组装起来，里面可以引入图片或者css文件。这样的好处自然就非常明显了，减少请求。 特点： a) 模块来源广泛，支持包括npm/bower等等的各种主流模块安装／依赖解决方案 b) 模块规范支持全面，amd/cmd/commonjs/shimming等完全支持 c) 浏览器端足迹小，移动端友好，却对热加载乃至热替换有很好的支持 d) 插件机制完善，实现本身实现同样模块化，容易扩展，支持es6，react等 e) 需要手写配置 优点： a) 支持主流模块格式（AMD、CommonJs、globals） b) 能快速检测有错的模块 c) 能操作css d) 有综合性强的缓存机制（如果你的项目涉及到CDN） e) 支持热部署（App 代码请求 HMR 运行时应用更新） f) 几乎能加载所有的东西（文档有加载的list） tree-shaking tree-shaking是RollUP中的一种技术，tree-shaking是下一代前端打包工具(PS:这一代斗没有用好，前端发展太快了) 通过 tree-shaking 打包的结果只包括 /*实际用到的 exports*/。Three-shaking 的关键在于依赖 ES6 模块的静态结构。“静态结构”意味着在编译时他们是可分解的，而不用执行它们的任何代码，简单理解是ES6导出的部分如果在其它模块没有调用，rollup在输出时会直接把这部分作为死码删除。 github与Git Git是一个分布式的版本控制系统,版本控制工具。 github是一个用git做版本控制的项目托管平台，用来存放仓库(repo)。 作为前端，开源的世界很美好。 npm 官方网站NPM的全称是Node Package Manager ，是一个NodeJS包管理和分发工具。 我们在安装很多项目中，有使用npm install就是依赖了很多放在npm上的包。类似java中的jar包。 NPM是基于couchdb的一个数据库，详细记录了每个包的信息，包括作者、版本、依赖、授权信息等。它的一个很重要的作用就是：将开发者从繁琐的包管理工作（版本、依赖等）中解放出来，更加专注于功能的开发。 基本信息： package.json：包描述信息，里面的dependencies参数就是 npm install 时需要安装的包。应用依赖模块会安装到当前模块的node_modules目录下。 package版本：常见版本声明形式。 数据结构 作为学过java的童鞋，还是不要把数据结构忘了，记得某某人说过 “程序 ＝ 数据结构 ＋ 算法”，所以把他们放得这么靠后。特别像一些大公司特别注重这方面，前端和后端类似刀刃和刀背的关系！比如美团特别重视。 在复习的过程中，看得比较多的还是c语言和java版本的。 操作系统 堆和栈的区别​​ 栈中存放的数据类型有：局部变量、操作数、动态连接、返回地址​ 堆同时也是被所有线程所共享。存放对象实例，几乎所有的对象实例以及数组都要在这里分配内存。被GC（Garbage Colletor）管理。可以自动回收​ 1、内存分配方面：​ 堆：一般由程序员分配释放，并指明大小。 若程序员不释放，程序结束时可能由OS回收 。和数据结构不同，分配方式是类似于链表。可能用到的关键字如下：new、malloc、delete、free等等。​ 栈：由编译器(Compiler)自动分配释放，存放函数的参数值，局部变量的值等。​ 2.系统响应​ 堆：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序​ 栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 3.大小限制​ 堆：是向高地址扩展的数据结构，由于链表，所以是不连续的内存区域。堆的大小受限于计算机系统中有效的虚拟内存。​ 栈：在Windows下, 栈是向低地址扩展的数据结构，是一块连续的内存的区域。WINDOWS下，栈的大小是固定的（是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。 4.效率方面​ 堆：是由new分配的内存，一般速度比较慢，而且容易产生内存碎片​ 栈：由系统自动分配，速度较快。但程序员是无法控制的。 5.存取效率​ 堆：char *s1 = “Hellow Word”；是在编译时就确定的；​ 栈：char s1[] = “Hellow Word”； 是在运行时赋值的；用数组比用指针速度要快一些，因为指针在底层汇编中需要用edx寄存器中转一下，而数组在栈上直接读取。什么是死锁？其条件是什么？怎样避免死锁？​​ 死锁的概念：在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗地讲，就是两个或多个进程被无限期地阻塞、相互等待的一种状态。​ 死锁产生的原因主要是：？ 系统资源不足；？ 进程推进顺序非法。​ 产生死锁的必要条件：​ （1）互斥（mutualexclusion），一个资源每次只能被一个进程使用；​ （2）不可抢占（nopreemption），进程已获得的资源，在未使用完之前，不能强行剥夺；​ （3）占有并等待（hold andwait），一个进程因请求资源而阻塞时，对已获得的资源保持不放；​ （4）环形等待（circularwait），若干进程之间形成一种首尾相接的循环等待资源关系。​ 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。​ 死锁的解除与预防：理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。​ 死锁的处理策略：鸵鸟策略、预防策略、避免策略、检测与恢复策略。 你能描述一下当你制作一个网页的工作流程吗？ 内容分析：分清展现在网络中内容的层次和逻辑关系 结构设计：写出合理的html结构代码 布局设计：使用html+css进行布局 样式设计：首先要使用reset.css 交互设计：鼠标特效。行为设计：js代码，ajax页面行为和从服务器获取数据。最后测试兼容性。优化性能 为什么利用多个域名来提供网站资源会更有效？ 浏览器同一时间可以从一个域名下载多少资源？ 三个最主流的原因: CDN缓存更方便 突破浏览器并发限制 Cookieless, 节省带宽，尤其是上行带宽 一般比下行要慢。。。还有另外两个非常规原因: 对于UGC的内容和主站隔离，防止不必要的安全问题( 上传js窃取主站cookie之类的) 。正是这个原因要求用户内容的域名必须不是自己主站的子域名，而是一个完全独立的第三方域名。 数据做了划分，甚至切到了不同的物理集群，通过子域名来分流比较省事. ^_^ 这个可能被用的不多。PS: 关于Cookie的问题，带宽是次要的，安全隔离才是主要的。 关于多域名，也不是越多越好，虽然服务器端可以做泛解释，浏览器做dns解释也是耗时间的，而且太多域名，如果要走 https的话，还有要多买证书和部署的问题，^_^。 衡量网页性能的指标 DNS解析时间 TCP链接时间 HTTP重定向时间 首字节加载时间 HTML内容时间 整个页面对象加载时间 具体说明 DNS解析时间 DNS查找的时间就是将域名翻译成具体IP的时间，大多人数认为，无论DNS是否工作，都不是件简单的事情。 在这个过程中，你可能会遇到许多微妙的问题，比如响应时间太长、超时、无效的缓存等。这些情况下，一个查询便可通过，但它需要花费更多的时间。 通常，如果DNS的查找时间过长，那么意味着你或托管服务商的DNS服务有问题。记住，如果网站与其DNS服务之间距离太远，那么解析时间也会稍微增加，这在一些国际网站上会体现出来，而有效的缓存则会降低时间。 TCP链接时间 当URL被解析成一个IP地址后，TCP链接时间表示客户端链接到服务端所花费的时间。监控链接时间有助于开发者发现一些影响响应时间的问题，比如网络延时、路由问题、服务器宽带问题等。 例如，如果宽带服务器不足以处理工作负载，那么客户端要先与服务器端意识到这个问题，当客户端向服务器端发送请求时，可能会被拒绝或者时间超时、响应时间延迟等问题。 HTTP重定向时间 HTTP重定向时间主要是指TCP链接完成时间，它意味着发送初始通知到重定向网站并且浏览器最终定向到目标网站所花费的时间。如果没有重定向，那么重定向时间就为0。它包括了DNS解析时间、TCP链接等等。 HTTP重定向可用于缩短URL、当网页链接移动时，可用于防止链接损坏，或允许多个域名链接到一个网站上。 首字节加载时间 当开发人员思考如何优化网站时，往往会选择优化内容——文件组合、多媒体优化、缓存和压缩文件，但也有需要对服务器进行优化。其中一个最佳指标就是首字节的加载时间，首字节加载时间表示从链接创建到首字节成功转换所花费的时间。这个时间也包括了服务器执行各种协议和计算的时间。 通常服务器端遇到与首字节相关的问题包括内存泄露、程序派生的进程太多——没有完全关闭——低效SQL查询，并且调用外部资源，例如谷歌和Facebook。 HTML内容时间 HTML内容时间主要包括加载Web页面布局、CSS、JavaScript，这个时间与HTML页面的大小有着直接的关系。HTML内容加载时间通常会作为衡量宽带的一个指标，但也不完全是。 整个页面对象加载时间 一旦整个HTML内容被整个接收，浏览器会解析所有的页面对象，并且直到所有对象加载完毕。这些对象包括图片、JavaScript、CSS、Flas对象、RSS回馈、JavaScript文件等。 衡量全页加载时间对监控第三方内容非常有用，特别是广告，但它并不会告诉你有哪些用户看了这个广告。例如，它不会告诉你第三方内容放在哪加载速度会快些。但站在用户角度来看，这些并不算问题。 如果你参与到一个项目中，发现他们使用 Tab 来缩进代码，但是你喜欢空格，你会怎么做？ 建议这个项目使用像 EditorConfig (http://editorconfig.org/) 之类的规范 为了保持一致性，接受项目原有的风格 直接使用 VIM 的 retab 命令 你都使用哪些工具来测试代码的性能？ Profiler, JSPerf, Dromaeo 什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？ 如果使用import方法对CSS进行导入,会导致某些页面在Windows 下的Internet Explorer出现一些奇怪的现象:以无样式显示页面内容的瞬间闪烁,这种现象称之为文档样式短暂失效(Flash of Unstyled Content),简称为FOUC。 原因大致为： * 1，使用import方法导入样式表。 2，将样式表放在页面底部 3，有几个样式表，放在html结构的不同位置。 其实原理很清楚： 当样式表晚于结构性html加载，当加载到此样式表时，页面将停止之前的渲染。此样式表被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象。 解决方法： 使用LINK标签将样式表放在文档HEAD中。 请尽可能完整得描述下从输入URL到整个网页加载完毕及显示在屏幕上的整个流程 1）把URL分割成几个部分：协议、网络地址、资源路径。其中网络地址指示该连接网络上哪一台计算机，可以是域名或者IP地址，可以包括端口号；协议是从该计算机获取资源的方式，常见的是HTTP、FTP，不同协议有不同的通讯内容格式；资源路径指示从服务器上获取哪一项资源。例如：http://www.guokr.com/question/554991/协议部分：http网络地址：www.guokr.com资源路径：/question/554991/ 2）如果地址不是一个IP地址，通过DNS（域名系统）将该地址解析成IP地址。IP地址对应着网络上一台计算机，DNS服务器本身也有IP，你的网络设置包含DNS服务器的IP。例如：www.guokr.com 不是一个IP，向DNS询问请求www.guokr.com 对应的IP，获得IP： 111.13.57.142。这个过程里，你的电脑直接询问的DNS服务器可能没有www.guokr.com 对应的IP，就会向它的上级服务器询问，上级服务器同样可能没有，就依此一层层向上找，最高可达根节点，找到或者全部找不到为止。 3）如果地址不包含端口号，根据协议的默认端口号确定一个。端口号之于计算机就像窗口号之于银行，一家银行有多个窗口，每个窗口都有个号码，不同窗口可以负责不同的服务。端口只是一个逻辑概念，和计算机硬件没有关系。例如：www.guokr.com 不包含端口号，http协议默认端口号是80。如果你输入的url是http://www.guokr.com:8080/ ，那表示不使用默认的端口号，而使用指定的端口号8080。 4）向2和3确定的IP和端口号发起网络连接。例如：向111.13.57.142的80端口发起连接 5）根据http协议要求，组织一个请求的数据包，里面包含大量请求信息，包括请求的资源路径、你的身份例如：用自然语言来表达这个数据包，大概就是：请求 /question/554991/ ，我的身份是xxxxxxx。 6）服务器响应请求，将数据返回给浏览器。数据可能是根据HTML协议组织的网页，里面包含页面的布局、文字。数据也可能是图片、脚本程序等。现在你可以用浏览器的“查看源代码”功能，感受一下服务器返回的是什么东东。如果资源路径指示的资源不存在，服务器就会返回著名的404错误。 7）如果（6）返回的是一个页面，根据页面里一些外链的URL，例如图片的地址，按照（1）－（6）再次获取。 8）开始根据资源的类型，将资源组织成屏幕上显示的图像，这个过程叫渲染，网页渲染是浏览器最复杂、最核心的功能。 9）将渲染好的页面图像显示出来，并开始响应用户的操作。以上只是最基本的步骤，实际不可能就这么简单，一些可选的步骤例如网页缓存、连接池、加载策略、加密解密、代理中转等等都没有提及。即使基本步骤本身也有很复杂的子步骤，TCP/IP、DNS、HTTP、HTML：每一个都可以展开成庞大的课题，而浏览器的基础——操作系统、编译器、硬件等更是一个比一个复杂。不是计算机专业的同学看了上面的解释完全不明白是很正常的，可能会问为什么要搞得那么复杂，但我保证这每一个步骤都经过深思熟虑和时间的考验。你输入URL即可浏览互联网，而计算机系统在背后做了无数你看不到的工作，计算机各个子领域无数工程师为此付出你难以想象的努力。 文档为什么要分类型？ 如果文档不分类型，各浏览器就会形成多种写法，假如IE用&lt;title&gt;标签作为标题、火狐浏览器用&lt;caption&gt;标签作为标题，而另一种浏览器可能采用&lt;mytitle&gt;，这对于开发者和用户来说简直是灾难。W3C（万 维网联盟World Wide Web Consortium）制作了对所有方面都平衡的分歧解决方案，并且各浏览器没有异议，于是用&lt;!doctype&gt;（注意：作为一个特殊的标 签，它是不需要闭合的）标签来引入W3C的dtd文件，以达到规范页面的效果。这为浏览器的文档标准的统一以及开发人员和用户带了了便利。而html5不是基于SGML实现的，因此html不需要引入DTD，所以html5可以简单的声明一下&lt;!doctype html&gt;。 如果网页内容需要支持多语言，你会怎么做？ 采用统一编码UTF-8模式 在设计和开发多语言网站时，有哪些问题你必须要考虑？ 1、应用字符集的选择 2、语言书写习惯&amp;导航结构 3、数据库驱动型网站1、应用字符集的选择 一个定位于不同语言国家的企业网站势必需要提供多种语言版本的产品和销售信息来满足其世界各地使用不同语言的客户和合作伙伴，其中包括法语、德语、意大利语、葡萄牙语、西班牙语、阿拉伯语等等。但有一个问题却极易被网站设计者们所忽略。这就是网站的字符集设置问题。 一般我们使用的是简体中文(GB2312)字符集，而对多语言网站来说，中文字符集却可能会使你辛辛苦苦的努力功亏一篑。原因很简单：就是这个毫不起眼的小小字符集在作怪。 计算机应用领域中存在着几十种互不相同的字符集，而不同语言客户在浏览不同语言网页时，往往会因为相互间所使用字符集无法兼容而出现乱码情况。我们在浏览国外一些网站时，往往也会出现为了能正常地看到网站上的信息而不得不在各种字符集之间来回切换的情况。 试想一下：如果一个网站提供了中、英、法、德等多种语言版本的内容，内容全之又全，设计美仑美奂。我们在中文编码环境下浏览这些非中文版本的页面觉得非常完美，现在一个法国客户对你的产品发生了兴趣，当他进到法语版面一看，乱码多多，甚至可能整个版面都一塌里糊涂。你的网站再下大工夫又有什么意义呢? 所以对提供了多语言版本的网站来说，Unicode字符集应该是最理想的选择。它是一种双字节编码机制的字符集，不管是东方文字还是西方文字，在Unicode中一律用两个字节来表示，因而至少可以定义65536个不同的字符，几乎可以涵盖世界上目前所有通用的语言的每一种字符。所以在设计和开发多语言网站时，一定要注意先把非中文页面的字符集定义为“utf-8”格式，即： √: ×: 这一步非常重要，原因在于若等页面做好之后再更改字符集设置，可说是一件非常非常吃力不讨好的工作，有时候甚至可能需要从头再来，重新输入网站的文字内容。 2、语言书写习惯&amp;导航结构 有些国家的语言书写习惯是从右到左，例如许多中东地区所使用的阿拉伯语，波斯语和希伯来语等等。如果你的市场目标是这些语言的国家，那么在网站设计中就需要考虑这些特殊的语言书写习惯。而且如果你在网站导航结构设计中使用的是一个竖直导航栏，这时候就应该把它放在右边，而不是象我们习惯的那样放在左边了。 3、数据库驱动型网站 对一个数据库驱动型的网站，尤其是当客户可以留言并向数据库添加信息时，则应当考虑如何从技术上实现对不同语言数据信息的收集和检索。 data-属性的作用是什么？ data-为前端开发者提供自定义的属性，这些属性集可以通过对象的dataset属性获取，不支持该属性的浏览器可以通过 getAttribute方法获取。ppk提到过使用rel属性，lightbox库推广了rel属性，HTML5提供了data-做替代，这样可以更好 地使用自定义的属性。 sessionStorage与页面 js 数据对象的区别 页面中一般的 js 对象或数据的生存期是仅在当前页面有效，因此刷新页面或转到另一页面这样的重新加载页面的情况，数据就不存在了。 而sessionStorage 只要同源的同窗口（或tab）中，刷新页面或进入同源的不同页面，数据始终存在。也就是说只要这个浏览器窗口没有关闭，加载新页面或重新加载，数据仍然存在 Web Storage带来的好处： 减少网络流量：一旦数据保存在本地后，就可以避免再向服务器请求数据，因此减少不必要的数据请求，减少数据在浏览器和服务器间不必要地来回传递。 快速显示数据：性能好，从本地读数据比通过网络从服务器获得数据快得多，本地数据可以即时获得。再加上网页本身也可以有缓存，因此整个页面和数据都在本地的话，可以立即显示。 临时存储：很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用sessionStorage非常方便。 浏览器本地存储与服务器端存储之间的区别 其实数据既可以在浏览器本地存储，也可以在服务器端存储。 浏览器端可以保存一些数据，需要的时候直接从本地获取，sessionStorage、localStorage和cookie都由浏览器存储在本地的数据。 服务器端也可以保存所有用户的所有数据，但需要的时候浏览器要向服务器请求数据。 1.服务器端可以保存用户的持久数据，如数据库和云存储将用户的大量数据保存在服务器端。 2.服务器端也可以保存用户的临时会话数据。服务器端的session机制，如jsp的 session 对象，数据保存在服务器上。实现上，服务器和浏览器之间仅需传递session id即可，服务器根据session id找到对应用户的session对象。会话数据仅在一段时间内有效，这个时间就是server端设置的session有效期。 服务器端保存所有的用户的数据，所以服务器端的开销较大，而浏览器端保存则把不同用户需要的数据分布保存在用户各自的浏览器中。 浏览器端一般只用来存储小数据，而服务器可以存储大数据或小数据。 服务器存储数据安全一些，浏览器只适合存储一般数据。 常见兼容性问题？1234567891011121314151617181920212223242526272829303132333435363738* png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.* 浏览器默认的margin和padding不同。解决方案是加一个全局的*&#123;margin:0;padding:0;&#125;来统一。 * IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 浮动ie产生的双倍距离 #box&#123; float:left; width:10px; margin:0 0 0 100px;&#125; 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别) 渐进识别的方式，从总体中逐渐排除局部。 首先，巧妙的使用“\\9”这一标记，将IE游览器从所有情况中分离出来。 接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。 css .bb&#123; background-color:#f1ee18;/*所有识别*/ .background-color:#00deff\\9; /*IE6、7、8识别*/ +background-color:#a200ff;/*IE6、7识别*/ _background-color:#1e0bd1;/*IE6识别*/ &#125; * IE下,可以使用获取常规属性的方法来获取自定义属性, 也可以使用getAttribute()获取自定义属性; Firefox下,只能使用getAttribute()获取自定义属性. 解决方法:统一通过getAttribute()获取自定义属性. * IE下,even对象有x,y属性,但是没有pageX,pageY属性; Firefox下,event对象有pageX,pageY属性,但是没有x,y属性. * 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。* Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:L-V-H-A : a:link &#123;&#125; a:visited &#123;&#125; a:hover &#123;&#125; a:active &#123;&#125; iframe有那些缺点？12345*iframe会阻塞主页面的Onload事件；*iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以可以绕开以上两个问题。 请描述一下 cookies，sessionStorage 和 localStorage 的区别？1234cookie在浏览器和服务器间来回传递。 sessionStorage和localStorage不会sessionStorage和localStorage的存储空间更大；sessionStorage和localStorage有更多丰富易用的接口；sessionStorage和localStorage各自独立的存储空间； webSocket如何兼容低浏览器？(阿里)​ 1Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR 解释下浮动和它的工作原理。 浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。link 列举不同的清除浮动的技巧，并指出它们各自适用的使用场景。 1.使用空标签清除浮动。 这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。 2.使用overflow。 给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。 3.使用after伪对象清除浮动。 该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；二、content属性是必须的，但其值可以为空，蓝色理想讨论该方法的时候content属性的值 设为”.”，但我发现为空亦是可以的。 你最喜欢的图片替换方法是什么，你如何选择使用。 1&lt;h2&gt; &lt;span 图片丢这里&gt;&lt;/span&gt;Hello World &lt;/h2&gt; * 把span背景设成文字内容，这样又可以保证seo，也有图片的效果在上面。 * 一般都是：alt，title，onerror 讨论CSS hacks，条件引用或者其他。 在这个浏览器百花争鸣的时代，作为前端开发的我们为了我们漂亮的设计能适应各个浏览器可为煞费苦心，主要体现在javascript和css上面。javascript我这次就不谈了，先说说css。 为了适应不同浏览器不同的版本（版本主要就ie来说），ie这朵奇葩现在我们要兼容6-9，它的10也快出来了。。。在ie下我们可以写条件注释来区分ie和其他浏览器，以及ie的版本，这些请大家自行google。这篇文章主要讨论的是css hack。 在书写高效 CSS 时会有哪些问题需要考虑？ 样式是：从右向左的解析一个选择器 ID最快，Universal最慢 有四种类型的key selector，解析速度由快到慢依次是：ID、class、tag和universal 不要tag-qualify （永远不要这样做 ul#main-navigation { } ID已经是唯一的，不需要Tag来标识，这样做会让选择器变慢。） 后代选择器最糟糕（换句话说，下面这个选择器是很低效的： html body ul li a { }） 想清楚你为什么这样写 CSS3的效率问题（CSS3选择器（比如 :nth-child）能够漂亮的定位我们想要的元素，又能保证我们的CSS整洁易读。但是这些神奇的选择器会浪费很多的浏览器资源。） 我们知道#ID速度是最快的，那么我们都用ID，是不是很快。但是我们不应该为了效率而牺牲可读性和可维护性 CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？1234567891011121314151617* 1.id选择器（ # myid） 2.类选择器（.myclassname） 3.标签选择器（div, h1, p） 4.相邻选择器（h1 + p） 5.子选择器（ul &lt; li） 6.后代选择器（li a） 7.通配符选择器（ * ） 8.属性选择器（a[rel = &quot;external&quot;]） 9.伪类选择器（a: hover, li: nth - child） * 可继承的样式： font-size font-family color, UL LI DL DD DT;* 不可继承的样式：border padding margin width height ; * 优先级就近原则，同权重情况下样式定义最近者为准;* 载入样式以最后载入的定位为准; 优先级为:​​ !important &gt; id &gt; class &gt; tag​1important 比 内联优先级高 CSS3新增伪类举例： 1234567p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。:enabled :disabled 控制表单控件的禁用状态。:checked 单选框或复选框被选中。 如何居中div？如何居中一个浮动元素？ * 给div设置一个宽度，然后添加margin:0 auto属性 div{ width:200px; margin:0 auto; } ​​ * 居中一个浮动元素​​ 确定容器的宽高 宽500 高 300 的层​ 设置层的外边距​​ .div {​ Width:500px ; height:300px;//高度可以不设​ Margin: -150px 0 0 -250px;​ position:relative;相对定位​ background-color:pink;//方便看效果​ left:50%;​ top:50%;​ } 列出display的值，说明他们的作用。position的值， relative和absolute定位原点是？12345678910111213141516171819201. block 象块类型元素一样显示。none 缺省值。象行内元素类型一样显示。inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。list-item 象块类型元素一样显示，并添加样式列表标记。2. *absolute 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。 *fixed （老IE不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。 *relative 生成相对定位的元素，相对于其正常位置进行定位。 * static 默认值。没有定位，元素出现在正常的流中*（忽略 top, bottom, left, right z-index 声明）。 * inherit 规定从父元素继承 position 属性的值。 CSS3有哪些新特性？1234CSS3实现圆角（border-radius:8px），阴影（box-shadow:10px），对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜增加了更多的CSS选择器 多背景 rgba javascript的proto（注意前后都是两条下划线）和prototype都可以访问对象的原型对象，那么他们之间有什么不同吗？ proto是只能用 对象. 来访问，而prototype则只能是 类. 来访问 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 利用原型模式实现简单继承 */ function per()&#123; this.getName = function(str)&#123; alert(str); &#125; &#125; per.prototype.getAge = function(age)&#123; alert(age); &#125; var a = &#123;&#125;; a.__proto__ = per.prototype; //a.getAge(2); // a.getName(&quot;a&quot;); /** * 简单方式实现继承 */ var b = &#123;&#125;; b.__proto__ = new per(); b.__proto__.constructor = b; b.getAge(&quot;1&quot;); b.getName(&quot;a&quot;); /** * 串联继承 */ function A()&#123; this.getA = &quot;a&quot;; &#125; function B()&#123; this.getB = &quot;b&quot;; &#125; function K()&#123;&#125; B.prototype = new A(); B.prototype.constructor = B; K.prototype = new B(); K.prototype.constructor = K; var test = new K(); alert(test.getA); alert(test.getB); 解释下事件代理。 JavaScript事件代理则是一种简单的技巧，通过它你可以把事件处理器添加到一个父级元素上，这样就避免了把事件处理器添加到多个子级元素上。 当我们需要对很多元素添加事件的时候，可以通过将事件添加到它们的父节点而将事件委托给父节点来触发处理函数。这主要得益于浏览器的事件冒泡机制。 事件代理用到了两个在JavaSciprt事件中常被忽略的特性：事件冒泡以及目标元素。 1234function getEventTarget(e) &#123;e = e || window.event;return e.target || e.srcElement;&#125; * 事件代理，比如，我要点一个table中的td时编辑，那么我们会在td上绑定事件呢还是table上，如果在td上绑定，会产生非常多的事件，对内存来说是个不小的考验，所以我们选择在table中绑定。因为js中有些事件是冒泡的，比如onclick。 解释下 JavaScript 中 this 是如何工作的。 this永远指向函数运行时所在的对象， 而不是函数被创建时所在的对象。匿名函数和不处于任何对象中的函数指向window。 call,apply,with指的this是谁就是谁。 普通的函数调用，函数调用被谁调用，this指的就是谁。 解释下原型继承的原理。 当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止。(大多数JavaScript的实现用 proto 属性来表示一个对象的原型链。) 注：proto 是一个不应在你代码中出现的非正规的用法，这里仅仅用它来解释JavaScript原型继承的工作原理。 AMD vs. CommonJS？ AMD是依赖提前加载,CMD是依赖延时加载 什么是哈希表？ 哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。说白了哈希表的原理其实就是通过空间换取时间的做法。。 哈希表的做法其实很简单，就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。 而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位。。 描述以下变量的区别：null，undefined 或 undeclared？ 该如何检测它们？ undefined :js语言类型，有申明，没有初始化。 undeclared：js语法错误，没有申明直接使用，js无法找到对应的上下文。 null：是空值。 用typeof判断undefined，==，！=null判断Null.. 什么是闭包，如何使用它，为什么要使用它？ 闭包就是能够读取其他函数内部变量的函数。 闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 函数数再定义一个函数，用于返回里面的值， 你喜欢的使用闭包的模式是什么？ 两种模式用在不同场合。参见jQuery源码，立即调用模式，把$的jQuery源码放在了全局作用域下。返回函数类型的，制作一个随时可以使用的函数。 闭包与设计模式 单例模式，例如要做一个荫罩层，这个时候我们需要一个全局变量来判断页面是否已经存在这样一个东西，如果就用一个var a 定义，那么就会污染全局命名空间。最好的作法，就是把这样一个变旦放在一个函数里面，然后通过函数内的函数去判断调用写它的逻辑。 闭包会带来什么问题？怎么避免？ 使用闭包的注意点 1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 你能解释一下 JavaScript 中的继承是如何工作的吗？ 原型继承 创建了一个实例。这个实例是一个具有proto属性的空对象，并且proto指向F.prototype 初始化实例。将arguments 和 this赋予函数F。 返回这个实例。 在什么时候你会使用 document.write()？ 大多数生成的广告代码依旧使用 document.write()，虽然这种用法会让人很不爽。 请尽可能详尽的解释 AJAX 的工作原理。 非ajax是把要提交的内容放在submit里面，浏览器刷新提交数据。ajax即异步数据刷新，将要提交的数据与服务器接口交换数据，将得到的数据返回用于重组dom元素，以及改变一些页面效果。 动态添加script标签，script是不存在跨域问题的，所以可以跨域以get方式访问异域的数据。要跨域以post方式，需要使用iframe标签。ajax是使用XMLHttpRequest来和服务器进行异步通信，所以原理完全不同。 请解释 JSONP 的工作原理，以及它为什么不是真正的 AJAX。 JSON是一种数据交换格式，而JSONP是一种依靠开发人员的聪明才智创造出的一种非官方跨域数据交互协议。我们拿最近比较火的谍战片来打个比方，JSON是地下党们用来书写和交换情报的“暗号”，而JSONP则是把用暗号书写的情报传递给自己同志时使用的接头方式。看到没？一个是描述信息的格式，一个是信息传递双方约定的方法。 你使用过 JavaScript 模板系统吗？ 如有使用过，请谈谈你都使用过哪些库，比如 Mustache.js，Handlebars 等等。 大量的正则表达式用于替换掉html中代表数据的内容。生成静态的html页面 请解释变量声明提升。 在中间声明的函数，会提升到最先去声明，但是赋值位置不会提升。 请描述下事件冒泡机制。 点击document中的div ，也会触发到document的click事件，这就是冒泡啦，！如果要停止冒泡，ie下e.returnValue = false。ff下,stop啥的。 Node.js的适用场景？1高并发、聊天、实时消息推送 介绍js的基本数据类型。1number,string,boolean,object,undefined Javascript如何实现继承？1通过原型和构造器 [“1”, “2”, “3”].map(parseInt) 答案是多少？1[1, NaN, NaN] 因为 parseInt 需要两个参数 (val, radix) 但 map 传了 3 个 (element, index, array) 如何创建一个对象? （画出此对象的内存图）12345function Person(name, age) &#123; this.name = name; this.age = age; this.sing = function() &#123; alert(this.name) &#125; &#125; 谈谈This对象的理解。12345this是js的一个关键字，随着函数使用场合不同，this的值会发生变化。但是有一个总原则，那就是this指的是调用函数的那个对象。this一般情况下：是全局对象Global。 作为方法调用，那么this就是指这个对象 事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？1231. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。 2. 事件处理机制：IE是事件冒泡、火狐是 事件捕获；3. ev.stopPropagation(); .call() 和 .apply() 的区别？123456789101112131415例子中用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4); 注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。 function add(a,b) &#123; alert(a+b); &#125; function sub(a,b) &#123; alert(a-b); &#125; add.call(sub,3,1); JQuery的源码看过吗？能不能简单说一下它的实现原理？ 在 jQuery 中， jQuery 对象实际上是一个仿数组的对象，代表通过选择器得到的所有 DOM 对象的集合，它像数组一样有 length 属性，表示代表的 DOM 对象的个数，还可以通过下标进行遍历。 95 行的 jQuery.each 是 jQuery 中用来遍历这个仿数组，对其中的每个元素进行遍历处理的基本方法，callback 表示处理这个 DOM 对象的函数。通常情况下，我们并不使用这个方法，而是使用 jQuery 对象的 each 方法进行遍历。jQuery 对象的 css 和 text 方法在内部实际上使用 jQuery 对象的 each 方法对所选择的元素进行处理。 jquery 中如何将数组转化为json字符串，然后再转化回来？ 知乎 jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展： $.fn.stringifyArray = function(array) { ​ return JSON.stringify(array) } $.fn.parseArray = function(array) { ​ return JSON.parse(array) } 然后调用： $(“”).stringifyArray(array) 针对 jQuery 的优化方法？*基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。 *频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好。 比如：var str=$(&quot;a&quot;).attr(&quot;href&quot;); *for (var i = size; i &lt; arr.length; i++) {} for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快： for (var i = size, length = arr.length; i &lt; length; i++) {} 那些操作会造成内存泄漏？​​ 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。​ 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） JQuery一个对象可以同时绑定多个事件，这是如何实现的？ 1、jQuery(“#id”).click(func1).mouseover(func2)//方法连写，func为方法的名字 2、jQuery(“#id”).click(function(){//你的具体方法实现}),mouser(function(){//你的具体方法实现}); 3、jQuery(“#id”).bind(“click mouseover”,func)//两个事件中间有空格 ，func为方法的名字 4、jQuery(“#id”).bind(“load scroll”,function(){//你的具体方法实现}); 如何判断当前脚本运行在浏览器还是node环境中？（阿里） ​ 通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中 对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？ 前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。 1、实现界面交互 2、提升用户体验 3、有了Node.js，前端可以实现服务端的一些事情 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好， 参与项目，快速高质量完成实现效果图，精确到1px； 与团队成员，UI设计，产品经理的沟通； 做好的页面结构，页面重构和用户体验； 处理hack，兼容、写出优美的代码格式； 针对服务器的优化、拥抱最新前端技术。 平时如何管理你的项目？先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等； 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）； 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）； 页面进行标注（例如 页面 模块 开始和结束）； CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）； JS 分文件夹存放 命名以该JS功能为准的英文翻译。 图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理 如何设计突发大规模并发架构？ 移动端（Android IOS）怎么做好用户体验? 清晰的视觉纵线、信息的分组、极致的减法、 利用选择代替输入、标签及文字的排布方式、 依靠明文确认密码、合理的键盘利用、 备注： 12根据自己需求选择性阅读，前端的路上我们一起携手共进！个人收藏有不少关于前端开发的书籍以及资料，如有需要，请通过邮箱索要！ 出一套适应不同分辨率，不同终端的前端实现方案你有什么思路? 流式布局: 使用非固定像素来定义网页内容，也就是百分比布局，通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。这样的布局方式，就是移动web开发使用的常用布局方式。这样的布局可以适配移动端不同的分辨率设备。 响应式开发:CSS3 中的 Media Query(媒介查询)，通过查询 screen 的宽度来指定某个宽 度区间的网页布局。超小屏幕(移动设备) 768px以下 小屏设备 768px-992px中等屏幕 992px-1200px宽屏设备 1200px 以上 px em rem 取用选择依据? px 像素(Pixel)。绝对单位。像素 px 是相对于显示器屏幕分辨率而言的，是一个虚拟长度单位，是计算机系统的数字化图像长度单位，如果 px 要换算成物理长度，需要指定精度DPI。 em 是相对长度单位，相对于当前对象内文本的字体尺寸。如当前对行内文本的字 体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。它会继承父级元素的字体大小，因此并不是一个固定的值。 rem 是 CSS3 新增的一个相对单位(root em，根 em)，使用 rem 为元素设定字 体大小时，仍然是相对大小，但相对的只是 HTML 根元素。 区别:IE 无法调整那些使用 px 作为单位的字体大小，而 em 和 rem 可以缩放，rem 相对的只是 HTML 根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既 可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁 反应。目前，除了 IE8 及更早版本外，所有浏览器均已支持 rem。 src 与 href 的区别src(source)指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置;在 请求 src 资源时会将其指向的资源下载并应用到文档中，如js脚本，img图片和iframe等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行 完毕，类似于将所指向资源嵌入当前标签内。href(hypertext reference/超文本引用)指向网络资源所在位置，建立和当前元素(锚点) 或当前文档(链接)之间的链接，如果我们在文档中添加那么浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止 对当前文档的处理。 说说你对 this 的理解?this 是一个关键字，它代表函数运行时，自动生成的一个内部对象，只能在函数内 部使用。 作为纯粹的函数调用 this 指向全局对象 作为对象的方法调用 this 指向调用对象 作为构造函数被调用 this 指向新的对象(new 会改变 this 的指向) apply 调用 this 指向 apply 方法的第一个参数 介绍一下 JS 有哪些内置对象Object 是 JavaScript 中所有对象的父对象数据封装类对象:Object、Array、Boolean、Number、String其他对象:Function、Argument、Math、Date、RegExp、Error 表单验证传输的什么数据?明文还是暗文==加密?如何加密?是每一次传 输数据，都是加密之后才传输吗?GET 是从服务器上请求数据，POST 是发送数据到服务器。事实上，GET方法是把数 据参数队列(query string)加到一个 URL 上，值和表单是一一对应的。 比如说， name=John。在队列里，值和表单用一个&amp;符号分开，空格用+号替换，特殊的符号转换 成十六进制的代码。因为这一队列在 URL 里边，这样队列的参数就能看得到，可以被记录 下来，或更改。通常 GET 方法还限制字符的大小(大概是 256 字节 )。 事实上 POST 方法可以没有时间限制的传递数据到服务器，用户在浏览器端是看不到 这一过程的，所以 POST 方法比较适合用于发送一个保密的(比如信用 卡号)或者比较大 量的数据到服务器。 区别Post 是允许传输大量数据的方法，而 Get 方法会将所要传输的数据附在网址后面，然 后一起送达服务器，因此传送的数据量就会受到限制，但是执行效率却比 Post 方法好。总结:1、get 方式的安全性较 Post 方式要差些，包含机密信息的话，建议用 Post 数据提交 方式;2、在做数据查询时，建议用 Get 方式;而在做数据添加、修改或删除时，建议用 Post 方式;所以表达如果是向服务器传输数据(如帐号密码等)都是加密数据(post)， 如果只是单单想要 从服务器获得数据或者传输的数据并不重要， 可以直接使用明文方式传输( get ) 闭包?简单的说，作用域是针对变量的，比如我们创建一个函数 a1，函数里面又包了一 个子函数 a2。此时就存在三个作用域:全局作用域、a1 作用域、a2 作用域;即全局作用域包含了 a1 的作用域，a2 的作用 域包含了 a1 的作用域。当 a1 在查找变量的时候会先从自身的作用域区查找，找不到再到上一级 a2 的作用域 查找，如果还没找到就到全局作用域区查找，这样就形成了一个作用域链。理解闭包首先要理解，js 垃圾回收机制，也就是当一个函数被执行完后，其作用域会被 收回，如果形成了闭包，执行完后其作用域就不会被收回。如果某个函数被他的父函数之外的一个变量引用，就会形成闭包。闭包的作用，就是保存自己私有的变量，通过提供的接口(方法)给外部使用，但外部 不能直接访问该变量。​ 请说说事件委托机制?这样做有什么好处?事件委托，就是某个事件本来该自己干的，但是自己不干，交给别人来干。就叫事件委 托。打个比方:一个 button 对象，本来自己需要监控自身的点击事件，但是自己不来监控 这个点击事件，让自己的父节点来监控自己的点击事件。好处:A，提高性能:列如，当有很多 li 同时需要注册事件的时候，如果使用传统方法来注册 事件的话，需要给每一个 li 注册事件。然而如果使用委托事件的话，就只需要将事件委托给 该一个元素即可。这样就能提高性能。B，新添加的元素还会有之前的事件; 在 JS 的计时器运行原理是怎样的，为什么可以触发计时效果? 计时器是多 线程吗? javascript 引擎只有一个线程，强迫异步事件排队等待被执行。 setTimeout 和 setInterval 本质上不同的地方是他们如何执行异步代码的。 如果一个定时器正在执行的时候被阻塞了，那么它将会被推迟到下一个可能的执 行点，这既是使得延迟时间有可能会超过声明定时器时设置的值。 Interval 如果有足够的时间来执行(大于制定的延迟)，那么它将会无延迟的一个紧接着一个执行。 原理:计时器通过设定一定的时间段(毫秒)来异步的执行一段代码。因为 Javascript 是一 个单线程语言，计时器提供了一种绕过这种语言限制来执行代码的能力。总结:计时器是单线程的， 需要等待上一个执行完， 如果上一个没有执行完， 下一个需要 延迟执行， 直到上一个执行完。 一个页面上有大量的图片(大型电商网站)，加载很慢，你有哪些方法优化 这些图片的加载，给用户更好的体验。图片懒加载在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端 的距离与页面的距离，如果前者小于后者，优先加载。如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先 下载。如果图片为 css 图片，可以使用 CSSsprite，SVGsprite，Iconfont、Base64 等技术。如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图， 以提高用户体验。如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩， 图片压缩后大小与展示一致。 Vue.js 核心思想:1、数据驱动(基于操作 dom 的方式)(1)、Dom 是数据的一种自然映射(双向数据绑定)手动改变 DOM 非常麻烦使用 vue.js 之后，只需要改变数据，通过改变 Directives 指令,当数据发生变化，会通过数据指令去修 改对应的 DOM。 (2)、Vue.js 还会对事件进行一定的监听，当我们改变视图(view)的时候通过 DOM Listeners 来改变数据。 2、组件化Vue-cli:(它是 vue 的脚手架工具) 作用:帮助我们完成基础的代码(包括:目录结构、本地调试、代码部署、热加载、单元测 试) 组件的设计原则:页面上每一个独立的可视/可交互区域视为一个组件 每个组件对应一个工程目录，组件所需要的各种资源在这个目录下就近维护 展示面不过是组件的容器，组件可以嵌套自由组合形成完整的页面。 angularJS angularJS 的适用场景AngularJS 是为了克服 HTML 在构建应用上的不足而设计的。HTML 是一门很好的为静态 文本展示设计的声明式语言，但要构建 WEB 应用的话它就显得乏力了，所以说 angular 适 合做单页面应用程序 angularJS 是什么AngularJS 是一个 JavaScript 框架。它可通过 标签添加到 HTML 页面。 AngularJS 通过 指令 扩展了 HTML，且通过 表达式 绑定数据到 HTML angularJS 中的 MVVM 模式AngularJS 是一个 JavaScript 框架。它可通过 标签添加到 HTML 页面。 AngularJS 通过 指令 扩展了 HTML，且通过 表达式 绑定数据到 HTML采用这种方式为合理组织代码提供了方便，降低了代码间的耦合度，功能结构清晰可见。 Model:一般用来处理数据，包括读取和设置数据，一般指的是操作数据库。 View:一般用来展示数据，就是放数据，比如通过 HTML 来展示。 Controller:因为一个模块里面可能有多个视图和模型，控制器就起到了连接模型和视图的 作用。VM–&gt; ViewModel(视图模型) 也就是$scope。 模块化与依赖注入 AngularJS 模块是一种容器，把代码隔离并组织成简洁，整齐，可复用的块。 模块本身不提供直接的功能:包含其他提供功能的对象的实例:控制器，过滤器，服务，动 画。可通过定义其提供的对象构建模块。通过依赖注入将模块连接在一起，构建一个完整的 应用程序。AngularJS 建立在模块原理上。大部分 AngularJS 提供的功能都内置到 ng-*模块中。 看过 Angular 的源码吗，它是怎么实现双向数据绑定的?答:angular 对常用的 dom 事件，xhr 事件等做了封装，在里面触发进入 angular 的 digest 流程。在 digest 流程里面， 会从 rootscope 开始遍历， 检查所有的 watcher。 为什么 angular 不推荐使用 dom 操作?答:Angular 倡导以测试驱动开发，在的 service 或者 controller 中出现了 DOM 操作，那 么也就意味着的测试是无法通过的使用 Angular 的其中一个好处是啥，那就是双向数据绑定，这样就能专注于处理业务逻辑， 无需关系一堆堆的 DOM 操作。如果在 Angular 的代码中还到处充斥着各种 DOM 操作， 那为什么不直接使用 jquery 去开发呢。 指令AngularJS 通过被称为 指令 的新属性来扩展 HTML。AngularJS 通过内置的指令来为应 用添加功能。AngularJS 允许你自定义指令。AngularJS 指令:AngularJS 指令是扩展的 HTML 属性，带有前缀 ng-。ng-app 指令初始化一个 AngularJS 应用程序。ng-init 指令初始化应用程序数据。ng-model 指令把元素值(比如输入域的值)绑定到应用程序。 自定义的指令:除了 AngularJS 内置的指令外，我们还可以创建自定义指令。 你可以使用 .directive 函数来添加自定义的指令。 要调用自定义指令，HTML 元素上需要添加自定义指令名。 使用驼峰法来命名一个指令， runoobDirective, 但在使用它时需要以 - 分 割, runoob-directive: ReactJSReactJS 的适用场景1、一些后台界面，或者是和后台数据比较多，又或者和用户交互比较多，dom 操作频繁的 都可以用 react。因为 react 的大特点就是虚拟 DOM 技术，这样可以提高渲染的性能。个 人的体验就是，用 react 可以让整个页面的速度提高很多。 2、另外这样做的话，和后台的数据通过接口来进行前后端分离，也挺好挺方便的。 2、ReactJS 是什么 React 是一个用于构建用户界面的 JAVASCRIPT 库。React 主要用于构建 UI，很多人认为 React 是 MVC 中的 V(视图)。React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月 开源。React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。 3、ReactJs 的特点 1.声明式设计 −React 采用声明范式，可以轻松描述应用。2.高效 −React 通过对 DOM 的模拟，最大限度地减少与 DOM 的交互。3.灵活 −React 可以与已知的库或框架很好地配合。4.JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用 它。5.组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的 开发中。6.单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它 为什么比传统数据绑定更简单。 NodeJS统一Web应用的UI层目前 MVC 的架构，在某种意义上来说，Web 开发有两个 UI 层，一个是在浏览器里面我们 最终看到的，另一个在 server 端，负责生成和拼接页面。 不讨论这种架构是好是坏，但是有另外一种实践，面向服务的架构，更好的做前后端的依赖 分离。如果所有的关键业务逻辑都封装成 REST 调用，就意味着在上层只需要考虑如何用这些 REST 接口构建具体的应用。那些后端程序员们根本不操心具体数据是如何从一个页面传 递到另一个页面的，他们也不用管用户数据更新是通过 Ajax 异步获取的还是通过刷新页面。 3. 大量 Ajax 请求的应用 例如个性化应用，每个用户看到的页面都不一样，缓存失效，需要在页面加载的时候发起 Ajax 请求，NodeJS 能响应大量的并发请求。 总而言之，NodeJS 适合运用在高并发、 I/O 密集、少量业务逻辑的场景。 NodeJS 是什么Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node.js 的包管理器 npm，是全球最大的开源库生态系统。NodeJS 的特点其特点为: 它是一个 Javascript 运行环境 依赖于 Chrome V8 引擎进行代码解释 事件驱动 非阻塞 I/O 轻量、可伸缩，适于实时数据交互应用 单进程，单线程 NodeJS 的优缺点:优点:1. 高并发(最重要的优点)2. 适合 I/O 密集型应用缺点:1. 不适合 CPU 密集型应用;CPU 密集型应用给 Node 带来的挑战主要是:由于 JavaScript 单线程的原因，如果有长时间运行的计算(比如大循环)，将会导致 CPU 时间 片不能释放，使得后续 I/O 无法发起; 只支持单核 CPU，不能充分利用 CPU 可靠性低，一旦代码某个环节崩溃，整个系统都崩溃 开源组件库质量参差不齐，更新快，向下不兼容 Debug 不方便，错误没有 stack trace原因:单进程，单线程 解决方案:(1)分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞 I/O 调 用的发起;(2)Nnigx 反向代理，负载均衡，开多个进程，绑定多个端口;(3)开多个进程监听同一个端口，使用 cluster 模块;3、NodeJS 非阻塞 I/O 模型执行流程 主线程:1.执行 node 的代码，把代码放入队列 2.事件循环程序(主线程)把队列里面的同步代码都先执行了， 3.同步代码执行完成，执行异步代码4.异步代码分 2 种状况，(1)、异步非 io setTimeout() setInterval() 判断是否可执行，如果可以执行就执行，不可以跳过。(2)、异步 io 文件操作 会从线程池当中去取一条线程，帮助主线程去执行。 node 的构架是什么样子的?答案: 主要分为三层，应用 app &gt;&gt; V8 及 node 内置架构 &gt;&gt; 操作系统. V8 是 node 运行的环境，可以理解为 node 虚拟机.node 内置架构又可分为三层: 核心模块(javascript 实现) &gt;&gt; c++绑定 &gt;&gt; libuv + CAes + http. node 有哪些核心模块?答案: EventEmitter, Stream, FS, Net 和全局对象 node 有哪些全局对象?答案: process, console, Buffer 和 exports process 有哪些常用方法?答案: process.stdin, process.stdout, process.stderr, process.on, process.env,process.argv, process.arch, process.platform, process.exit 5. console 有哪些常用方法?答案: console.log/console.info, console.error/console.warning, console.time/console.timeEnd, console.trace, console.table node 有哪些定时功能?答案: setTimeout/clearTimeout, setInterval/clearInterval, setImmediate/clearImmediate, process.nextTick 什么是 EventEmitter?参考答案: EventEmitter 是 node 中一个实现观察者模式的类，主要功能是监听和发射 消息，用于处理多模块交互问题. EventEmitter 有哪些典型应用?参考答案: 1) 模块间传递消息 2) 回调函数内外传递消息 3) 处理流数据，因为流是在 EventEmitter 基础上实现的. 4) 观察者模式发射触发机制相关应用 怎么捕获 EventEmitter 的错误事件?参考答案: 监听 error 事件即可.如果有多个 EventEmitter,也可以用 domain 来统一 处理错误事件.5、nodejs 中流(stream)的理解 什么是 Stream?答案: stream 是基于事件 EventEmitter 的数据管理模式.由各种不同的抽象接口组成， 主要包括可写，可读，可读写，可转换等几种类型. Stream 有什么好处?答案: 非阻塞式数据处理提升效率，片断处理节省内存，管道处理方便可扩展等. Stream 有哪些典型应用?答案: 文件，网络，数据转换，音频视频等. 怎么捕获 Stream 的错误事件?答案: 监听 error 事件，方法同 EventEmitter. 有哪些常用 Stream,分别什么时候使用?答案: Readable 为可被读流，在作为输入数据源时使用;Writable 为可被写流,在作为输出源时使用;Duplex 为可读写流,它作为输出源接受被写入，同时又作为输入源被后面的 流读出.Transform 机制和 Duplex 一样，都是双向流，区别时 Transfrom 只需要实现一 个函数_transfrom(chunk, encoding, callback);而 Duplex 需要分别实现_read(size)函数 和_write(chunk, encoding, callback)函数. 实现一个 Writable Stream?答案: 三步走: 1)构造函数 call Writable 、2) 继承 Writable 、3) 实现_write(chunk, encoding, callback)函数NodeJs 面试题大全详见:http://www.cnblogs.com/meteorcn/p/node_mianshiti_interview_question.html 对于这些缺点，如果能把 HTML 5 的优点用到 Web 上的话就会得到很大改善，尽管技术在 提高，目前它还不能做原生应用可以做的每件事。 有些公司，比如金融时报继原生应用后也开发了 Web 应用，用户通过浏览器来访问他们的 应用，因为他们的应用要采取应用内购买，而 App Store 是不允许应用内购买的，不然它 们就无法拿到那 20%-30% 的抽成了。 什么是混合 app?Hybrid App 是指介于 web-app、native-app 这两者之间的 app,它虽然看上去是一个 Native App，但只有一个 UI WebView，里面访问的是一个 Web App，比如街旁网最开 始的应用就是包了个客户端的壳，其实里面是 HTML5 的网页，后来才推出真正的原生应用。 再彻底一点的，如掌上百度和淘宝客户端 Android 版，走的也是 Hybrid App 的路线，不 过掌上百度里面封装的不是 WebView，而是自己的浏览内核，所以体验上更像客户端，更 高效。Hybrid App(混合模式移动应用)兼具“Native App 良好用户交互体验的优势”和“Web App 跨平台开发的优势”。很多人不知道市场上一些主流移动应用都是基于 Hybrid App 的方式开发，比如国外有 Facebook、国内有百度搜索等。综合一下就是:“Hybrid App 同时使用网页语言与程序语言开发，通过应用商店区分 移动操作系统分发，用户需要安装使用的移动应用”。总体特性更接近 Native App 但是和 Web App 区别较大。只是因为同时使用了网页语言编码，所以开发成本和难度比 Native App 要小很多。因此说，Hybrid App 兼具了 Native App 的所有优势，也兼具了 Web App 使用 HTML5 跨平台开发低成本的优势 混合应用大家都知道是原生应用和 Web 应用的结合体，采用了原生应用的一部分、Web 应用的一部分，所以必须，部分在设备上运行、部分在 Web 上运行。 不过混合应用中比例很自由，比如 Web 占 90%，原生占 10%;或者各占 50%。 优点:兼容多平台;顺利访问手机的多种功能;App Store 中可下载(Web 应用套用原生应用的外壳); 可线下使用。缺点:不确定上线时间;用户体验不如本地应用;性能稍慢(需要连接网络);技术还不是很成熟。比如 Facebook 现在的应用属于混合应用它可以在许多 App Store 畅通无阻，但是掺杂了 大量 Web 特性，所以它运行速度比较慢，而现在为了提高性能 FB 又决定采用原生应用。 1以下是列举的一些重点差异: ● 开发难度。移动 web 和混合 App 开发难度对于 web 开发者来说相对较低，而且可以充 分利用现有的 web 开发工具和工作流程● 发布渠道和更新方式。混合 App 可以在应用商店 App Store 发布，但可以自主更新，而 原生 App 的更新必须通过应用商店 App Store。● 移动设备本地 API 访问。混合 App 可以通过 JavaScript API 访问到移动设备的摄像头、 GPS;而原生 App 可以通过原生编程语言访问设备所有功能。● 跨平台和可移植性。基于浏览器的移动 web 最好的可移植性和跨平台表现;混合 App 也能节省跨平台的时间和成本，只需编写一次核心代码就可部署到多个平台，而原生 App 的跨平台性能最差。● 搜索引擎友好。只有移动 web 对搜索引擎友好，可与在线营销无缝整合。● 货币化。混合 App 除广告外，还支持付费下载及程序内购买;原生 App 的程序内购买 金额 2012 年首次超过下载收费。北京市顺义区京顺路 99 号·黑马程序员 www.itheima.com 第 118 页 共 125 页​● 消息推送。只有混合 App 和原生 App 支持消息推送，这能增加用户忠诚度。 结论总结:选择合适的应用需要考虑些什么，比如:1、是否需要使用某些设备的特殊功能 如:摄像头、摄像头闪光灯或者重力加速器 2、你的开发预算 3、你的应用是否一定需要网 络 3 你的应用的目标硬件设备是所有的移动设备还是仅仅只是一部分而已 4、你自己已经熟 悉的开发语言 5、这个应用对于性能要求是否苛刻 2、ionic 流行开发框架(混合 APP)Ionic 介绍:1、ionic 是一个用来开发混合手机应用的，开源的，免费的代码库。可以优化 html、css 和 js 的性能，构建高效的应用程序，而且还可以用于构建 Sass 和 AngularJS 的优化。ionic 会是一个可以信赖的框架。2、ionic 是一个专注于用 WEB 开发技术，基于 HTML5 创建类似于手机平台原生应用的一 个开发框架。绑定了 AngularJS 和 Sass。这个框架的目的是从 web 的角度开发手机应用， 基于 PhoneGap 的编译平台，可以实现编译成各个平台的应用程序。ionic 的开发添加 android 和 ios 环境。ionic 提供很多 css 组件 和 javascript UI 库。ionic 可以支持定制 android 和 ios 的插件，也支持服务端 REST 的敏捷开发。ionic 特点:1.ionic 基于 Angular 语法，简单易学。2.ionic 是一个轻量级框架。3.ionic 完美的融合下一代移动框架，支持 Angularjs 的特性， MVVM ，代码易维护。4.ionic 提供了漂亮的设计，通过 SASS 构建应用程序，它提供了很多 UI 组件来帮助开 发者开发强大的应用。5.ionic 专注原生，让你看不出混合应用和原生的区别6.ionic 提供了强大的命令行工具。7.ionic 性能优越，运行速度快。Ionic 中文教程连接:http://www.runoob.com/ionic/ionic-tutorial.html2.1.8、前端工具介绍或使用方法1、前端工程化工具发展历程:grunt –&gt;gulp –&gt;webpackgulp 较之 grunt 的优势:1、易用， Gulp 相比 Grunt 更简洁，而且遵循代码优于配置策略，维护 Gulp 更像是写代 码。2、高效， Gulp 相比 Grunt 更有设计感，核心设计基于 Unix 流的概念，通过管道连接， 不需要写中间文件。3、高质量 ，Gulp 的每个插件只完成一个功能，这也是 Unix 的设计原则之一，各个功能 通过流进行整合并完成复杂的任务。例如:Grunt 的 imagemin 插件不仅压缩图片，同时 还包括缓存功能。他表示，在 Gulp 中，缓存是另一个插件，可以被别的插件使用，这样 就促进了插件的可重用性。目前官方列出的有 673 个插件。4、易学 ，Gulp 的核心 API 只有 5 个，掌握了 5 个 API 就学会了 Gulp，之后便可以通过 管道流组合自己想要的任务。 2、Webpack1、什么是 WebpackWebPack 可以看做是模块打包机:它做的事情是，分析你的项目结构，找到 JavaScript 模块以及其它的一些浏览器不能直接运行的拓展语言(Scss，TypeScript 等)，并将其打 包为合适的格式以供浏览器使用。2、为什要使用 WebPack 今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的 JavaScript 代码和一大 堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法 a:模块化，让我们可以把复杂的程序细化为小的文件;b:类似于 TypeScript 这种在 JavaScript 基础上拓展的开发语言:使我们能够实现目前版 本的 JavaScript 不能直接使用的特性，并且之后还能能装换为 JavaScript 文件使浏览器可 以识别;c:scss，less 等 CSS 预处理器………这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外 的处理才能让浏览器识别,而手动处理又是非常反锁的，这就为 WebPack 类的工具的出现 提供了需求。3、WebPack 和 Grunt 以及 Gulp 相比有什么特性其实 Webpack 和另外两个并没有太多的可比性，Gulp/Grunt 是一种能够优化前端 的开发流程的工具，而 WebPack 是一种模块化的解决方案，不过 Webpack 的优点使得 Webpack 可以替代 Gulp/Grunt 类的工具。Grunt 和 Gulp 的工作方式是:在一个配置文件中，指明对某些文件进行类似编译， 组合，压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务。Webpack 的工作方式是:把你的项目当做一个整体，通过一个给定的主文件(如: index.js)，Webpack 将从这个文件开始找到你的项目的所有依赖文件，使用 loaders 处 理它们，最后打包为一个浏览器可识别的 JavaScript 文件。优点:模块化在 webpack 看来一切都是模块!这就是它不可不说的优点，包括你的 JavaScript 代码， 也包括 CSS 和 fonts 以及图片等等，只要通过合适的 loaders，它们都可以被当做模块被 处理。 3、svn 和 git 的区别1、GIT 是分布式的，SVN 是集中式的2、git 是每个历史版本都存储完整的文件,便于恢复,svn 是存储差异文件,历史版本不可恢 复。(核心)3、git 可离线完成大部分操作,svn 则不能。4、git 有着更优雅的分支和合并实现。5、git 有着更强的撤销修改和修改历史版本的能力6、Git 下载下来后，在本地不必联网就可以看到所有的 log，很方便学习，SVN 却需要联 网;git 速度更快,效率更高。7、Git 没有一个全局的版本号，而 SVN 有。 4、Git/GitHubGit 是一个开源的分布式版本控制系统，用以有效、高速的处理各种规模的项目版本 管理， 它是 Linux Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版 本控制软件，后来得到广泛的使用。GitHub 是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的 版本库格式进行托管，故名 GitHub。除了 Git 代码仓库托管及基本的 Web 管理界面以 外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱(报表)、代码片段 分享(Gist)等功能。目前，其注册用户已经超过 350 万，托管版本数量也是非常之多， 其中不乏知名开源项目 Ruby on Rails、jQuery、python 等。2.2、如何表述项目2.2.1、项目描述方式1、项目功能模块分析项目功能模块分析结合自己的知识技术水平以及面试公司会用到的相关技术点阐述我们 的项目，吸引面试官，让他感觉你跟他们公司的气质很适合。2、项目如何开展分配从项目的需求分析、原型定制、人员分配、技术定性、技术讨论、注意事项等展开我 们开发这个项目的一个流程分析，可以加上开发过程中遇到的问题，怎么解决的，或者加上 自己的见解等。2.2.2、项目口述、面述话术模板1、基于项目功能模块分析1、介绍项目主要是干嘛的，例如:数据交易平台系统主要是主要是进行数据的交易、买卖， 从而为客户提供更好的数据交易服务。主要包括首页、个人中心、商品列表、订单支付、商 品详情、需求定制、数据合作等模块。2、介绍自己负责的部分和使用的技术，例如:在这个项目中我负责的主要是个人中心这个 模块的开发，包括静态页面和数据交互。开发过程中主要用到的技术有 H5+css3、ajax、 插件(分页、弹框、模块化开发)。 3、然后结合自己的项目介绍，说什么技术实现了什么功能(如果产品上线可以给面试官看) 4、此时你基本上介绍完毕，面试官如果对你介绍的感兴趣，他会问你的，如果他没有问， 你可以问下该公司主要业务是什么，用什么技术开发，寻找共同点，展开话题 2、从项目如何开展分配分析 1、首先介绍项目主要是干嘛的，例如:数据交易平台系统主要是进行数据的交易、买卖， 从而为客户提供更好的数据交易服务。主要包括首页、个人中心、商品列表、订单支付、商 品详情、需求定制、数据合作等模块。 2、该项目结合用户提出的需求进行制定，技术人员讨论技术点的实现，结合考虑多方面的 内容，定制产品模型。3、产品模型出来之后，ui 设计师，设计出来 psd 图，同时前端人员可以做些准备工作(比 如定版心，定框架、浏览器兼容版本等) 4、前端人员任务分配:可以先自行选择，然后项目经理进行 2 次分配。 5、确定时间节点，开发周期等比如:静态页面完成时间、与后台交互时间、测试时间等。 6、可以说一下在开发过程中遇到的一些问题，比如双边距问题，输入框默认值问题，讲一 下怎么解决的，总结自己的感想。 7、介绍基本完成后可以适当与面试官进行交流，问下该公司主要业务是什么，用什么技术 开发，寻找共同点，展开下一步的话题，可以占据主动性。 备注： 1前端的路上我们一起携手共进！如果转载，请标注本链接地址。 ​MIT ©杨方涛 Email:58267980@qq.com","categories":[{"name":"面试技巧","slug":"面试技巧","permalink":"https://lzws0931.cn/categories/面试技巧/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://lzws0931.cn/tags/面试/"}]},{"title":"路径并不像你想的那么简单","slug":"路径并不像你想的那么简单","date":"2018-04-08T06:21:00.000Z","updated":"2018-04-08T06:51:07.539Z","comments":true,"path":"2018/04/08/路径并不像你想的那么简单/","link":"","permalink":"https://lzws0931.cn/2018/04/08/路径并不像你想的那么简单/","excerpt":"","text":"相对路径，绝对路径？ 之前在通过demo学习相对路径和绝对路径的时候，感觉路径是很简单的知识点。相对，不就是相对于某一个东西而言的位置，绝对，不就是写死的路径么。可是，当把这些点放在项目里面的时候我才绝的并不简单。 相对路径-以引用文件之网页所在位置为参考基础，而建立出的目录路径。因此，当保存于不同目录的网页引用同一个文件时，所使用的路径将不相同，故称之为相对。 绝对路径-以Web站点根目录为参考基础的目录路径。之所以称为绝对，意指当所有网页引用同一个文件时，所使用的路径都是一样的。 每个文件／文件夹都只有一个绝对路径，无数个相对路径有一天，Cherry在路上遇到Sunkist，它问Sunkist的公司地址在哪里，Sunkist可能有两个答案：以这里为起点，西南方向500米的石室大厦中国广东省广州市思哲路石室大厦 第一个答案以当前的位置为起点所描述的称为相对路径。根据Sunkist当前的位置不一样，它回答的相对路径会不一样. 第二个答案从国家到省份城市巨细无遗地描述称为绝对路径，一个文件除非被移动，否则绝对路径是不会变化的。 每个文件/文件夹在一台计算机中可能会有无数个相对路径，但是只有一个绝对路径。（此demo引自）engine 如何表示上级目录../表示源文件所在目录的上一级目录，../../表示源文件所在目录的上上级目录，以此类推。 如何表示下级目录引用下级目录的文件，直接写下级目录文件的路径即可。1&lt;a href=&quot;adminwang/bbb.html&quot;&gt;链接bbb网页&lt;/a&gt;","categories":[{"name":"知识分享","slug":"知识分享","permalink":"https://lzws0931.cn/categories/知识分享/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://lzws0931.cn/tags/前端/"}]},{"title":"从一个人的社交圈看不到什么有用信息！","slug":"感谢","date":"2018-04-06T14:56:00.000Z","updated":"2018-04-06T15:09:51.263Z","comments":true,"path":"2018/04/06/感谢/","link":"","permalink":"https://lzws0931.cn/2018/04/06/感谢/","excerpt":"","text":"心里很不舒服 之前心里很不舒服还是几年前。 几年之前呢？ 13年还是16年？ 具体的时间我已经忘记了。。但是却非常不愿意有这种滋味。 感觉身上发冷，是由内而外的冷。 我不喜欢把自己内心的东西发布在任何一个社交平台，包括这里 不希望被别人看透彻，不希望被别人知道，这里一下，哪里一下。不要把任何个人的情绪波动表露出来，这就是缺乏安全感吧，只能相信自己。 这个博客是自己搭建起来的，像我的微博一样，自己养活那么大，真让我卖，还真舍不得。 偶尔矫情一下，还是有必要的。 大家都懂，感谢你。 小太阳","categories":[{"name":"生活琐事","slug":"生活琐事","permalink":"https://lzws0931.cn/categories/生活琐事/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://lzws0931.cn/tags/生活/"}]},{"title":"对于前后端分离的了解","slug":"对于前后端分离的了解","date":"2018-03-21T02:21:00.000Z","updated":"2018-03-21T02:51:13.123Z","comments":true,"path":"2018/03/21/对于前后端分离的了解/","link":"","permalink":"https://lzws0931.cn/2018/03/21/对于前后端分离的了解/","excerpt":"","text":"前后端分离、 本文来源我在慕课网学习时候看到笔记整理 https://www.imooc.com 什么叫前后端分离？ 前后端分离就是后端不再直接返回html， 直接返回数据，当然数据格式可以自己指定比如xml， json、yml都是可以的， html页面由前端去填充这些数据到dom中。 随着前后端技术的更新，越来越多的前端框架进入开发者们的视野，网站的前后分离架构越来越得到开发者们的喜爱与认可。 后端只提供数据接口、业务逻辑与持久化服务，而视图、控制与渲染则交给前端。 因此，越来越多的网站从后端渲染变成了前端渲染，前后端分离意味着后端可以不用去了解前端的代码， 前端不用学习后端的模板语法， 前后端不需要等到对方做好了才能调试了， 尽量在保证自己端的代码写好以及少bug， 这样在后期真正联调的时候就可以尽量避免bug了，而且前后端分离还意味着pc端、app、后台管理系统等各种系统可以尽量多的共用接口了。 什么时候选择前后端分离的开发模式？ 在开发过程中相信大家经常会遇到一个问题， android端、ios端、pc端、 后台管理系统如果使用传统的mvc开发模式， 只要页面不一样 我们都得给对应的系统写一套后台， 而且很多页面还需要后端去填充数据到html中、 但是前后端分离的开发模式我们只需要把接口写好， 其余都不用管让前端去协调各个接口之间如何配合。这种模式最大的好处就是适应性很强。 当然还有个很大的好处就是前端不用再等待将页面写好了然后交给后端， 然后后端再将代码改成模板语言了， 当然如果前端熟悉后端模板语法， 后端当然就很喜欢了， 但是前端往往不愿意去学习后端的模板语法，更喜欢用前端自己的模板语法。 前后端分离解决了这个问题 但是Restful api还是有缺点， 最大的问题就是seo， 爬虫爬不到， 百度就会给你降权， 对于那种需要流量的网站来说，这个是不太接受的， 所以后面就有了ssr技术， 在服务器端渲染好静态页面直接给前端， 这篇爬虫就能爬取到了， 而且有些系统比如内部系统或者后台管理系统这种根本就不在乎seo的直接就用restful api开发就行了。 除了上面的问题以外还有就是数据格式依赖严重， 如果后端改了某个字段的名称， 前端也得跟着改， 在以前这种改动后端自己就可以一个人完成，但是分离之后得前端去改了， 如果返回格式变了，前端变动更大。 还有就是文档变得很重要了我们得去维护文档了，因为前后端分离脱离了文档，后期想维护能麻烦死。 前后端分离开发 跨域问题 我们现在有个二次开发的项目，要求前后端分离开发，前端我用webpack-dev-server本地服务，要请求java后台tomact下数据，我要处理跨域请求的问题，jsonp肯定是不行了，后台代码基本已经确认了，我想问如何让后台做的少更改的情况下，前端这边需要做什么配置来解决跨域问题。 想问一些关于前后端分离开发的问题。因为第一次开发有很多地方不清楚，上网查了很多资料现在似懂非懂，基本上就开发环境下的跨域问题是前端后后台一起解决，还是只用前端解决。（网上说是一起解决，但我后台的同事也没有接触过，他们以前都是javaweb项目，也不太懂），第二就是后期部署时前端和后台是不是分开部署服务器，可以部署在同一个服务器上吗。 要么单独写jsonp的接口，要么后台设置cors。开发环境下，你可以使用webpack的代理，用你启动的node服务代理请求访问java的接口然后把结果返回给你，但是生产环境下必须要后端的配合，要么jsonp, 要么设置cors，前端是无法解决的！设置cors是改动成本最低的方式 Node.js覆盖哪些领域？有没有值得玩的？ 理论上 Node 运行在服务器，后端能做的 Node 都能做，但是有几个擅长的领域前端本地代码构建、打包：webpack、gulp、babel 等前端单元测试 &amp; UI 测试：mocha、kama、jest、puppeteer 等视觉渲染为核心的 web 站点：koa、express企业级 web 框架 egg爬虫 puppeteer桌面程序开发 node-webkit、electron比较好玩的应该是爬虫和啄米昂程序开发，但工作最常用的是本地代码构建、打包 &amp; web 请问一下，在公司里从事前端和后端的人是如何配合的？在前后端分离的情况下，后端同学的任务是把数据和文件做持久化存储，并提供操作数据数据的接口。前端同学负责请求数据，然后对数据做处理和适配，最后再把数据呈现出来。其实就是以接口为界限，后端负责接口的制作，前端负责接口的调用。 在实际开发中，一般是前后端同学拿到需求后，一起来确定各个功能点需要的接口，然后再逐个细化出各个接口的输入输出字段，最后由后端同学生成一个接口文档。 模块化为什么可以提高开发效率？1.对代码进行封装隔离，提高代码的复用性，就能减少代码量2.通过逐级对业务的拆解，达到简化业务的作用，降低系统复杂度3.更好的代码组织方式，能支持团队并行开发，提高团队的效率4.封闭作用域，减少变量冲突带来的不太容易发现的问题5.耦合小，利于后期扩展和修改，降低系统的后期维护成本 开发环境：开发环境是程序猿们专门用于开发的服务器，配置可以比较随意，为了开发调试方便，一般打开全部错误报告。 测试环境：一般是克隆一份生产环境的配置，一个程序在测试环境工作不正常，那么肯定不能把它发布到生产机上。 生产环境：是值正式提供对外服务的，一般会关掉错误报告，打开错误日志。 三个环境也可以说是系统开发的三个阶段：开发-&gt;测试-&gt;上线，其中生产环境也就是通常说的真实环境。","categories":[{"name":"前后分离","slug":"前后分离","permalink":"https://lzws0931.cn/categories/前后分离/"}],"tags":[{"name":"工作流","slug":"工作流","permalink":"https://lzws0931.cn/tags/工作流/"}]},{"title":"我的技术博客终于完成了！","slug":"我的技术博客终于完成了","date":"2018-03-19T13:52:00.000Z","updated":"2018-03-19T15:18:55.427Z","comments":true,"path":"2018/03/19/我的技术博客终于完成了/","link":"","permalink":"https://lzws0931.cn/2018/03/19/我的技术博客终于完成了/","excerpt":"","text":"经过了一周的努力，我的技术博客完成了其中我收获颇多。虽然我用的是hexo第三方的主题，但是我修改了里面不少的结构样式其中踩到很多的坑。由于主题用的是ejs模版，不是很熟悉，导致刚开始的时候结构和样式比较混乱。经过一天的查询资料以及了解根据文件命名的了解大体对文件有了初步认识。 其中博客里面还自主插入了网易云音乐,QQ聊天,微博秀等第三方的插件，特别是在微博秀的时候，对http和https有了更深刻的认识。 在最后显示博文的标题图片的时候，也遇到了bug,然后自己也获得了解决。由于刚开始没有重点去用笔记的形式记这些内容，所以只是在自己的印象笔记里面有了一些关键词的笔记。后期如果学习和做项目的过程中，希望能发挥出我自己这个技术博客的作用。 哦，对了，最后由于觉得用hexo的命令行发布博文太麻烦，又找到了一个hexo/admin的插件可以使用，大大的方便了后面对博文的编辑。而且我的MD编辑的语法不是很熟悉，后面会对此进行加强练习。 域名正在备案中，等备案成功了，我就终于完成了一个小梦想。最近在做这个网站的时候我竟然觉得自己慢慢喜欢上看技术。以前可是从来没有这样的感觉。 上线以后再对网站进行SEO优化吧，让百度多抓抓、、或许别人觉得这个网站很简单，比较丑但是这就是提高。脚踏实地的提高。接下来就是给七期就业了。加油。⛽️","categories":[{"name":"博客制作","slug":"博客制作","permalink":"https://lzws0931.cn/categories/博客制作/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://lzws0931.cn/tags/生活/"}]},{"title":"法门扫地僧面试宝典第一版","slug":"法门扫地僧前端面试宝典第一版","date":"2018-03-19T01:45:09.000Z","updated":"2019-01-24T05:09:31.398Z","comments":true,"path":"2018/03/19/法门扫地僧前端面试宝典第一版/","link":"","permalink":"https://lzws0931.cn/2018/03/19/法门扫地僧前端面试宝典第一版/","excerpt":"","text":"Front-End前端开发工程师面试宝典！ （本文部分有转载，不定期更新！） 前言（README.md）12本仓库是我整理的前端常见面试题，大部分由我整理，其中个别部分参考网上其他资料，感谢！ 本资料仅供大家学习参考使用！欢迎大家Star和提交issues。 NO.1 READMENO.2 简历经验分享NO.3 angular常见问题NO.4 前端面试宝典第一版NO.5 前端笔记版本第二版NO.6 前端笔记版本第三版NO.7 前端笔记版本第四版NO.8 vue常见问题 欢迎大家一起交流提高CSS盒模型基本概念:标准模型+IE模型 标准模型和IE模型区别 标准模型的宽度是content IE模型的宽和高是content+padding+border CSS如何设置这两种模型 box-sizing：conten-box；用于标准浏览器 box-sizing：border-box；用于IE浏览器 BFC或IFC（边距重叠解决方案） BFC：块级格式化上下文IFC：行内格式化上下文 BFC的原理：BFC的渲染规则 一、BFC的垂直方向边距会发生重叠 二、BFC的box区域不会与浮动元素重叠（用于清除浮动） 三、BFC在页面上是一个独立的容器，外面的元素不会影响里面的元素 四、计算BFC高度的时候浮动元素也会参与计算如何创建BFC float不为none（默认值是none） position不是static和relative display的值是table相关的 overflow的值不为visibleBFC的使用场景 BFC垂直方向边距重叠 BFC不与float元素重叠 BFC子元素即使是float也会参与 ##HTTP协议 HTTP协议的主要特点 简单快速：每个URI是固定的 灵活：可以完成不同数据类型的传输 *无连接：连接一次就会断掉，不会一直连着 *无状态：http不能区分两次连接的不同 HTTP报文的组成部分 请求报文 请求行（http方法+页面地址+http协议版本） 请求头（key：value值） 空行（头和体的分隔标识） 请求体响应报文 状态行（http协议+版本+状态码） 响应头 空行 响应体 HTTP方法 GET-&gt;获取资源 POST-&gt;传输资源 PUT-&gt;更新资源 DELETE-&gt;删除资源 HEAD-&gt;获得报文首部 POST和GET的区别 GET在浏览器回退时是无害的，而POST会再次提交请求 GET产生的URI地址可以被收藏，而POST不可以 GET请求会被浏览器主动缓存，而POST不会，除非手动设置 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会保留 GET请求在URL中传输的参数是有长度限制的，而POST没有限制 GET参数通过URL传递，POST放在Request body中 常见HTTP状态码 1xx：指示信息-表示请求已接收，继续处理 2xx：成功-表示请求已被成功接收 3xx：重定向-要完成请求必须进行更进一步的操作 4xx：客户端错误-请求有语法错误或请求无法实现 5xx：服务器错误-服务器未能实现合法的请求 200：服务器成功返回 206：客户端表明自己只需要目标URL上的部分资源 301：永久重定向 302：临时重定向 304：缓存(服务器告诉客户，原来缓冲的文档还可以继续使用) 400：请求出错 401：被请求的页面需要用户名和密码 403：服务器拒绝访问 404：资源找不到 500：服务器错误 503：请求未完成。服务器临时过载或当机 HTTPS对于HTTP的优点 通信使用明文不加密，内容可能被窃听 不验证通信方身份，可能遭到伪装 无法验证报文完整性，可能被篡改 HTTPS就是HTTP加上加密处理（一般是SSL安全通信线路）+认证+完整性保护 ##关于this 浏览器宿主的全局环境中，this指的是window对象。1console.log(this === window); //true 浏览器中在全局环境下，使用var声明变量其实就是赋值给this或window。123var foo = &quot;bar&quot;;console.log(this.foo); //logs &quot;bar&quot;console.log(window.foo); //logs &quot;bar&quot; 任何情况下，创建变量时没有使用var或者let(ECMAScript 6)，也是在操作全局this。123456789foo = &quot;bar&quot;;function testThis() &#123; foo = &quot;foo&quot;;&#125;console.log(this.foo); //logs &quot;bar&quot;testThis();console.log(this.foo); //logs &quot;foo&quot; 除了DOM的事件回调或者提供了执行上下文（后面会提到）的情况，函数正常被调用（不带new）时，里面的this指向的是全局作用域。 当用调用函数时使用了new关键字，此刻this指代一个新的上下文(实例)，不再指向全局this。 在DOM事件的处理函数中，this指代的是被绑定该事件的DOM元素。 HTML标签的属性中是可能写JS的，这种情况下this指代该HTML元素。 无法重写this，因为它是一个关键字。 ##通信类 什么是同源策略及限制 源：协议，域名，端口 限制：不是一个源的文档没有权利去操作另一个源的文档，包括：Cookie, LocalStorage, IndexDB,DOM无法获取， Ajax无法发送 同源策略限制不同的源的文档之间进行交互 前后端如何通信 ajax（同源限制） WebSocket（不受限制） CORS（支持同源，也支持非同源—新的通信协议标准） 跨域通信的几种方式 JSONP Hash(hash改变，页面是不刷新的，？后是search，改变时会刷新页面) postMessage（H5标准） WebScoket CORS（可以理解为支持跨域通信的变种Ajax。当你在浏览器中发送一个ajax跨域请求时，浏览器会在http头中加入一个origin。如果只是一个普通的ajax，则会被浏览器拦截） JSONP的原理：利用script标签可以实现加载不同源。 在window全局注册一个函数 给服务端传递这个函数的名字，同时可以有参数 服务端返回这个函数，内部填充有数据，就可以拿到数据 删除全局注册的那个函数 Hash的原理：页面A中通过iframe或iframe嵌入了B窗口。目标是A给B发送消息。 拿到B的url地址 改变其hash值 在B中接收，onhashchange WebSocket的原理： var ws = new WebSocket(‘wss:echo.websocket.org’); onopen, onmessage, onclose ##浏览器是怎样渲染一个页面由从服务器接收到的 HTML 形成DOM（文档对象模型）。样式被加载和解析，形成 CSSOM（CSS 对象模型）。紧接着 DOM 和 CSSOM 创建了一个渲染树，这个渲染树是一些被渲染对象的集合（ Webkit 分别叫它们”renderer”和”render object”，而在Gecko 引擎中叫”frame”）。除了不可见的元素（比如 head 标签和一些有 display:none 属性的元素），渲染树映射了 DOM 的结构。在渲染树中，每一个文本字符串都被当做一个独立的 renderer。每个渲染对象都包含了与之对应的计算过样式的DOM 对象（或者一个文本块）。换句话说，渲染树描述了 DOM 的直观的表现形式。对每个渲染元素来说，它的坐标是经过计算的，这被叫做“布局(layout)”。浏览器使用一种只需要一次处理的“流方法”来布局所有元素（tables需要多次处理）。最后，将布局显示在浏览器窗口中，这个过程叫做“绘制(painting)”。 重绘当在页面上修改了一些不需要改变定位的样式的时候（比如background-color,border-color,visibility)，浏览器只会将新的样式重新绘制给元素（这就叫一次“重绘”或者“重新定义样式”） 重排当页面上的改变影响了文档内容、结构或者元素定位时，就会发生重排（或称“重新布局”）。重排通常由以下改变触发： DOM 操作（如元素增、删、改或者改变元素顺序）。内容的改变，包括 Form 表单中文字的变化。计算或改变 CSS 属性。增加或删除一个样式表。改变”class”属性。浏览器窗口的操作（改变大小、滚动窗口）。激活伪类（如:hover状态）。 ##加载和渲染过程页面加载和渲染的过程（涉及内核间的差异以及并发处理）从浏览器地址栏的请求链接开始，浏览器通过DNS解析查到域名映射的IP地址，成功之后浏览器端向此IP地址取得连接，成功连接之后，浏览器端将请 求头信息 通过HTTP协议向此IP地址所在服务器发起请求，服务器接受到请求之后等待处理，最后向浏览器端发回响应，此时在HTTP协议下，浏览器从服务器接收到 text/html类型的代码，浏览器开始显示此html，并获取其中内嵌资源地址，然后浏览器再发起请求来获取这些资源，并在浏览器的html中显示。 其实浏览器加载显示html的顺序是按下面的顺序进行的： 1、IE下载的顺序是从上到下，渲染的顺序也是从上到下，下载和渲染是同时进行的。 2、在渲染到页面的某一部分时，其上面的所有部分都已经下载完成（并不是说所有相关联的元素都已经下载完）。 3、如果遇到语义解释性的标签嵌入文件（JS脚本，CSS 脚本）在IE的下载过程会启用单独连接进行下载。 4、并且在下载后进行解析，解析过程中，停止页面所有往下元素的下载。 5、样式表在下载完成后，将和以前下载的所有样式表一起进行解析，解析完成后，将对此前所有元素（含以前已经渲染的）重新进行渲染。 6、JS、CSS中如有重定义，后定义函数将覆盖前定义函数。 Firefox处理下载和渲染顺序大体相同，只是在细微之处有些差别，例如：iframe的渲染 样式文件和JS文件一样是下载完一个解析一个的 ##运算符 i++和 ++i的区别，i++单独使用时候和++i一模一样，i++是等i这个表达式运算结束后再运算i+1，然后改变i的值,而++i是先运算i+1,然后改变i的值，然后再和外面的表达式结合，进行整体运算。 ##字符串处理toFixed(num)（ps：num为保留小数点后几位）Math.ceil(num) //返回大于等于其数值参数的最大整数Math.floor(num) //返回小于等于其数值参数的最大整数Math.round(num) //四舍五入取整concat 将两个或多个字符的文本组合起来，返回一个新的字符串。indexOf 返回字符串中一个子串第一处出现的索引（从左到右搜索）。如果没有匹配项，返回 -1 。charAt 返回指定位置的字符。lastIndexOf 返回字符串中一个子串最后一处出现的索引（从右到左搜索），如果没有匹配项，返回 -1 。match 检查一个字符串匹配一个正则表达式内容，如果么有匹配返回 null。substring 返回字符串的一个子串，传入参数是起始位置和结束位置。substr 返回字符串的一个子串，传入参数是起始位置和长度replace 用来查找匹配一个正则表达式的字符串，然后使用新字符串代替匹配的字符串。search 执行一个正则表达式匹配查找。如果查找成功，返回字符串中匹配的索引值。否则返回 -1 。slice 提取字符串的一部分，并返回一个新字符串（与 substring 相同）。split 通过将字符串划分成子串，将一个字符串做成一个字符串数组。length 返回字符串的长度，所谓字符串的长度是指其包含的字符的个数。toLowerCase 将整个字符串转成小写字母。toUpperCase 将整个字符串转成大写字母。 字符串连接操作非常消耗资源,解决方法是用 Array 对象存储字符串，然后用 join() 方法（参数是空字符串）创建最后的字符串 ##js里面的基础对象和基础数据类型JS基础数据类型:number数字(NaN)、string字符串、boolean布尔值、null、undefinedtypeof 用来判断数据类型显示/强制类型转换（ Number()、parseInt()、parseFloat() ）基础对象：Document、Window、Navigator、Screen、History、Location 基础对象JS Array、JS Boolean、JS Date、JS Math、JS Number、JS String、JS RegExp、JS Functions、JS EventsBrowser 对象 Window、Navigator、Screen、History、Location ##DOM年份，DOM好处和坏处，怎么禁用DOMDocument Object Model (DOM)是HTML和XML文档的编程接口。DOM标准主要要为：微软DOM与W3C DOM，一般IE实现的是微软DOM，而其它浏览器则不同程度的实际了W3C DOMDOM Level Zero ,事实上从来不存在DOM 0版本，只是人们的戏称。只是在W3C DOM出现之前，不同浏览器（主要是IE与NN）实现的DOM相互排斥，1996年的浏览器大战所产生的DHTML就是所谓的DOM 0，它是脚本程序员的恶梦DOM Level 1 包括DOM Core和DOM HTML。前者提供了基于XML的文档结构图。后者添加了一些HTML专用的对象和方法，从而扩展了DOM Core.目前IE在内的大部分桌面浏览器都通过不同方式实现了DOM 1DOM Level 2 引入几个新模块：DOM视图，事件，样式，遍历和范围。IE只实现了一部分，火狐浏览器几乎全部实现，除IE之外的浏览器也实现了大部分DOM Level 3 引入了以统一的方式载入和保存文档的方法。DOM Core被扩展支持所有的XML1.0的特性。火狐浏览器之类实现了少部分 好处：js调用dom的属性和方法就可以编程控制网页中的各种元素坏处：DOM操作很耗性能 ##BOM浏览器信息BOM是Browser Object Model的缩写，简称浏览器对象模型window对象、History对象、Location 对象、Navigator对象 ##Jsonp接口的原理 JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。 JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。 ##js模板引擎模板引擎是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。 JS的加载不能并行下载和解析（阻塞下载）当 引用了JS的时候，浏览器发送1个jsrequest就会一直等待该request的返回。因为浏览器需要1个稳定的DOM树结构，而JS中很有可能有代 码直接改变了DOM树结构，比如使用 document.write 或 appendChild,甚至是直接使用的location.href进行跳转，浏览器为了防止出现JS修改DOM树，需要重新构建DOM树的情况，所以就会阻塞其他的下载和呈现。 ##闭包 了解什么是闭包、如何使用闭包、闭包的原理、闭包的真正原理 定义 闭包是有权访问另一个函数作用域中的变量的函数 作用域链 作用域链就是函数在定义的时候创建的,用于寻找使用到的变量的值的一个索引,而他内部的规则是,把函数自身的本地变量放在最前面,把自身的父级函数中的变量放在其次,把再高一级函数中的变量放在更后面,以此类推直至全局对象为止。 内存回收机制 如果这个函数内部又嵌套了另一个函数,而这个函数是有可能在外部被调用到的.并且这个内部函数又使用了外部函数的某些变量的话.这种内存回收机制就会出现问题. 闭包作用：一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 ##事件绑定 为什么用bind来进行事件绑定，live方法的实现原理Jquery中绑定事件有三种方法：以click事件为例 （1）target.click(function(){}); （2）target.bind(“click”,function(){}); （3）target.live(“click”,function(){}); 第一种方法很好理解，其实就和普通JS的用法差不多，只是少了一个on而已 第二、三种方法都是绑定事件，但是二者又有很大的不同，下面着重讲解一下，因为这个如果用到Jquery的框架的话是用的挺多的，尤其要注意二者的区别。 【bind和live的区别】 live方法其实是bind方法的变种，其基本功能就同bind方法的功能是一样的，都是为一个元素绑定某个事件，但是bind方法只能给当前存在的元素绑定事件，对于事后采用JS等方式新生成的元素无效，而live方法则正好弥补了bind方法的这个缺陷，它可以对后生成的元素也可以绑定相应的事件。 live方法之所以能对后生成的元素也绑定相应的事件的原因归结在“事件委托”上面，所谓“事件委托”就是指绑定在祖先元素上的事件可以在其后代元素上进行使用。live方法的处理机制就是把事件绑定在DOM树的根节点上，而不是直接绑定在某个元素上。 由于只有在事件发生的时候，live方法才会去检测绑定事件的对象是否存在，所以live方法可以实现后来新增的元素也可实现事件的绑定。相比之下，bind会在事件在绑定阶段就会判断绑定事件的元素是否存在，而且只针对当前元素进行绑定，而不是绑定到父节点上。 那么为什么还要使用bind方法呢？bind和live主要的不同如下： （1）bind方法可以绑定任何JavaScript的事件，而live方法在jQuery1.3的时候只支持click, dblclick, keydown, keypress,keyup,mousedown, mousemove, mouseout, mouseover, 和 mouseup.在jQuery 1.4.1中，甚至也支持 focus 和 blue事件了（映射到更合适，并且可以冒泡的focusin和focusout上）。另外，在jQuery 1.4.1中，也能支持hover（映射到”mouseenter mouseleave”）。 （2）live() 并不完全支持通过DOM遍历的方法找到的元素。取而代之的是，应当总是在一个选择器后面直接使用 .live()方法。 （3）当一个元素采用live方法进行事件的绑定的时候，如果想阻止事件的传递或冒泡，就要在函数中return false,仅仅调用stopPropagation()是无法实现阻止事件的传递或者冒泡的 ##mouseover和mouseenter的区别 不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。对应mouseout 只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。对应mouseleave 工具库extJS、YUI、Prototype：这些工具库或框架都有各自的特点 extJS 最新版本：Ext JS5 优点： 强大的UI，而且性能不错，这是其最大的优点。 速度快，不管是UI还是其它模块。 100%面向对象和组件化的思想，一致的语法，全局的命名空间。 文档的完整，规范，方便。 核心的开发团队，Jack Slocum等。 活跃的社区，迅速增加的用户量。 模块化实现，可扩展性强。 所有的组件（widgets）都可直接使用，而无需进行设置 缺点： 稍复杂。 为重量级的框架（包含大量UI），体积大。如果导入ext-all.js，压缩后也有近500k。 2.ExtJs的特点 (1)纯Html/CSS+JS技术,重新定义表示层的耦合； (2)基于纯Html/CSS+JS技术，提供丰富的跨浏览器UI组件，灵活采用JSON/XML数据源开发，使得服务端表示层的负荷真正减轻，从而达到客户端的MVC应用； (3)集成多种JS底层库， 满足开发者不同需求； (4)Ext初期仅是对YUI的对话框扩展，后来逐渐有了自己的特色，深受网友的喜爱。发展至今，Ext除YUI外还支持Jquery Prototype等的JS库，让大家自由地选择； (5)多浏览器支持、支持多平台下的主流浏览器。 3.ExtJs的优缺点 (1).ExtJs的优点 .UI组件丰富，外观漂亮。 Ext JS库有着丰富且漂亮的UI组件，大大缩短了我们的开发周期，而且组件拥有漂亮的布局，经过简单的调用与配置就可以实现不错的界面布局。ExtJS提供的各种组件可以用更加标准的方式展示数据降低了开发难度。 .浏览器兼容性好。 使用ExtJS对浏览器没有任何要求。可以说是一种绿色的富客户端实现方式，ExtJs基本可以运行于现在主流的浏览器。 有很多动画效果做得很不错，提高了用户的感知度。 和后台代码无关。 不管后台用什么语言开发的都不会受影响，不管你是用C#也好 JAVA也好 还是PHP都和它没关系。 将Web程序向桌面系统转化。 ExtJS最大的优势在于它将Web应用程序的操作方式向传统桌面应用程序的操作方式进行转化甚至消除了这种差异，从根本上提高了用户的使用体验，这是ExtJS应用前景广阔的主要原因。 .相对丰富的文档和示例。 毫无疑问，刚刚接触到ExtJS的人多数都是被它附带的例子和开发文档吸引过去的，它的文档做的确实不错。 (2) ExtJs的缺点 .体积较大，速度稍慢。 由于使用了大量的UI组件，所以体积较大，导致页面加载速度比较慢。 .收费,好像不免费。 因为它太优秀了，所以从Ext JS 2.0以后的版本都是收费的。也许这一点不能算是它的缺点，但这确实阻碍了它的推广与应用。 没有合适的开发利器。 毫无疑问，一个好的开发工具可以大大的提高编码的速度，但是对于ExtJS，始终没有一个完美的开发工具，可以推荐的有Aptana Studio， Spket IDE，和Spket 提供的提示文件，但是都是各有优缺点，都不完美，只能一边看SDK一边写代码。 没有界面设计工具。 虽然有人提供了一个在线的界面设计工具，但是和Visual Studio提供的ASP.Net设计工具来说，真的可以说是天壤之别。因此，只能一边预览，一边写代码。 文档不全。 虽然ExtJS提供的文档很丰富，但是还是跟不上源代码的更新速度，所以，经常要通过看源代码，调试才能真正解决问题。 不能编译。 这一点可以说是JavaScript的缺点（如果能编译，就不叫JavaScript了），在实际的开发中，经常会敲错一些代码，比如大小写错误等，不能通过编译得到反馈，只能在运行时排错，导致开发的效率比较低下。 YUI如果你想作门户、如果你想作SNS、如果你想作大型电子商务和电子政务网站，你大概只有一个选择，那就是Yui，Yui抽象出了比其他框架更复杂的层次结构、把模块按照不同的层次划分，并定义层次之间模块依赖关系，这种设计使得Yui对万行级代码的管理游刃有余，这种重设计轻开发的思想是Yui的核心之一，此外，Yui不仅仅是JS框架，他是JS＋CSS＋规范的集合，必要的约束在团队协作项目中可以降低成本。其实Yui本身也是团队合作的产物。在扩展性方面，我觉得Yui是所有前端框架作的最好的，Ext就是选择基于Yui进行扩展。相对来讲，ProtoType和jQuery显然太小了。 Prototype 优点：基本底层，易学易用，甚至是其他一些js特效开发包的底层，体积算是最小的了。 缺点：如果说缺点，可能就是功能是他的弱项 jQuery 有人说jQuery是被设计用来改变你写JavaScript的方法的。在这一方面jQuery的确作的很好，20行的Dom javascript语句在jQuery里只需要2－3行就可以完成，语言的简洁简直太吸引人了，尤其对于前端开发工程师这群多少有些代码洁癖的人来说，简直美妙绝伦，甚至忽视了其粗糙的面向对象的结构这一致命的缺点。当我们过多的沉浸在代码简洁的乐趣中无法自拔的时候，对更高级抽象的忽视往往阻挡住了我们的视野。因此，jQuery本身无法承担庞大的网站架构任务，也只能在中小网站中搞一搞动画特效而已。但这仍然无法阻止wd们对jQuery的偏爱，只要你有洁癖，那么你一定会喜欢jQuery的。 MooTools 在面向对象的方面，MooTools的确作的不错，软件设计模式中的高内聚和低耦合在MooTools中有良好的体现。文档也很完整，但MooTools的占有率一直不高是一个很尴尬的现象，作底端太多余，无法和jQuery竞争，作高端又有点吃力，无法和Yui竞争，给人鸡肋的感觉，就这样。 fiddler工具 它能记录所有客户端和服务器的http和https请求，允许你监视，设置断点，甚至修改输入输出数据原理：Fiddler 是以代理web服务器的形式工作的,它使用代理地址:127.0.0.1, 端口:8888. 当Fiddler会自动设置代理， 退出的时候它会自动注销代理，这样就不会影响别的程序。 BackboneJS Backbone 为复杂Javascript应用程序提供模型(models)、集合(collections)、视图(views)的结构。其中模型用于绑定键值数据和自定义事件；集合附有可枚举函数的丰富API； 视图可以声明事件处理函数，并通过RESRful JSON接口连接到应用程序。 AngularJS AngularJS 是一款开源 JavaScript 函式库，由Google 维护，用来协助单一页面应用程式运行的。它的目标是透过MVC模式 (MVC) 功能增强基于浏览器的应用，使开发和测试变得更加容易。 函式库读取包含附加自定义（标签属性）的HTML， 遵从这些自定义属性中的指令，并将页面中的输入或输出与由JavaScript变量表示的模型绑定起来。这些JavaScript变量的值可以手工设置，或者从静态或动态JSON资源中获取。 优点​ 模板功能强大丰富，并且是声明式的，自带了丰富的Angular指令是一个比较完善的前端MV*框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能自定义Directive，比jQuery插件还灵活，但是需要深入了解Directive的一些特性，简单的封装容易，复杂一点官方没有提供详细的介绍文档，我们可以通过阅读源代码来找到某些我们需要的东西，如：在directive使用 $parseng模块化比较大胆的引入了Java的一些东西（依赖注入），能够很容易的写出可复用的代码，对于敏捷开发的团队来说非常有帮助，我们的项目从上线到目前，UI变化很大，在摸索中迭代产品，但是js的代码基本上很少改动补充：Angular支持单元测试和e2e-testing 缺点 验证功能错误信息显示比较薄弱，需要写很多模板标签，没有JQuery Validate方便，所以我们自己封装了验证的错误信息提示，详细参考 why520crazy/w5c-validator-angular · GitHubngView只能有一个，不能嵌套多个视图，虽然有 angular-ui/ui-router · GitHub 解决，但是貌似ui-router 对于URL的控制不是很灵活，必须是嵌套式的（也许我没有深入了解或者新版本有改进）对于特别复杂的应用场景，貌似性能有点问题，特别是在Windows下使用chrome浏览器，不知道是内存泄漏了还是什么其他问题，没有找到好的解决方案，奇怪的是在IE10下反而很快，对此还在观察中这次从1.0.X升级到1.2.X，貌似有比较大的调整，没有完美兼容低版本，升级之后可能会导致一个兼容性的BUG，具体详细信息参考官方文档 AngularJS ，对应的中文版本：Angular 1.0到1.2 迁移指南ng提倡在控制器里面不要有操作DOM的代码，对于一些JQuery 插件的使用，如果想不破坏代码的整洁性，需要写一些directive去封装一下JQ插件，但是现在有很多插件的版本已经支持Angular了，如：jQuery File Upload Demo Angular 太笨重了，没有让用户选择一个轻量级的版本，当然1.2.X后，Angular也在做一些更改，比如把route，animate等模块独立出去，让用户自己去选择 Seajs SeaJS是由支付宝前端高级技术专家王保平（玉伯）开发的一个遵循CMD规范的模块加载框架，可用来轻松愉悦地加载任意JavaScript模块和CSS模块。 SeaJS非常小巧，小巧在于其压缩后体积只有4KB，而且接口和方法也非常少。SeaJS有两个核心：模块的定义和模块的加载。SeaJS可以加载任意 JavaScript模块和CSS模块，能保证你在使用一个模块时，已将所依赖的其他模块载入脚本运行环境中。SeaJS可以让你享受写代码的乐趣，不用 去管那些加载的问题。毕竟现在网页的可维护性和性能问题一样严峻，体现在：文件太多，不利于维护，前端后端都一样；HTTP请求过多，当然这个可以通过合 并解决，但如果没有后端直接合并，那么人工成本会非常大。用SeaJS就能非常好地解决这些问题。SeaJS遵循CMD规范，因此可以很方便地书写模块。 目前已经有越来越多的人采用CMD规范来开发项目了。 CommonJS CommonJS API定义很多普通应用程序（主要指非浏览器的应用）使用的API，从而填补了这个空白。它的终极目标是提供一个类似Python，Ruby和Java标准库。这样的话，开发者可以使用CommonJS API编写应用程序，然后这些应用可以运行在不同的JavaScript解释器和不同的主机环境中。在兼容CommonJS的系统中，你可以实用JavaScript程序开发： 服务器端JavaScript应用程序命令行工具图形界面应用程序混合应用程序（如，Titanium或Adobe AIR） ##lazyloader 1、获取需要做按需加载的图片在页面的位置 getClientRects常用于获取鼠标的位置 getBoundingClientRect获取元素位置 2、预加载的位置为：上下一屏的图片 ##cookie 大多数浏览器规定Cookie大小不超过4K，每个站点能保存的Cookie不超过20个，所有站点保存的Cookie总和不超过300个当没有指明cookie时间时，所创建的cookie有效期默认到用户浏览器关闭止，故被称为会话cookiedocument.cookie=”userId=828; userName=hulk”; ##描述一下渐进增强和优雅降级之间的不同两者区别的关键在于它们各自关注的焦点，以及这种关注对工作流程的影响。 优雅降级的视角 优雅降级关注于在最先进/最全能的浏览器上构建网站。在被认为老的或能力不足的浏览器中的测试，经常要等到开发周期的最后一个环节才进行，并且通常限制在主流浏览器（如IE、Mozzila等）的前一个发布版本中。 在这种模式下，老的浏览器只可能提供差强人意（poor, but passable）的体验。或许会做些小补丁来适应某个特定浏览器，但这些浏览器毕竟不是关注的焦点，除了修正重大的错误，也不会再费多大的神了。 渐进增强的视角 渐进增强关注于内容。请注意区别：我甚至都没提及浏览器。 内容是我们最初创建网站的原因。有些网站传播内容，有些收集内容，有些请求内容，有些操作内容，有些网站以上所有功能都有，然而而他们都需要内容。这就是渐进增加成为一种更适合的模式的关键所在。这也是Yahoo!迅速采纳这种模式并用它创建了分级浏览器支持（Graded Browser Support）策略的原因。 ##如何无刷新图片上传并且兼容1、用iframe上传在页面动态创建 form 表单和 ifram ，设定 form 表单提交的目标为 ifram ，将文件域和要 post 的参数动态写入 form 表单中，然后提交 from 表单 2、借助于flash，例如swfupload.js ##前端自动化工具的区别比如百度的fix工具和grunt工具 Grunt 是一个基于 task 的构建工具，依赖众多的插件进行配置组织，可以解决基本的前端自动化问题。FIS 是基于工具、开发框架、本地开发环境为一体的前端解决方案，不但拥有各类工具插件，同时还针对 PC、Mobile、I18n 等业务、场景总结了很多最佳实践。 Grunt的缺点 1、相对的低效：grunt各插件之间尽可能地保持独立，于是频繁的文件读写有时候就成了无奈的选择 2、缺乏有效的串联：插件A、插件B之间彼此独立，有的时候需要将插件A的输出，作为插件B的输入（如将sass编译后再内联到html里），有的时候就不得不使用临时目录来曲折地实现这个目的 接触fis是在grunt之后，有两点比较吸引的，当然就是相对于grunt来说： 1、更加高效：管道操作，避免了频繁的文件IO 2、更加灵活的配置：强大到令人发指的部署配置（当然也让人晕晕的，glob、正则混搭的规则～） ##PNG8和PNG24有什么不同 PNG8不支持半透明、PNG24支持半透明 #javascript的typeof返回那些数据类型？ Object number function boolean underfind IE和DOM事件流的区别 1.执行顺序不一样、 2.参数不一样​ 事件侦听函数的区别​ ie–&gt;attachEvent(‘事件’,事件处理函数);//两个参数​ DOM–&gt;addEventListener(‘事件’，事件处理函数,boolean);//三个参数 3.事件加不加on 4.this指向问题​ 事件绑定：addEventListener​ 与attachEvent 事件处理函数中this指向不同， IE中指向window 5 ie 捕获 html&gt;div&gt;button​ dom 先捕获 在 冒泡 html&gt;div&gt;button&gt;div&gt;html #call和apply的区别 相同: call和apply 都是为了改变函数体内this的指向的。 不同：接收参数的方式 apply ↓↓↓​ function.apply(obj,args)方法能接收两个参数​ 第一个参数 就是this的指向 这个对象代替Function类里的this对象​ args：这个数组或类数组，apply方法把这个集合中的元素作为参数传递给被调用的函数。​ call ↓↓↓​ call和apply方法的第一个参数是一样的，都是this的指向 功能和this想同​ call的第二个参数是参数列表​​ 在非严格模式下当我们第一个参数传递为null或undefined时，函数体的this会指向默认的宿主对象，​ 在浏览器中则是window​ var test = function(){ console.log(this === window); } test.apply(null);//true test.call(undefined);//true 事件委托是什么 让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！ 如何阻止事件冒泡和默认事件 阻止事件冒泡：​ stopPropagation()​ concelBubble = true //ie用 为了兼容​ 封装一个stopBubble();​ 判断浏览器 是否 有 stopPropagation()这个方法​ 如果有就调用 stopPropagation();​ 如果不存在 就 调用ie的concelBubble = “true”方法; 阻止默认事件：​ proventDefault()​ returnValue() //ie用​ 为了兼容：​ 封装一个 stopDefault();​ 判断浏览器 是否 有 proventDefalut()这个方法​ 如果有就调用 proventDefalut();​ 如果没有就使用ie的 returnValue = “false”；​ 闭包是什么，有什么特性，对页面有什么影响 闭包: 闭包的实质是一个函数，是一个用于返回局部变量值的函数， 闭包特性 : 是能够读取其他函数内部变量的函数 因为在全局中，受JavaScript链式作用域结构的影响，父级变量中无法访问到子级的变量值，为了解决这个问题，才使用闭包这个概念。 影响: 由于闭包时，变量的值都保存到内存中，会导致页面加载时内存消耗很大，IE会导致内在泄露，因此尽量少用或用时要及时删除变量。 #doccument load 和 document ready的区别 1.load是当页面所有资源全部加载完成后（包括DOM文档树，css文件，js文件，图片资源等），执行一个函数​ 问题：如果图片资源较多，加载时间较长，onload后等待执行的函数需要等待较长时间，所以一些效果可能受到影响 2.$(document).ready()是当DOM文档树加载完成后执行一个函数 （不包含图片，css等）所以会比load较快执行​ 在原生的jS中不包括ready()这个方法，只有load方法就是onload事件 ”==”和“===”的不同 ==: 比较值是否相同 前者会自动转换类型 ===: 比较值与数据类型是否相同 后者不会 #JavaScript 的数据类型都有什么？ 1 Number 数字类型 2 String 字符串类型 3 Boolean 布尔类型 4 Function 函数 5 Object 对象 6 Null 7 Undefined 没有定义类型 #简述列举文档对像模型BOM里document 的常用 的查找访问节点 的方法 并作简单 的 说明 1 通过ID,使用 getElementById() 获得标签节点 2 通过标签的名称,使用getElementsByTagName() 获得元素节点或标签节点​ 注意：以上的查找方式都会忽略文档的结构 3 通过使用一个元素节点的 parentNode、firstChild 以及 lastChild 属性 4 节点名称nodeName​ a) 如果节点是标签，nodeName是标签名称​ b) 如果节点是属性，nodeName是属性名称​ c) 如果节点是文本节点，nodeName是#text​ d) 如果节点是文档，nodeName是#document 5 节点值nodeValue 6 节点类型nodeType #简述创建函数的几种方式 1 函数声明​ :解析器会先读取函数声明，并使其在执行任何代码之前可以访问​ function sum1(n1,n2){​ return n1+n2;​ }; 2 函数表达式，又叫函数字面量​ :函数表达式则必须等到解析器执行到它所在的代码行才会真正被解释执行​ var sum2=function(n1,n2){​ return n1+n2;​ };​ 3 自执行函数严格来说也叫函数表达式​ :创建一个新的作用域，且立即执行,在此作用域内声明的变量，不会和其它作用域内的变量冲突或混淆，大多是以匿名函数方式存在​ (function(n1,n2){​ console.log (n1+n2)​ })(1,3);//4 #JavaScript如何实现继承？ 种类:六种 记住前三种 后面三种 记住名称就行 既然要实现继承，那么首先我们得有一个父类，代码如下： //定义一个动物类 function Animal (name) { this.name = name || &apos;Animal&apos;; // 属性 this.sleep = function(){ // 实例方法 console.log(this.name + &apos;正在睡觉！&apos;); } } // 原型方法 Animal.prototype.eat = function(food) { console.log(this.name + &apos;正在吃：&apos; + food); }; 一 原型链继承(推荐★★ 3 4两大致命缺陷)​ 核心: 将父类的实例作为子类的原型​ 特点:​ 1 非常纯粹的继承关系，实例是子类的实例，也是父类的实例​ 2 父类新增原型方法/原型属性，子类都能访问到​ 3 简单，易于实现​ 缺点：​ 1 要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中​ 2 无法实现多继承​ 3 来自原型对象的引用属性是所有实例共享的（详细请看附录代码： 示例1）​ 4 创建子类实例时，无法向父类构造函数传参 二 组合继承(推荐★★★★（仅仅多消耗了一点内存）)​ 核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用​ 特点：​ 1 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法​ 2 既是子类的实例，也是父类的实例​ 3 不存在引用属性共享问题​ 4 可传参​ 5 函数可复用​ 缺点：​ 1 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）​ function Cat(name){​ Animal.call(this);​ this.name = name || ‘Tom’;​ }​ Cat.prototype = new Animal();​ 三 寄生组合继承(推荐 ★★★★（实现复杂，扣掉一颗星）)​ 核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点​ 特点：​ 堪称完美​ 缺点：​ 实现较为复杂​ function Cat(name){​ Animal.call(this);​ this.name = name || ‘Tom’;​ }​ (function(){​ // 创建一个没有实例方法的类​ var Super = function(){};​ Super.prototype = Animal.prototype;​ //将实例作为子类的原型​ Cat.prototype = new Super();​ })();​ 四 构造函数(推荐★★ 缺点3)​ 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）​ 特点：​ 1 解决了1中，子类实例共享父类引用属性的问题​ 2 创建子类实例时，可以向父类传递参数​ 3 可以实现多继承（call多个父类对象）​ 缺点：​ 1 实例并不是父类的实例，只是子类的实例​ 2 只能继承父类的实例属性和方法，不能继承原型属性/方法​ 3 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能​ function Cat(name){​ Animal.call(this);​ this.name = name || ‘Tom’;​ }​ 五 实例继承(推荐★★)​ 核心：为父类实例添加新特性，作为子类实例返回​ 特点：​ 1 不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果​ 缺点：​ 1 实例是父类的实例，不是子类的实例​ 2 不支持多继承​ function Cat(name){​ var instance = new Animal();​ instance.name = name || ‘Tom’;​ return instance;​ }​ 六 拷贝继承(推荐★)​ 特点：​ 1 支持多继承​ 缺点：​ 1 效率较低，内存占用高（因为要拷贝父类的属性）​ 2 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到​ function Cat(name){​ var animal = new Animal();​ for(var p in animal){​ Cat.prototype[p] = animal[p];​ }​ Cat.prototype.name = name || ‘Tom’;​ } #JavaScript创建对象的几种方式？ 说明:很多问题 都有很多方式解决 但常用的就一两种 对其他的几种只需要理解就好了 1 对象字面量的方式{} 创建一个对象（最简单，好理解，推荐使用）​ var Cat = {};//JSON​ Cat.name=”kity”;//添加属性并赋值​ Cat.age=2;​ Cat.sayHello=function(){​ alert(“hello “+Cat.name+”,今年”+Cat[“age”]+”岁了”);//可以使用“.”的方式访问属性，也可以使用HashMap的方式访问​ }​ Cat.sayHello();//调用对象的（方法）函数 2 new方式创建对象 有参数 或无参数​ function Person(){ }​ var personOne=new Person();//定义一个function，如果有new关键字去”实例化”,那么该function可以看作是一个类​ personOne.name=”dylan”;​ personOne.hobby=”coding”;​ personOne.work=function(){​ alert(personOne.name+” is coding now…”);​ }​ personOne.work();​ 3 使用工厂方式来创建（Object关键字）​ var wcDog =new Object();​ wcDog.name=”旺财”;​ wcDog.age=3;​ wcDog.work=function(){​ alert(“我是”+wcDog.name+”,汪汪汪……”);​ }​ wcDog.work();​ 4 使用原型对象的方式 prototype关键字​ function Dog(){}​ Dog.prototype.name=”旺财”;​ Dog.prototype.eat=function(){​ alert(this.name+”是个吃货”);​ }​ var wangcai =new Dog();​ wangcai.eat();​ 5 混合模式(原型和构造函数)​ function Car(name,price){​ this.name=name;​ this.price=price;​ }​ Car.prototype.sell=function(){​ alert(“我是”+this.name+”，我现在卖”+this.price+”万元”);​ }​ var camry =new Car(“凯美瑞”,27);​ camry.sell();​ 6 动态原型的方式(可以看作是混合模式的一种特例)​ function Car(name,price){​ this.name=name;​ this.price=price;​ if(typeof Car.sell==”undefined”){​ Car.prototype.sell=function(){​ alert(“我是”+this.name+”，我现在卖”+this.price+”万元”);​ }​ Car.sell=true;​ }​ }​ var camry =new Car(“凯美瑞”,27);​ camry.sell(); #iframe的优缺点 优点：​ 1.iframe能够原封不动的把嵌入的网页展现出来。​ 2.如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。​ 3.网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。​ 4.如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。 缺点：​ 1.会产生很多页面，不容易管理。​ 2.iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。​ 3.代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会不利于搜索引擎优化。​ 4.很多的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。​ 5.iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。​ 分析了这么多，现在基本上都是用Ajax来代替iframe，所以iframe已经渐渐的退出了前端开发。 #js延迟加载的方式有哪些？ 1 使用setTimeout延迟方法的加载时间 2 让js最后加载(放在body底部) #哪些操作会造成内存泄漏？ (比较重要) 内存泄露: 一块被分配的内存既不能使用，也不能回收。从而影响性能，甚至导致程序崩溃。 起因：JavaScript的垃圾自动回收机制会按一定的策略找出那些不再继续使用的变量，释放其占有的内存。​ 然而由于一些原因导致在这种机制下内存管理器不能正确解读JavaScript变量的生命周期，从而没有释放其内存，而也没有再被使用。​ 循环引用是导致以上情况的主要原因之一。​ 1 全局变量过多​ :js中如果不用 var 声明变量,该变量将被视为 window 对象(全局对象)的属性,也就是全局变量.​ 1) function foo(arg) {​ bar = “this is a hidden global variable”;​ }​ // 上面的函数等价于 你调用完了函数以后,变量仍然存在,导致泄漏.​ function foo(arg) {​ window.bar = “this is an explicit global variable”;​ }​ 2) function foo() {​ this.variable = “potential accidental global”;​ }​ // 没有对象调用foo, 也没有给它绑定this, 所以this是window​ foo();​ 2 被遗忘的定时器或者回调​ var someResource = getData();​ setInterval(function() {​ var node = document.getElementById(‘Node’);​ if(node) {​ node.innerHTML = JSON.stringify(someResource));​ }​ }, 1000);​ 这样的代码很常见, 如果 id 为 Node 的元素从 DOM 中移除, 该定时器仍会存在, 同时,​ 因为回调函数中包含对 someResource 的引用, 定时器外面的 someResource 也不会被释放 3 没有清理的DOM元素引用​ var elements = {​ button: document.getElementById(‘button’),​ image: document.getElementById(‘image’),​ text: document.getElementById(‘text’)​ };​ function doStuff() {​ image.src = ‘http://some.url/image&#39;;​ button.click();​ console.log(text.innerHTML);​ }​ function removeButton() {​ document.body.removeChild(document.getElementById(‘button’));​ // 虽然我们用removeChild移除了button, 但是还在elements对象里保存着#button的引用​ // 换言之, DOM元素还在内存里面.​ } 4 闭包 不在使用后清空(闭包我发现其实有很多问题 不好理解 见老师 我会在问 你自己也去查一查 这个很重要) #数组方法数组方法pop() push() unshift() shift() push() 和 pop() 都是对末尾字符进行操作的push()是尾部添加操作 pop()是尾部删除push()返回的是length pop()返回的是删出的字符unshift() 和 shift() 都是对首字符进行的操作unshift()是头部添加 返回的是lengthshift()首字符删除 返回值是删除的字符. Push()尾部添加 pop()尾部删除Unshift()头部添加 shift()头部删除 #window.loction.search();返回的是什么？ window.location.search方法是截取当前url中“?”后面的字符串， 例如：index.php?act=doctor,截取后的字符串就是act=doctor window.location 对象所包含的属性 属性 描述​ hash 从井号 (#) 开始的 URL（锚）​ host 主机名和当前 URL 的端口号​ hostname 当前 URL 的主机名​ href 完整的 URL​ pathname 当前 URL 的路径部分​ port 当前 URL 的端口号​ protocol 当前 URL 的协议​ search 从问号 (?) 开始的 URL（查询部分 #JavaScript中的垃圾回收机制 内存的生命周期​ 1 当需要的时候分配内存​ 2 对内存进行读写操作​ 3 当上面分配的内存不再需要的时候，将他们释放掉 过程:​ 1 变量初始化(自动分配相应的内存空间)​ 2 函数调用时候分配空间​ 3 操作变量值 读、写、函数调用​ 4 内存不再被使用时，将它们释放掉​ 5 垃圾回收 #精度问题：JS精度不能精确到0.1 console.log(0.1+0.2); //结果为 0.30000000000000004 原因:​ 其实对于浮点数的四则运算，几乎所有的编程语言都会有类似精度误差的问题，​ 只不过在 C++/C#/Java 这些语言中已经封装好了方法来避免精度的问题，​ 而 JavaScript 是一门弱类型的语言，从设计思想上就没有对浮点数有个严格的数据类型，​ 所以精度误差的问题就显得格外突出​​ 计算机读懂的是二进制，而不是十进制，所以我们先把 0.1 和 0.2 转换成二进制结果为：​ 0.1 =&gt; 0.0001 1001 1001 1001…（无限循环）​ 0.2 =&gt; 0.0011 0011 0011 0011…（无限循环）​ 双精度浮点数的小数部分最多支持 52 位，所以两者相加之后得到这么一串很长的二进制 0.0100110011001… 因浮点数小数位的限制而截断二进制数字，这时候，我们再把它转换为十进制，就成了 0.30000000000000004。 解决办法:给出明确的精度要求，在返回值的过程中，计算机会自动四舍五入​ Math.formatFloat = function(f, digit) {​ var m = Math.pow(10, digit);​ return parseInt(f * m, 10) / m;​ }​ var numA = 0.1;​ var numB = 0.2;​ alert(Math.formatFloat(numA + numB, 1) === 0.3); #BOM对象有哪些，列举window对象 BOM:​ 1. Window 对象：表示浏览器打开的窗口，包括获取焦点、改变滚动条、设置定时器等等。​ 2. Navigator 对象：包含浏览器信息。如：获取浏览器名称、版本信息、操作系统平台信息等等。​ 3. Screen 对象：包含屏幕信息。如：获取屏幕高度、宽度等等。​ 4. History 对象：可对当前页的浏览历史进行操作，如：前进、后退等。​ 5. Location 对象：可对当前页面的URL进行操作，如：导航到新的页面、获取URL信息等​ window: (举例一些常用的就行..)​ 属性:​ closed 返回窗口是否已被关闭。​ defaultStatus 设置或返回窗口状态栏中的默认文本。​ document 对 Document 对象的只读引用。请参阅 Document 对象。​ history 对 History 对象的只读引用。请参数 History 对象。​ innerheight 返回窗口的文档显示区的高度。​ innerwidth 返回窗口的文档显示区的宽度。​ length 设置或返回窗口中的框架数量。​ location 用于窗口或框架的 Location 对象。请参阅 Location 对象。​ name 设置或返回窗口的名称。​ Navigator 对 Navigator 对象的只读引用。请参数 Navigator 对象。​ opener 返回对创建此窗口的窗口的引用。​ outerheight 返回窗口的外部高度。​ outerwidth 返回窗口的外部宽度。​ pageXOffset 设置或返回当前页面相对于窗口显示区左上角的 X 位置。​ pageYOffset 设置或返回当前页面相对于窗口显示区左上角的 Y 位置。​ parent 返回父窗口。​ Screen 对 Screen 对象的只读引用。请参数 Screen 对象。​ self 返回对当前窗口的引用。等价于 Window 属性。​ status 设置窗口状态栏的文本。​ top 返回最顶层的先辈窗口​ 方法:​ alert() 显示带有一段消息和一个确认按钮的警告框。​ blur() 把键盘焦点从顶层窗口移开。​ clearInterval() 取消由 setInterval() 设置的 timeout。​ clearTimeout() 取消由 setTimeout() 方法设置的 timeout。​ close() 关闭浏览器窗口。​ confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框。​ createPopup() 创建一个 pop-up 窗口。​ focus() 把键盘焦点给予一个窗口。​ moveBy() 可相对窗口的当前坐标把它移动指定的像素。​ moveTo() 把窗口的左上角移动到一个指定的坐标。​ open() 打开一个新的浏览器窗口或查找一个已命名的窗口。​ print() 打印当前窗口的内容。​ prompt() 显示可提示用户输入的对话框。​ resizeBy() 按照指定的像素调整窗口的大小。​ resizeTo() 把窗口的大小调整到指定的宽度和高度。​ scrollBy() 按照指定的像素值来滚动内容。​ scrollTo() 把内容滚动到指定的坐标。​ setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。​ setTimeout() 在指定的毫秒数后调用函数或计算表达式。 #js常用对象 window document location History Navigator Screen Array Date Math RegExp #怎样添加 移除 复制 创建和查找节点 创建新节点​ createDocumentFragment() //创建一个DOM片段​ createElement_x() //创建一个具体的元素​ createTextNode() //创建一个文本节点​ 添加、移除、替换、插入​ appendChild()​ removeChild()​ replaceChild()​ insertBefore()​ 查找​ getElementsByTagName() //通过标签名称​ getElementsByName() //通过元素的Name属性的值​ getElementById() //通过元素Id，唯一性 如何优化你的代码 1代码重用 2避免全局变量（命名空间，封闭空间，模块化mvc..） 3拆分函数避免函数过于臃肿 #请说出三种减低页面加载时间的方法 1、压缩css、js文件 2、合并js、css文件，减少http请求 3、外部js、css文件放在最底下 4、尽量减少dom操作，尽可能用变量替代不必要的dom操作 #解释什么是sql注入，xss漏洞 SQL:当应用程序使用输入内容来构造动态sql语句以访问数据库时，会发生sql注入攻击，如查询、插入数据时。 xss:通过插入恶意脚本，实现对用户浏览器的控制 #在JavaScript中什么是伪数组？如何将伪数组转化为标准数组 什么是伪数组:不能调用数组内置的一些属性和方法的数组(也就是假的 张的想而已) 例如:​ 这种对象有很多，比较特别的是arguments对象，还有像调用getElementsByTagName,document.childNodes之类的，​ 它们都返回NodeList对象都属于伪数组。 转化:​ 能通过Array.prototype.slice转换为真正的数组 带有length属性的对象。​ 我们可以通过Array.prototype.slice.call(fakeArray)将伪数组转变为真正的Array对象。​​ var fakeArray01 = {0:’a’,1:’b’,length:2};//这是一个标准的有伪数组对象​ var arr01 = Array.prototype.slice.call(fakeArray01);​ alert(arr01[0]);//a​ var arr02 = [].slice.call(fakeArray01);​ alert(arr02[0]);//a #列举哪些方法对前端开发进行优化？ 优化的目的:​ 1 从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。​ 2 从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。 优化方法:​ http请求过程:一个完整的请求都需要经过DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个“漫长”而复杂的过程​ 减少HTTP请求数​ 使用图片地图​ 使用CSS Sprites​ 合并JS和CSS文件​ 使用CDN(内容发布网络):当页面中有很多资源的时候,可以从不同的服务中去读取,同时可以提高并行下载速度​ 添加http Expires头:为图片视频之类很少改变的资源设置长的Expires时间将直接减少http请求​ 如果资源设置了Expires头为将来的某个时间,下次访问时候浏览器发现资源还没有过期,会直接从缓存中读取,不会 再次产生http请求​ 压缩组件:在Server端对Response资源进行压缩再传给浏览器,一般使用GZIP​ 将CSS放再顶部: 能加快页面内容显示,并且能避免页面产生白屏​ 将JS放在底部​ JS会阻塞对其后面内容的呈现​ JS会阻塞对其后面内容的下载​ 避免CSS表达式​ 将JS,CSS放在外部文件中​ 通过使用Keep-Alive和较少的域名来减少DNS查找​ 精简JS和CSS文件​ 寻找一种避免重定向的方法​ 移除重复的脚本​ 配置Etag 总结:优化这种东西 比较续 纯靠经验(自己在多去 看看 需要理解) #请说出三种减低页面加载时间的方法 1、压缩css、js文件 2、合并js、css文件，减少http请求 3、外部js、css文件放在最底下 4、尽量减少dom操作，尽可能用变量替代不必要的dom操作 简述同步和异步的区别 javascript: 是单线程机制。所谓单线程就是按次序执行，执行完一个任务再执行下一个。​ 对于浏览器来说，也就是无法在渲染页面的同时执行代码。​ 单线程机制的优点在于实现起来较为简单，运行环境相对简单。​ 缺点在于，如果中间有任务需要响应时间过长，经常会导致​ 页面加载错误或者浏览器无响应的状况。这就是所谓的“同步模式”，程序执行顺序与任务排列顺序一致。对于浏览器来说，​ 同步模式效率较低，耗时长的任务都应该使用异步模式；而在服务器端，异步模式则是唯一的模式，如果采用同步模式个人认为​ 服务器很快就会出现12306在高峰期的表现。。。。 同步: 阻塞模式 就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，​ 那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去； 异步: 非阻塞模式 是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。​ 当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。​ 例如;​ 1)回调函数callback​ 所谓回调函数，就是将函数作为参数传到需要回调的函数内部再执行。​ 典型的例子就是发送ajax请求。例如：​ $.ajax({​ async: false,​ cache: false,​ dataType: ‘json’,​ url: “url”,​ success: function(data) {​ console.log(‘success’);​ },​ error: function(data) {​ console.log(‘error’);​ }​ })​ 当发送ajax请求后，等待回应的过程不会堵塞程序运行，耗时的操作相当于延后执行。​ 回调函数的优点在于简单，容易理解，但是可读性较差，耦合度较高，不易于维护。 解释jsonp的原理，以及为什么不是真正的ajax Ajax是页面无刷新请求数据操作 动态创建script标签，回调函数 1、ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装； 2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加标签来调用服务器提供的js脚本。 3、所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。 4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。 总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变着一点！ #ajax 原理： 1.通过异步模式提升了用户体验 2.优化了浏览器和服务器之间的传输，减少不必要的数据往返减少了带宽占用 3.ajax在用户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。 Ajax不是一门新的语言，而是对现有技术的综合利用。 本质是在HTTP协议基础上的以异步的方式与服务器进行通信。 应用： 1、创建XMLHttpRequest对象，也就是创建一个异步调用对象 2、创建一个新的HTTP请求，并指定该HTTP请求的方法，URL及验证信息 3、设置响应Http请求状态变化的函数 4、发送HTTP请求 5.异步获取调用返回的数据 6.使用javascript和DOM实现DOM的局部刷新 Ajax可以实现异步通信效果，实现页面局部刷新，带来更好的用户体验；按需获取数据节约带宽资源。 #jsonp 要点：动态创建script标签，回调函数、 协议、域名、端口都相同才同域，否则都是跨域 出于安全考虑，服务器不允许用ajax跨域获取数据，但是可以跨域获取文件内容， 所以基于这一点可以动态创建script标签，使用src属性访问js文件的形式获取js脚本， 并且这个js脚本中的内容是函数调用，该函数调用的参数是服务器返回的数据， 为了获取这里参数的数据，需要事先在页面中定义回调函数，在回调函数中处理服务器返回的数据， 这就是解决跨域问题的主流解决方案 同源策略是浏览器的一种安全策略，所谓同源是指-&gt;域名 端口 协议完全 相同。 其本质是利用了标签具有可跨域的特性，由服务端返回一个预先定义好的jabascript函数的调用， 并且将服务器数据以该函数参数的形式传递过来，此方法需要前后端配合才能完成。 备注： 1前端的路上我们一起携手共进！如果转载，请标注本链接地址。 ​MIT ©杨方涛 Email:58267980@qq.com","categories":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://lzws0931.cn/categories/面试宝典/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://lzws0931.cn/tags/面试/"}]},{"title":"关于https不支持http的解决方案","slug":"关于https不支持http的解决方案","date":"2018-03-18T16:21:00.000Z","updated":"2018-03-21T02:28:03.403Z","comments":true,"path":"2018/03/19/关于https不支持http的解决方案/","link":"","permalink":"https://lzws0931.cn/2018/03/19/关于https不支持http的解决方案/","excerpt":"","text":"由于在写md的时候截图是用的微博的图床，上传到github才发现不让在其他网站使用，所有本文只有一张图片。 刚才进行网站测试的时候，微博秀这个插件不能显示出来，一直是空白，然后我把本地域名改成了127.0.0.1，显示出来了。可是部署到github以后还是显示空白，我以为是网络问题，但是检查了一下才发现报错了。 1Mixed Content: The page at ‘https://www.taobao.com/‘ was loaded over HTTPS, but requested an insecure image ‘http://g.alicdn.com/s.gif’. This content should also be served over HTTPS. 查了一下原因，显示说是现在的github是https协议了。而微博秀还是http的协议，然后通过了解可以通过ssl进行解决。但是有点麻烦，然后，我又经过查找资料。 把微博秀里面的http去掉了。写成了类似相对路径的形式。 并且查到可以在页面中加入（meta）头，为了以防万一，我进行了这两个步骤，然后部署后成功显示1&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot; /&gt; 正常显示了微博秀","categories":[{"name":"网站上线","slug":"网站上线","permalink":"https://lzws0931.cn/categories/网站上线/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://lzws0931.cn/tags/HTTP/"}]},{"title":"法门扫地僧面试宝典第二版","slug":"法门扫地僧前端面试宝典第二版","date":"2018-03-17T00:20:09.000Z","updated":"2019-01-24T05:09:29.107Z","comments":true,"path":"2018/03/17/法门扫地僧前端面试宝典第二版/","link":"","permalink":"https://lzws0931.cn/2018/03/17/法门扫地僧前端面试宝典第二版/","excerpt":"","text":"Front-End前端开发工程师面试宝典！ （本文部分有转载，不定期更新！） 前言（README.md）12本仓库是我整理的前端常见面试题，大部分由我整理，其中个别部分参考网上其他资料，感谢！ 本资料仅供大家学习参考使用！欢迎大家Star和提交issues。 NO.1 READMENO.2 简历经验分享NO.3 angular常见问题NO.4 前端面试宝典第一版NO.5 前端笔记版本第二版NO.6 前端笔记版本第三版NO.7 前端笔记版本第四版NO.8 vue常见问题 欢迎大家一起交流提高前端需要注意哪些SEO 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标 web开发中会话跟踪的方法有哪些 cookie session url重写 隐藏input ip地址 &lt;img&gt;的title和alt有什么区别 title是global attributes之一，用于为元素提供附加的advisory information。通常当鼠标滑动到元素上的时候显示。 alt是&lt;img&gt;的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。 doctype是什么,举例常见doctype及特点 &lt;!doctype&gt;声明必须处于HTML文档的头部，在&lt;html&gt;标签之前，HTML5中不区分大小写 &lt;!doctype&gt;声明不是一个HTML标签，是一个用于告诉浏览器当前HTMl版本的指令 现代浏览器的html布局引擎通过检查doctype决定使用兼容模式还是标准模式对文档进行渲染，一些浏览器有一个接近标准模型。 在HTML4.01中&lt;!doctype&gt;声明指向一个DTD，由于HTML4.01基于SGML，所以DTD指定了标记规则以保证浏览器正确渲染内容 HTML5不基于SGML，所以不用指定DTD 什么是web语义化,有什么好处web语义化是指通过HTML标记表示页面包含的信息，包含了HTML标签的语义化和css命名的语义化。HTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构css命名的语义化是指：为html标签添加有意义的class，id补充未表达的语义，如Microformat通过添加符合规则的class描述信息为什么需要语义化： 去掉样式后页面呈现清晰的结构 盲人使用读屏器更好地阅读 搜索引擎更好地理解页面，有利于收录 便团队项目的可持续运作及维护 HTTP method 一台服务器要与HTTP1.1兼容，只要为资源实现GET和HEAD方法即可 GET是最常用的方法，通常用于请求服务器发送某个资源。 HEAD与GET类似，但服务器在响应中值返回首部，不返回实体的主体部分 PUT让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档，或者，如果那个URL已经存在的话，就用干这个主体替代它 POST起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。 TRACE会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。 OPTIONS方法请求web服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。 DELETE请求服务器删除请求URL指定的资源 从浏览器地址栏输入url到显示页面的步骤(以HTTP为例) 在浏览器地址栏输入URL 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤 如果资源未缓存，发起新请求 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。 检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control： HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期 HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间 浏览器解析URL获取协议，主机，端口，path 浏览器组装一个HTTP（GET）请求报文 浏览器获取主机ip地址，过程如下： 浏览器缓存 本机缓存 hosts文件 路由器缓存 ISP DNS缓存 DNS递归查询（可能存在负载均衡导致每次IP不一样） 打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下： 客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包 客户端发送ACK=Y+1， Seq=Z TCP链接建立后发送HTTP请求 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作 服务器将响应报文通过TCP连接发送回浏览器 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下： 主动方发送Fin=1， Ack=Z， Seq= X报文 被动方发送ACK=X+1， Seq=Z报文 被动方发送Fin=1， ACK=X， Seq=Y报文 主动方发送ACK=Y， Seq=X报文 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同 如果资源可缓存，进行缓存 对响应进行解码（例如gzip压缩） 根据资源类型决定如何处理（假设资源为HTML文档） 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释 构建DOM树： Tokenizing：根据HTML规范将字符流解析为标记 Lexing：词法分析将标记转换为对象并定义属性和规则 DOM construction：根据HTML标记关系将对象组成DOM树 解析过程中遇到图片、样式表、js文件，启动下载 构建CSSOM树： Tokenizing：字符流转换为标记流 Node：根据标记创建节点 CSSOM：节点创建CSSOM树 根据DOM树和CSSOM树构建渲染树: 从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none 对每一个可见节点，找到恰当的CSSOM规则并应用 发布可视节点的内容和计算样式 js解析如下： 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素 当文档完成解析，document.readState变成interactive 所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write() 浏览器在Document对象上触发DOMContentLoaded事件 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件 显示页面（HTML解析过程中会逐步显示页面） 如何进行网站性能优化 content方面 减少HTTP请求：合并文件、CSS精灵、inline Image 减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询 避免重定向：多余的中间访问 使Ajax可缓存 非必须组件延迟加载 未来所需组件预加载 减少DOM元素数量 将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量 减少iframe数量 不要404 Server方面 使用CDN 添加Expires或者Cache-Control响应头 对组件使用Gzip压缩 配置ETag Flush Buffer Early Ajax使用GET进行请求 避免空src的img标签 Cookie方面 减小cookie大小 引入资源的域名不要包含cookie css方面 将样式表放到页面顶部 不使用CSS表达式 使用不使用@import 不使用IE的Filter Javascript方面 将脚本放到页面底部 将javascript和css从外部引入 压缩javascript和css 删除不需要的脚本 减少DOM访问 合理设计事件监听器 图片方面 优化图片：根据实际颜色需要选择色深、压缩 优化css精灵 不要在HTML中拉伸图片 保证favicon.ico小并且可缓存 移动方面 保证组件小于25k Pack Components into a Multipart Document 什么是渐进增强渐进增强是指在web设计时强调可访问性、语义化HTML标签、外部样式表和脚本。保证所有人都能访问页面的基本内容和功能同时为高级浏览器和高带宽用户提供更好的用户体验。核心原则如下: 所有浏览器都必须能访问基本内容 所有浏览器都必须能使用基本功能 所有内容都包含在语义化标签中 通过外部CSS提供增强的布局 通过非侵入式、外部javascript提供增强功能 end-user web browser preferences are respected $CSS部分CSS选择器有哪些 *通用选择器：选择所有元素，不参与计算优先级，兼容性IE6+ #X id选择器：选择id值为X的元素，兼容性：IE6+ .X 类选择器： 选择class包含X的元素，兼容性：IE6+ X Y后代选择器： 选择满足X选择器的后代节点中满足Y选择器的元素，兼容性：IE6+ X 元素选择器： 选择标所有签为X的元素，兼容性：IE6+ :link，：visited，：focus，：hover，：active链接状态： 选择特定状态的链接元素，顺序LoVe HAte，兼容性: IE4+ X + Y直接兄弟选择器：在X之后第一个兄弟节点中选择满足Y选择器的元素，兼容性： IE7+ X &gt; Y子选择器： 选择X的子元素中满足Y选择器的元素，兼容性： IE7+ X ~ Y兄弟： 选择X之后所有兄弟节点中满足Y选择器的元素，兼容性： IE7+ [attr]：选择所有设置了attr属性的元素，兼容性IE7+ [attr=value]：选择属性值刚好为value的元素 [attr~=value]：选择属性值为空白符分隔，其中一个的值刚好是value的元素 [attr|=value]：选择属性值刚好为value或者value-开头的元素 [attr^=value]：选择属性值以value开头的元素 [attr$=value]：选择属性值以value结尾的元素 [attr*=value]：选择属性值中包含value的元素 [:checked]：选择单选框，复选框，下拉框中选中状态下的元素，兼容性：IE9+ X:after, X::after：after伪元素，选择元素虚拟子元素（元素的最后一个子元素），CSS3中::表示伪元素。兼容性:after为IE8+，::after为IE9+ :hover：鼠标移入状态的元素，兼容性a标签IE4+， 所有元素IE7+ :not(selector)：选择不符合selector的元素。不参与计算优先级，兼容性：IE9+ ::first-letter：伪元素，选择块元素第一行的第一个字母，兼容性IE5.5+ ::first-line：伪元素，选择块元素的第一行，兼容性IE5.5+ :nth-child(an + b)：伪类，选择前面有an + b - 1个兄弟节点的元素，其中n&gt;= 0， 兼容性IE9+ :nth-last-child(an + b)：伪类，选择后面有an + b - 1个兄弟节点的元素其中n &gt;= 0，兼容性IE9+ X:nth-of-type(an+b)：伪类，X为选择器，解析得到元素标签，选择前面有an + b - 1个相同标签兄弟节点的元素。兼容性IE9+ X:nth-last-of-type(an+b)：伪类，X为选择器，解析得到元素标签，选择后面有an+b-1个相同标签兄弟节点的元素。兼容性IE9+ X:first-child：伪类，选择满足X选择器的元素，且这个元素是其父节点的第一个子元素。兼容性IE7+ X:last-child：伪类，选择满足X选择器的元素，且这个元素是其父节点的最后一个子元素。兼容性IE9+ X:only-child：伪类，选择满足X选择器的元素，且这个元素是其父元素的唯一子元素。兼容性IE9+ X:only-of-type：伪类，选择X选择的元素，解析得到元素标签，如果该元素没有相同类型的兄弟节点时选中它。兼容性IE9+ X:first-of-type：伪类，选择X选择的元素，解析得到元素标签，如果该元素是此此类型元素的第一个兄弟。选中它。兼容性IE9+ css sprite是什么,有什么优缺点概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案。 优点： 减少HTTP请求数，极大地提高页面加载速度 增加图片信息重复度，提高压缩比，减少图片大小 更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现 缺点： 图片合并麻烦 维护麻烦，修改一个图片可能需要从新布局整个图片，样式 display: none;与visibility: hidden;的区别联系：它们都能让元素不可见 区别： display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见 display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式 修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。 读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容 css hack原理及常用hack原理：利用不同浏览器对CSS的支持和解析结果不一样编写针对特定浏览器样式。常见的hack有1）属性hack。2）选择器hack。3）IE条件注释 IE条件注释：适用于[IE5, IE9]常见格式如下 123&lt;!--[if IE 6]&gt;Special instructions for IE 6 here&lt;![endif]--&gt; link与@import的区别 link是HTML方式， @import是CSS方式 link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUC link可以通过rel=&quot;alternate stylesheet&quot;指定候选样式 浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式 @import必须在样式规则之前，可以在css文件中引用其他文件 总体来说：link优于@import display: block;和display: inline;的区别block元素特点： 1.处于常规流中时，如果width没有设置，会自动填充满父容器2.可以应用margin/padding3.在没有设置高度的情况下会扩展高度以包含常规流中的子元素4.处于常规流中时布局时在前后元素位置之间（独占一个水平空间）5.忽略vertical-align inline元素特点 1.水平方向上根据direction依次布局2.不会在元素前后进行换行3.受white-space控制4.margin/padding在竖直方向上无效，水平方向上有效5.width/height属性对非替换行内元素无效，宽度由元素内容决定6.非替换行内元素的行框高由line-height确定，替换行内元素的行框高由height,margin,padding,border决定6.浮动或绝对定位时会转换为block7.vertical-align属性生效 PNG,GIF,JPG的区别及如何选参考资料： 选择正确的图片格式GIF: 8位像素，256色 无损压缩 支持简单动画 支持boolean透明 适合简单动画 JPEG： 颜色限于256 有损压缩 可控制压缩质量 不支持透明 适合照片 PNG： 有PNG8和truecolor PNG PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画 适合图标、背景、按钮 容器包含若干浮动元素时如何清理(包含)浮动 容器元素闭合标签前添加额外元素并设置clear: both 父元素触发块级格式化上下文(见块级可视化上下文部分) 设置容器元素伪元素进行清理推荐的清理浮动方法 1234567891011121314151617181920212223242526/*** 在标准浏览器下使用* 1 content内容为空格用于修复opera下文档中出现* contenteditable属性时在清理浮动元素上下的空白* 2 使用display使用table而不是block：可以防止容器和* 子元素top-margin折叠,这样能使清理效果与BFC，IE6/7* zoom: 1;一致**/.clearfix:before,.clearfix:after &#123; content: &quot; &quot;; /* 1 */ display: table; /* 2 */&#125;.clearfix:after &#123; clear: both;&#125;/*** IE 6/7下使用* 通过触发hasLayout实现包含浮动**/.clearfix &#123; *zoom: 1;&#125; 什么是FOUC?如何避免Flash Of Unstyled Content：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。解决方法：把样式表放到文档的head 如何创建块级格式化上下文(block formatting context),BFC有什么用创建规则： 根元素 浮动元素（float不是none） 绝对定位元素（position取值为absolute或fixed） display取值为inline-block,table-cell, table-caption,flex, inline-flex之一的元素 overflow不是visible的元素 作用： 可以包含浮动元素 不被浮动元素覆盖 阻止父子元素的margin折叠 display,float,position的关系 如果display为none，那么position和float都不起作用，这种情况下元素不产生框 否则，如果position值为absolute或者fixed，框就是绝对定位的，float的计算值为none，display根据下面的表格进行调整。 否则，如果float不是none，框是浮动的，display根据下表进行调整 否则，如果元素是根元素，display根据下表进行调整 其他情况下display的值为指定值总结起来：绝对定位、浮动、根元素都需要调整display 外边距折叠(collapsing margins)毗邻的两个或多个margin会合并成一个margin，叫做外边距折叠。规则如下： 两个或多个毗邻的普通流中的块元素垂直方向上的margin会折叠 浮动元素/inline-block元素/绝对定位元素的margin不会和垂直方向上的其他元素的margin折叠 创建了块级格式化上下文的元素，不会和它的子元素发生margin折叠 元素自身的margin-bottom和margin-top相邻时也会折叠 如何确定一个元素的包含块(containing block) 根元素的包含块叫做初始包含块，在连续媒体中他的尺寸与viewport相同并且anchored at the canvas origin；对于paged media，它的尺寸等于page area。初始包含块的direction属性与根元素相同。 position为relative或者static的元素，它的包含块由最近的块级（display为block,list-item, table）祖先元素的内容框组成 如果元素position为fixed。对于连续媒体，它的包含块为viewport；对于paged media，包含块为page area 如果元素position为absolute，它的包含块由祖先元素中最近一个position为relative,absolute或者fixed的元素产生，规则如下： 如果祖先元素为行内元素，the containing block is the bounding box around the padding boxes of the first and the last inline boxes generated for that element. 其他情况下包含块由祖先节点的padding edge组成 如果找不到定位的祖先元素，包含块为初始包含块 stacking context,布局规则z轴上的默认层叠顺序如下（从下到上）： 根元素的边界和背景 常规流中的元素按照html中顺序 浮动块 positioned元素按照html中出现顺序 如何创建stacking context： 根元素 z-index不为auto的定位元素 a flex item with a z-index value other than ‘auto’ opacity小于1的元素 在移动端webkit和chrome22+，z-index为auto，position: fixed也将创建新的stacking context 如何水平居中一个元素 如果需要居中的元素为常规流中inline元素，为父元素设置text-align: center;即可实现 如果需要居中的元素为常规流中block元素，1）为元素设置宽度，2）设置左右margin为auto。3）IE6下需在父元素上设置text-align: center;,再给子元素恢复需要的值 12345678910111213141516171819&lt;body&gt; &lt;div class=&quot;content&quot;&gt; aaaaaa aaaaaa a a a a a a a a &lt;/div&gt;&lt;/body&gt;&lt;style&gt; body &#123; background: #DDD; text-align: center; /* 3 */ &#125; .content &#123; width: 500px; /* 1 */ text-align: left; /* 3 */ margin: 0 auto; /* 2 */ background: purple; &#125;&lt;/style&gt; 如果需要居中的元素为浮动元素，1）为元素设置宽度，2）position: relative;，3）浮动方向偏移量（left或者right）设置为50%，4）浮动方向上的margin设置为元素宽度一半乘以-1 123456789101112131415161718192021&lt;body&gt; &lt;div class=&quot;content&quot;&gt; aaaaaa aaaaaa a a a a a a a a &lt;/div&gt;&lt;/body&gt;&lt;style&gt; body &#123; background: #DDD; &#125; .content &#123; width: 500px; /* 1 */ float: left; position: relative; /* 2 */ left: 50%; /* 3 */ margin-left: -250px; /* 4 */ background-color: purple; &#125;&lt;/style&gt; 如果需要居中的元素为绝对定位元素，1）为元素设置宽度，2）偏移量设置为50%，3）偏移方向外边距设置为元素宽度一半乘以-1 123456789101112131415161718192021&lt;body&gt; &lt;div class=&quot;content&quot;&gt; aaaaaa aaaaaa a a a a a a a a &lt;/div&gt;&lt;/body&gt;&lt;style&gt; body &#123; background: #DDD; position: relative; &#125; .content &#123; width: 800px; position: absolute; left: 50%; margin-left: -400px; background-color: purple; &#125;&lt;/style&gt; 如果需要居中的元素为绝对定位元素，1）为元素设置宽度，2）设置左右偏移量都为0,3）设置左右外边距都为auto 12345678910111213141516171819202122&lt;body&gt; &lt;div class=&quot;content&quot;&gt; aaaaaa aaaaaa a a a a a a a a &lt;/div&gt;&lt;/body&gt;&lt;style&gt; body &#123; background: #DDD; position: relative; &#125; .content &#123; width: 800px; position: absolute; margin: 0 auto; left: 0; right: 0; background-color: purple; &#125;&lt;/style&gt; 如何竖直居中一个元素参考资料：6 Methods For Vertical Centering With CSS。 盘点8种CSS实现垂直居中 需要居中元素为单行文本，为包含文本的元素设置大于font-size的line-height： 1234567&lt;p class=&quot;text&quot;&gt;center text&lt;/p&gt;&lt;style&gt;.text &#123; line-height: 200px;&#125;&lt;/style&gt; offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别 offsetWidth/offsetHeight返回值包含content + padding + border，效果与e.getBoundingClientRect()相同 clientWidth/clientHeight返回值只包含content + padding，如果有滚动条，也不包含滚动条 scrollWidth/scrollHeight返回值包含content + padding + 溢出内容的尺寸 XMLHttpRequest通用属性和方法 readyState:表示请求状态的整数，取值： UNSENT（0）：对象已创建 OPENED（1）：open()成功调用，在这个状态下，可以为xhr设置请求头，或者使用send()发送请求 HEADERS_RECEIVED(2)：所有重定向已经自动完成访问，并且最终响应的HTTP头已经收到 LOADING(3)：响应体正在接收 DONE(4)：数据传输完成或者传输产生错误 onreadystatechange：readyState改变时调用的函数 status：服务器返回的HTTP状态码（如，200， 404） statusText:服务器返回的HTTP状态信息（如，OK，No Content） responseText:作为字符串形式的来自服务器的完整响应 responseXML: Document对象，表示服务器的响应解析成的XML文档 abort():取消异步HTTP请求 getAllResponseHeaders(): 返回一个字符串，包含响应中服务器发送的全部HTTP报头。每个报头都是一个用冒号分隔开的名/值对，并且使用一个回车/换行来分隔报头行 getResponseHeader(headerName):返回headName对应的报头值 open(method, url, asynchronous [, user, password]):初始化准备发送到服务器上的请求。method是HTTP方法，不区分大小写；url是请求发送的相对或绝对URL；asynchronous表示请求是否异步；user和password提供身份验证 setRequestHeader(name, value):设置HTTP报头 send(body):对服务器请求进行初始化。参数body包含请求的主体部分，对于POST请求为键值对字符串；对于GET请求，为null focus/blur与focusin/focusout的区别与联系 focus/blur不冒泡，focusin/focusout冒泡 focus/blur兼容性好，focusin/focusout在除FireFox外的浏览器下都保持良好兼容性，如需使用事件托管，可考虑在FireFox下使用事件捕获elem.addEventListener(‘focus’, handler, true) 可获得焦点的元素： window 链接被点击或键盘操作 表单空间被点击或键盘操作 设置tabindex属性的元素被点击或键盘操作 mouseover/mouseout与mouseenter/mouseleave的区别与联系 mouseover/mouseout是标准事件，所有浏览器都支持；mouseenter/mouseleave是IE5.5引入的特有事件后来被DOM3标准采纳，现代标准浏览器也支持 mouseover/mouseout是冒泡事件；mouseenter/mouseleave不冒泡。需要为多个元素监听鼠标移入/出事件时，推荐mouseover/mouseout托管，提高性能 标准事件模型中event.target表示发生移入/出的元素,vent.relatedTarget对应移出/如元素；在老IE中event.srcElement表示发生移入/出的元素，event.toElement表示移出的目标元素，event.fromElement表示移入时的来源元素 sessionStorage,localStorage,cookie区别 都会在浏览器端保存，有大小限制，同源限制 cookie会在请求时发送到服务器，作为会话标识，服务器可修改cookie；web storage不会发送到服务器 cookie有path概念，子路径可以访问父路径cookie，父路径不能访问子路径cookie 有效期：cookie在设置的有效期内有效，默认为浏览器关闭；sessionStorage在窗口关闭前有效，localStorage长期有效，直到用户删除 共享：sessionStorage不能共享，localStorage在同源文档之间共享，cookie在同源且符合path规则的文档之间共享 localStorage的修改会促发其他文档窗口的update事件 cookie有secure属性要求HTTPS传输 浏览器不能保存超过300个cookie，单个服务器不能超过20个，每个cookie不能超过4k。web storage大小支持能达到5M javascript跨域通信同源：两个文档同源需满足 协议相同 域名相同 端口相同 跨域通信：js进行DOM操作、通信时如果目标与当前窗口不满足同源条件，浏览器为了安全会阻止跨域操作。跨域通信通常有以下方法 如果是log之类的简单单项通信，新建&lt;img&gt;,&lt;script&gt;,&lt;link&gt;,&lt;iframe&gt;元素，通过src，href属性设置为目标url。实现跨域请求 如果请求json数据，使用&lt;script&gt;进行jsonp请求 现代浏览器中多窗口通信使用HTML5规范的targetWindow.postMessage(data, origin);其中data是需要发送的对象，origin是目标窗口的origin。window.addEventListener(‘message’, handler, false);handler的event.data是postMessage发送来的数据，event.origin是发送窗口的origin，event.source是发送消息的窗口引用 内部服务器代理请求跨域url，然后返回数据 跨域请求数据，现代浏览器可使用HTML5规范的CORS功能，只要目标服务器返回HTTP头部Access-Control-Allow-Origin: *即可像普通ajax一样访问跨域资源 javascript有哪几种数据类型六种基本数据类型 undefined null string boolean number symbol(ES6) 一种引用类型 Object 什么闭包,闭包有什么用闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量。闭包作用域链通常包括三个部分： 函数本身作用域。 闭包定义时的作用域。 全局作用域。 闭包常见用途： 创建特权方法用于访问控制 事件处理程序及回调 应用程序存储和离线web应用HTML5新增应用程序缓存，允许web应用将应用程序自身保存到用户浏览器中，用户离线状态也能访问。1.为html元素设置manifest属性:&lt;html manifest=&quot;myapp.appcache&quot;&gt;，其中后缀名只是一个约定，真正识别方式是通过text/cache-manifest作为MIME类型。所以需要配置服务器保证设置正确2.manifest文件首行为CACHE MANIFEST，其余就是要缓存的URL列表，每个一行，相对路径都相对于manifest文件的url。注释以#开头3.url分为三种类型：CACHE:为默认类型。NETWORK：表示资源从不缓存。 FALLBACK:每行包含两个url，第二个URL是指需要加载和存储在缓存中的资源， 第一个URL是一个前缀。任何匹配该前缀的URL都不会缓存，如果从网络中载入这样的URL失败的话，就会用第二个URL指定的缓存资源来替代。以下是一个文件例子： 客户端存储localStorage和sessionStorage localStorage有效期为永久，sessionStorage有效期为顶层窗口关闭前 同源文档可以读取并修改localStorage数据，sessionStorage只允许同一个窗口下的文档访问，如通过iframe引入的同源文档。 Storage对象通常被当做普通javascript对象使用：通过设置属性来存取字符串值，也可以通过setItem(key, value)设置，getItem(key)读取，removeItem(key)删除，clear()删除所有数据，length表示已存储的数据项数目，key(index)返回对应索引的key cookie及其操作 cookie是web浏览器存储的少量数据，最早设计为服务器端使用，作为HTTP协议的扩展实现。cookie数据会自动在浏览器和服务器之间传输。 通过读写cookie检测是否支持 cookie属性有名，值，max-age，path, domain，secure； cookie默认有效期为浏览器会话，一旦用户关闭浏览器，数据就丢失，通过设置max-age=seconds属性告诉浏览器cookie有效期 cookie作用域通过文档源和文档路径来确定，通过path和domain进行配置，web页面同目录或子目录文档都可访问 通过cookie保存数据的方法为：为document.cookie设置一个符合目标的字符串如下 读取document.cookie获得’; ‘分隔的字符串，key=value,解析得到结果 12345678910document.cookie = &apos;name=qiu; max-age=9999; path=/; domain=domain; secure&apos;;document.cookie = &apos;name=aaa; path=/; domain=domain; secure&apos;;// 要改变cookie的值，需要使用相同的名字、路径和域，新的值// 来设置cookie，同样的方法可以用来改变有效期// 设置max-age为0可以删除指定cookie//读取cookie，访问document.cookie返回键值对组成的字符串，//不同键值对之间用&apos;; &apos;分隔。通过解析获得需要的值 javascript有哪些方法定义对象 对象字面量： var obj = {}; 构造函数： var obj = new Object(); Object.create(): var obj = Object.create(Object.prototype); ===运算符判断相等的流程是怎样的 如果两个值不是相同类型，它们不相等 如果两个值都是null或者都是undefined，它们相等 如果两个值都是布尔类型true或者都是false，它们相等 如果其中有一个是NaN，它们不相等 如果都是数值型并且数值相等，他们相等， -0等于0 如果他们都是字符串并且在相同位置包含相同的16位值，他它们相等；如果在长度或者内容上不等，它们不相等；两个字符串显示结果相同但是编码不同==和===都认为他们不相等 如果他们指向相同对象、数组、函数，它们相等；如果指向不同对象，他们不相等 ==运算符判断相等的流程是怎样的 如果两个值类型相同，按照===比较方法进行比较 如果类型不同，使用如下规则进行比较 如果其中一个值是null，另一个是undefined，它们相等 如果一个值是数字另一个是字符串，将字符串转换为数字进行比较 如果有布尔类型，将true转换为1，false转换为0，然后用==规则继续比较 如果一个值是对象，另一个是数字或字符串，将对象转换为原始值然后用==规则继续比较 其他所有情况都认为不相等 对象到字符串的转换步骤 如果对象有toString()方法，javascript调用它。如果返回一个原始值（primitive value如：string number boolean）,将这个值转换为字符串作为结果 如果对象没有toString()方法或者返回值不是原始值，javascript寻找对象的valueOf()方法，如果存在就调用它，返回结果是原始值则转为字符串作为结果 否则，javascript不能从toString()或者valueOf()获得一个原始值，此时throws a TypeError 对象到数字的转换步骤1. 如果对象有valueOf()方法并且返回元素值，javascript将返回值转换为数字作为结果 2. 否则，如果对象有toString()并且返回原始值，javascript将返回结果转换为数字作为结果 3. 否则，throws a TypeError &lt;,&gt;,&lt;=,&gt;=的比较规则所有比较运算符都支持任意类型，但是比较只支持数字和字符串，所以需要执行必要的转换然后进行比较，转换规则如下: 如果操作数是对象，转换为原始值：如果valueOf方法返回原始值，则使用这个值，否则使用toString方法的结果，如果转换失败则报错 经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的16位unicode值的大小） 否则，如果有一个操作数不是字符串，将两个操作数转换为数字进行比较 +运算符工作流程 如果有操作数是对象，转换为原始值 此时如果有一个操作数是字符串，其他的操作数都转换为字符串并执行连接 否则：所有操作数都转换为数字并执行加法 函数内部arguments变量有哪些特性,有哪些属性,如何将它转换为数组 arguments所有函数中都包含的一个局部变量，是一个类数组对象，对应函数调用时的实参。如果函数定义同名参数会在调用时覆盖默认对象 arguments[index]分别对应函数调用时的实参，并且通过arguments修改实参时会同时修改实参 arguments.length为实参的个数（Function.length表示形参长度） arguments.callee为当前正在执行的函数本身，使用这个属性进行递归调用时需注意this的变化 arguments.caller为调用当前函数的函数（已被遗弃） 转换为数组：var args = Array.prototype.slice.call(arguments, 0); DOM事件模型是如何的,编写一个EventUtil工具类实现事件管理兼容 DOM事件包含捕获（capture）和冒泡（bubble）两个阶段：捕获阶段事件从window开始触发事件然后通过祖先节点一次传递到触发事件的DOM元素上；冒泡阶段事件从初始元素依次向祖先节点传递直到window 标准事件监听elem.addEventListener(type, handler, capture)/elem.removeEventListener(type, handler, capture)：handler接收保存事件信息的event对象作为参数，event.target为触发事件的对象，handler调用上下文this为绑定监听器的对象，event.preventDefault()取消事件默认行为，event.stopPropagation()/event.stopImmediatePropagation()取消事件传递 老版本IE事件监听elem.attachEvent(‘on’+type, handler)/elem.detachEvent(‘on’+type, handler)：handler不接收event作为参数，事件信息保存在window.event中，触发事件的对象为event.srcElement，handler执行上下文this为window使用闭包中调用handler.call(elem, event)可模仿标准模型，然后返回闭包，保证了监听器的移除。event.returnValue为false时取消事件默认行为，event.cancleBubble为true时取消时间传播 通常利用事件冒泡机制托管事件处理程序提高程序性能。 W3C标准万维网联盟标准。 万维网联盟（外语缩写：W3C）标准不是某一个标准，而是一系列标准的集合。网页主要由三部分组成： 结构(Structure) 表现（Presentation） 行为（Behavior） 对应的标准也分三方面： 结构化标准语言主要包括XHTML和XML， 表现标准语言主要包括CSS， 行为标准主要包括对象模型（如W3C DOM）、ECMAScript等。这些标准大部分由W3C起草和发布，也有一些是其他标准组织制订的标准，比如ECMA（European Computer Manufacturers Association）的ECMAScript标准。 网页通过W3C标准的步骤： 图片的alt=””属性必须每张图片都加上,而且对齐属性用CSS来定义。不加不能通过XHTML1.0验证。 每个文档必须加上DTD声明1&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTDXHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; 去掉后能通过验证，但有警告：No DOCTYPE found! Checking with default XHTML 1.0 Transitional Document Type。 RSS的XML通过时其中的域名地址必须与检测的地址一致,否则报错. 标签的链接属性加上JAVASCRIPT事件时必须为#空链,不能为javascript:;或javascript:void(null); 同一个页面当中，同名的ID会产生冲突。所以以ID定义样式的必须改成类引用。 1&lt;div id=&quot;a1&quot;&gt;111&lt;/div&gt; &lt;div id=&quot;a1&quot;&gt;222&lt;/div&gt; 如果不用W3C来检测的话，在CSS设计里是允许这样做的。 那是程序的角度不能相同，CSS上是可以相同的! 之前就是相同的产生问题，后面就改成类引用了!(简单的说就是id必须要是单一的不能重复 如果重复就使用class) 不可以省略双引号或者单引号 标签之间不可错位嵌套。123456&lt;div class=&quot;CaseDetaListSS&quot;&gt;原文链接：&lt;a href=&apos;/html/cases/cases_61.html&apos;&gt;官方网站&lt;/div&gt;&lt;/a&gt; 不允许这样。 所有标签必须都使用小写 FLASH的标签代码中不能含有,必须采用其它的方法实现。 所有的标签中含有的属性必须有值(官方的说法)。 标签必须配对完成,单标签必须以/关闭 JS和CSS外部引入文件必须加上类型定义: 12&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;style type=&apos;text/css&apos;&gt;&lt;/style&gt; 所有的样式全部写在外部文件。用类名定义。在使用的地方引用。 页面上的一些特殊字符必须用HTML代码来标识.如“&amp;”写成“&amp;“ 显示结果 说明 Entity Name Entity Number 空格 | ```&#160;``` |123456789101112131415161718192021| &lt; | 小于 | ```&amp;lt;``` | ```&amp;#60;``` || &gt; | 大于 | ```&amp;gt;``` | ```&amp;#62;``` || &amp; | &amp;符号 | ```&amp;amp;``` | ```&amp;#38;``` || &quot; | 双引号 | ```&amp;quot;``` | ```&amp;#34;``` || x | 乘号 | ```&amp;times;``` | ```&amp;#215;``` || ÷ | 除号 | ```&amp;divide;``` | ```&amp;#247;``` |## HTML5的备忘录##### HTML5是现在前端开发人员必备技能。&gt; HTML本来不会活过21世纪的。网页规范的制定者W3C组织，早在1998年就已经对HTML撒手不管了。W3C把未来都寄托在**XHTML**这个更具现代特色的后续规范上，XHTML被视为HTML的严肃整洁版，但XHTML举步维艰。当XHTML举步维艰的时候，有那么一群人\\(来自欧朋\\(OPera\\)\\/火狐\\(fireFox\\)\\/苹果\\(safari\\)的一些具有开发者自行组建了WHATWG\\(Web Hypertext Application Technology Working Group超文本应用技术工作组\\)\\)开始寻找新的解决方案，这就奠定了HTML5的的前身。**HTML5诞生于2004年****HTML5的规范正式公布于2014年**### 首先是HTML5的结构* 文档类型声明 &lt;!DOCTYPE HTML&gt; //相比于html4除去了约束和版本号 12* 字符编码 //声明字符集的编码 12345678910111213141516171819202122232425262728293031* HTML5的语法规则相比较HTML4更加松散* 总结： * 如何区分HTML和HTML5？ **html5的文档声明去除了约束和版本号，html5的字符编码更加简洁** * DOCTYPE是什么？ **DOCTYPE是文档类型声明** * HTML5有哪些新特性？ **新增了语义化标签,多媒体,地理定位,离线存储,canvas**#### 在开始H5的新特性之前先提一下腻子脚本(polyfill)以及IE版本条件注释 * **IE条件注释功能是条件注释是IE特有的一种功能，能对IE系列产品进行单独的XHTML代码处理，注意，主要是针对XHTML,而非CSS。条件注释功能非常强大，可以进行true和false判断。** * **主要是针对ie6 7 8对支持和让老浏览器支持html5+css3的一些js脚本** **所以这两个东西肯定都是为了兼容老版本的IE浏览器的**语法如下：lte：就是Less than or equal to的简写，也就是小于或等于的意思。lt ：就是Less than的简写，也就是小于的意思。gte：就是Greater than or equal to的简写，也就是大于或等于的意思。gt ：就是Greater than的简写，也就是大于的意思。! ：就是不等于的意思，跟javascript里的不等于判断符相同 123456789101112131415161718192021222324252627282930313233343536373839404142### 然后下面开始是HTML5的新特性：* 新的语义化标签 * 语义化标签的含义？ **答:通过标签就能明白标签中所包含的内容的这样的标签** * 使用语义化标签的好处 1. **可以让文档更加清晰简洁** 2. **可以让开发者更加容易修改和维护** 3. **可以让索搜引擎和残障人士更好的获取网页信息*** 新增了哪些语义化标签 * 主要的： **Headerd** 定义section或page的页眉-----页面的头部 **Nav** 定义导航链接.一般定义导航 **main** 定义主要区域 **section** 定义文档中的节 **aside** 定义内容之外的内容，侧边栏 **footer** 定义section或者page的页脚 * 提问使用这些新的语义化标签跟我们之前使用div有什么区别？ **为了被搜索引擎更好的检索** **为了浏览器实现特定功能（比如阅读功能）** **便于编程人员理解（即使是html5，光靠标签的语义也不够，还是要靠id、name甚至class的css命名来综合体现）** * 次要的： Article 定义文章 Mark 定义有记号的文本 Figure 定义媒介内容的分组,以及它们的标题 figcaption 定义figure元素的标题 details 定义元素的细节 summary 定义可见的&amp;lt;details&amp;gt;元素标题 progress 定义任何类型的任务的进度====&amp;gt;进度条* 新的表单**input 类型 -email邮箱类型 ** ; ; 12**input 类型 -url 网址** ; ;12** input 类型 -search 搜索框** ; t;12input 类型 - number\\(value,max,min,step\\(数字的间隔\\)\\) &lt;lable&gt; &lt;input type=&quot;number&quot; name = &quot;number&quot; class = &quot;number&quot; min=&quot;0&quot; max = &quot;100&quot; step = &quot;2&quot;&gt; &lt;/lable&gt; 12input 类型 -range\\(value,max,min,step\\)滑块 &lt;lable&gt; &lt;input type=&quot;range&quot; name = &quot;range&quot; class = &quot;range&quot; min=&quot;2&quot; max=&quot;100&quot; step=&quot;2&quot;&gt; &lt;/lable&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613**Input 类型 - Date Pickers（time, date, month, week, datetime-local）*** 多媒体（视频与音频）* Canvas绘图* 数据存储* 离线应用* 地理定位* 酷炫狂拽屌炸天的CSS特效### SGML HTML XML 之间有什么关系？ SGML:（标准通用标记语言） SGML 是一个标准，告诉我们怎么去指定文档标记。他是只描述文档标记应该是怎么样的元语言，HTML是被用SGML描述的标记语言。 现在解析SGML是一件痛苦的事情，所以创建了XML使事情更好。XML使用了SGML， 例如：在SGML中你必须使用起始和结束标签，但是在XML你可以有自动关闭的结束标签。 XHTML创建于XML，他被使用在HTML4.0中。你可以参考下面代码片段中展示的XML DTD 总之，SGML是所有类型的父类，较旧的HTML利用SGML，HTML4.0使用派生自XML的XHTML 因此利用SGML创建了HTML参照和必须共同遵守的DTD，你会经常在HTML页面的头部发现“DOCTYPE”属性， 用来定义用于解析目标DTD HTML5:（超文本标记语言） HTML5是最新的HTML标准，他的主要目标是提供所有内容而不需要任何的像flash，silverlight等的额外插件， 这些内容来自动画，视频，富GUI等 HTML5是万维网联盟（W3C）和网络超文本应用技术工作组（WHATWG）之间合作输出的 XHTML xhtml与html严格意义上其实没什么区别，xhtml1.0的开发实际上是作为html4.01与xml2.0的一个过渡的网页版本而存在的， 因为xml的解析语法过于苛刻，简单一句话就是：只要网页中出现一处错误，则浏览器停止解析。 XML:（可扩展标记语言） 自定义XML+XSLT=&gt;HTML，最常见的文档型应用之一。XML存放整个文档的XML数据，然后XSLT将XML转换、 解析，结合XSLT中的HTML标签，最终成为HTML，显示在浏览器上。典型的...### xhtml和html有什么区别 HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言 最主要的不同： XHTML 元素必须被正确地嵌套。 XHTML 元素必须被关闭。 标签名必须用小写字母。 XHTML 文档必须拥有根元素。### Canvas和SVG 异同 相同: 1 都是html5支持的两种可视化技术。基于这两种技术，诞生了很多可视化工具 2 这两种方式在功能上是等同的，任何一种都可以用另一种来模拟。它们都是有效的图形工具， 可用来快速创建在网页中显示的轻型图形；它们都使用 JavaScript 和 HTML；它们都遵守万维网联合会 (W3C) 标准 3 都允许您在浏览器中创建图形，但是它们在根本上是不同的。它们很不相同，他们各有强项和弱点 不同: 1 Canvas 通过JavaScript来绘制2D图形。Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。 如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象 SVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形 2 Canvas 是基于像素的即时模式图形系统，最适合较小的表面或较大数量的对象，Canvas不支持鼠标键盘等事件。 SVG 是基于形状的保留模式图形系统，更加适合较大的表面或较小数量的对象。Canvas和SVG在修改方式上还存在着不同。 绘制Canvas对象后，不能使用脚本和 CSS 对它进行修改。因为 SVG 对象是文档对象模型的一部分，所以可以随时使用脚本和 CSS 修改它们。 3 Canvas 1)依赖分辨率 2)不支持事件处理器 3)弱的文本渲染能力 4)能够以 .png 或 .jpg 格式保存结果图像 5)最适合图像密集型的游戏，其中的许多对象会被频繁重绘 SVG 1)不依赖分辨率 2)支持事件处理器 3)最适合带有大型渲染区域的应用程序（比如谷歌地图） 4)复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快） 5)不适合游戏应用### 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ 行内元素：a b span img input select strong 块级元素：div ul ol li dl dt dd h1 h2 h3 h4 p 空元素：&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;link&gt; &lt;meta&gt;### 页面导入样式时，使用link和@import有什么区别？ 1）link属于XHTML标签，而@import是css提供的； 2）页面被加载时，link会同时被加载，而@import引用的css会等到页面被加载完再加载； 3）@import只在IE5以上才能识别，而link是XHTML标签，无兼容问题； 4）link方式的样式的权重高于@import的权重。### html5 新增和移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？ 新特性，新增元素： 1）内容元素：article、footer、header、nav、section 2）表单控件：calendar、date、time、email、url、search 3）控件元素：webworker，websockt，Geolocation 移除元素： 1）显现层元素：basefont，big，center，font，s，strike，tt，u 2）性能较差元素：frame，frameset，noframes 处理兼容问题有两种方式： 1）IE6/IE7/IE8支持通过document方法产生的标签，利用这一特性让这些浏览器支持HTML5新标签。 2）使用是html5shim框架 另外，DOCTYPE声明的方式是区分HTML和HTML5标志的一个重要因素，此外，还可以根据新增的结构，功能元素来加以区分。### 如何区分 HTML 和 HTML5？ 1）在文档类型声明上不同： HTML是很长的一段代码，很难记住，遵守dtd约束 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt; 而HTML5却只有简简单单的声明，方便记忆。只需要DOCTYPE来规范浏览器的行为 &lt;!DOCTYPE html&gt; 2）在结构语义上不同： HTML：没有体现结构语义化的标签，通常都是这样来命名的&lt;div id=&quot;header&quot;&gt;&lt;/div&gt;，这样表示网站的头部。 HTML5：在语义上却有很大的优势。提供了一些新的标签，比如：&lt;header&gt;&lt;article&gt;&lt;footer&gt; 一个典型的WEB页面包含头部，脚部，导航，中心区域，侧边栏。现在如果我们想在在HTML4的HTML区域中呈现这些内容，我们可能要使用DIV标签。 但是在HTML5中通过为这些区域创建元素名称使他们更加清晰，也使得你的HTML更加可读### html5有哪些新特性 canvas(画布) audio 定义音频内容 video 定义视频（video 或者 movie） 地理定位 web存储 :localStorage 拖拽控制: draggable=&quot;true&quot; 使元素可拖动，把 draggable 属性设置为 true ： 表单 &lt;datalist&gt; 定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。 &lt;keygen&gt; 规定用于表单的密钥对生成器字段。 &lt;output&gt; 定义不同类型的输出，比如脚本的输出。### 请解释一下什么是语义化的HTML。 1 含义:内容使用特定标签，通过标签就能大概了解整体页面的布局结构（在什么情况下我可以使用这个标签才合理） 2 为什么使用语义化标签? 1）用正确的标签做正确的事情； 2）html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析； 3）即使在没有css样式情况下也以一种文档格式显示，并且是容易阅读的； 4）搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO； 5）使于读源代码的人对网站更容易将网站分块，便于阅读维护理解。 3 html语义标签 p 段落 strong和em 加粗 (但strong字面含义更强 推荐 见名知意 也是语义化标签的含义之所在) ul 有序列表用 ol 无序列表用... 4 html5 新增语义话标签 1)header(页眉): 标签:定义文档的页面组合，通常是一些引导和导航信息 2)footer(页脚): 标签:定义 section(章节) 或 document 的页脚。 3)nav(导航): 标签:导航链接放在nav标签里。 4)article(文章): 装载显示一个独立的文章内容 内层的artilce对外层的article标签有隶属的关系 &lt;article&gt; &lt;h1&gt;文章标题&lt;/h1&gt; 这是一篇文章 &lt;article&gt;评论1...&lt;/article&gt; &lt;article&gt;评论2...&lt;/article&gt; &lt;/article&gt; 5)section(章节): 使用内部article去定义区域或者把分组内容放到区域里 &lt;section&gt; &lt;h1&gt;章节一&lt;/h1&gt; &lt;p&gt;详细内容...&lt;/p&gt; &lt;/section&gt; &lt;section&gt; &lt;h1&gt;章节二&lt;/h1&gt; &lt;p&gt;详细内容...&lt;/p&gt; &lt;/section&gt; 6)mark(标记): 标签:定义带有记号的文本。请在需要突出显示文本时使用 &lt;mark&gt; 标签.... 7)&lt;aside&gt;：代表页面的侧边栏内容 总结:1 让对方知道你清楚语义化标签含义 2 让对方知道你清楚为什么用语义化标签 5 让对方知道你了解html5新增了一些语义化标签(举几个语义化标签就行不用全说 因为实际开发也不一定用 ) 是否是新手 回答问题就能听出来 新手问啥答啥 老鬼 会测出一堆相关问题 这也是他们为什么能聊那么长时间### DOCTYPE作用? 严格模式与混杂模式如何区分？它们有何意义? 1）&lt;!Doctype&gt;作用是告诉浏览器 我的html使用的那个版本的html协议写的 让浏览器按照声明的协议执行 2）严格模式的排版和JS运作模式是以该浏览器支持的最高标准运行。 3）混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 4）DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。 ### iframe有那些缺点？ iframe的优点： 1.iframe能够原封不动的把嵌入的网页展现出来。 2.如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。 3.网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的复用性。 4.如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。 iframe的缺点： 1.会产生很多页面，不容易管理。 2.iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条， 会分散访问者的注意力，用户体验度差。 3.代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容， 所以使用iframe会不利于搜索引擎优化。 4.很多的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。 5.iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。 总结:分析了这么多，现在基本上都是用Ajax来代替iframe，所以iframe已经渐渐的退出了前端开发。###常见兼容性问题？ 1）png24位的图片在IE6浏览器上出现背景； 解决方案是：做成PNG8； 2）浏览器默认的 margin 和 padding 不同。 解决方案是：加一个全局的*&#123;margin:0;padding:0;&#125;来统一。 3）IE6双边距bug：块属性标签float后，又有横行的 margin 情况下，在 IE6 显示 margin 比设置的大。 浮动IE产生的双倍距离 #box&#123;float:left;width:10px;margin:0 0 0 100px;&#125; 这种情况下IE6会产生200px的距离。 解决方法：加上_display：inline，使浮动忽略 4）IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute()获取自定义属性； 使用获取常规属性的方法来获/取自定义属性：getElementbyId(&quot;#box&quot;).Attributes[&quot;属性名&quot;] Firefox下，只能使用getAttribute()获取自定义属性。 解决方法：统一通过getAttribute()获取自定义属性。 5）IE下，even对象有x，y属性，但是没有pageX，pageY属性， 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。 6）Chrome中文界面下默认会将小于 12px 的文本强制按照 12px 显示 解决方法：可通过加入 CSS 属性 -webkt-text-size-adjust:none;解决 7）超链接访问过后 hover 样式就不出现了，被点击访问过的超链接样式不在具有 hover 和 active ； 解决方法：改变CSS属性的排列顺序：L-V-H-A: a:link&#123; &#125; a:visited&#123; &#125; a:hover&#123; &#125; a:active&#123; &#125; ### 支持HTML5新标签 1)IE8/IE7/IE6支持通过 document.createElement 方法产生的标签， 可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式； 2)当然最好的方式是直接使用成熟的框架、使用最多的是 html5shim 框架 针对IE浏览器比较好的解决方案是html5shiv。html5shiv主要解决HTML5提出的新的元素不被IE6-8识别， 这些新元素不能作为父节点包裹子元素，并且不能应用CSS样式。让CSS 样式应用在未知元素上只需执行 document.createElement(elementName) 即可实现。html5shiv就是根据这个原理创建的。 html5shiv的使用非常的简单，考虑到IE9是支持html5的，所以只需要在页面head中添加如下代码即可： &lt;!--[if lt IE 9]&gt; &lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; &lt;![endif]--&gt;### 简述一下src与href的区别： href: &lt;link href=”common.css” rel=”stylesheet”/&gt; 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。 src: &lt;script src =”js.js”&gt;&lt;/script&gt; 是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内， 例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理， 直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。 这也是为什么将js脚本放在底部而不是头部。### 浏览器的内核分别是什么? IE: trident 内核 Firefox：gecko内核 Safari：webkit内核 (苹果浏览器) Opera：以前是presto内核，Opera现已改用Google Chrome的Blink内核 Chrome：Blink(基于webkit，Google与Opera Software共同开发)### HTML5 中如何嵌入音频？ HTML5 支持 MP3、Wav 和 Ogg 格式的音频，下面是在网页中嵌入音频的简单示例： &lt;audio controls&gt; &lt;source src=”jamshed.mp3″ type=”audio/mpeg”&gt; Your browser does’nt support audio embedding feature. &lt;/audio&gt; ### HTML5 中如何嵌入视频？ HTML5 支持 MP4、WebM 和 Ogg 格式的视频，下面是简单示例： &lt;video width=”450″ height=”340″ controls&gt; &lt;source src=”jamshed.mp4″ type=”video/mp4″&gt; Your browser does’nt support video embedding feature. &lt;/video&gt; ### HTML5 存储类型有什么区别？ HTML5 能够本地存储数据，在之前都是使用 cookies。 HTML5 提供了下面两种本地存储方案： localStorage 用于持久化的本地存储，数据永远不会过期，关闭浏览器也不会丢失。 sessionStorage 同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储### HTML5 标准提供了哪些新的 API？ HTML5 提供的应用程序 API 主要有： Media API Text Track API Applocation Cache API User Interaction Data Transfer API Command API Constraint Validation API History API### 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ cookie: Cookie是在你浏览网页的时候，网站服务器放在客户端（Client End，就是你的电脑）里面的一个小小的TXT文件。 这个文件里面存储了一些与你访问的这个网站有关的一些东西，当你下一次访问这个网站的时候， Cookie就会记住你上次访问时候的一些状态或者设置，让服务器针对性的发送页面的相关内容。 Cookie里面包含的信息并没有一个标准的格式，各个网站服务器的规范都可能不同，但一般会包括： 所访问网站的域名（domain name），访问开始的时间，访问者的IP地址等客户端信息，访问者关于这个网站的一些设置等等 sessionStorage: 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。 因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储 localStorage: 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 web storage和cookie的区别: Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的， 并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。 除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。 但是Cookie也是不可或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生### 为什么利用多个域名来存储网站资源会更有效？ CDN缓存更方便 cnd：服务器 突破浏览器并发限制 节约cookie带宽 节约主域名的连接数，优化页面响应速度 防止不必要的安全问题### img的alt与title有何异同？ strong与em的异同？ alt 是图片加载失败时，显示在网页上的替代文字； title 是鼠标放上面时显示的文字。 strong:粗体强调标签，强调，表示内容的重要性 em:斜体强调标签，更强烈强调，表示内容的强调点### 你能描述一下渐进增强和优雅降级之间的不同吗? 渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始， 并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。 优雅降级: 观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段， 并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。 渐进增强: 观点则认为应关注于内容本身。 内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作， 还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。 这也是它立即被 Yahoo! 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在### 知道的网页制作会用到的图片格式有哪些？ png-8，png-24，jpeg，gif，svg。 但是上面的那些都不是面试官想要的最后答案。面试官希望听到是Webp。（是否有关注新技术，新鲜事物） 科普一下Webp：WebP格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3， 并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。 在质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小40%### 介绍一下 CSS 的盒子模型？ 1）有两种，IE 盒子模型、标准 W3C 盒子模型； IE 的 content 部分包含了 border 和 padding； 2）盒模型：内容（content）、填充（padding）、边界（margin）、边框（border）。### CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3 新增伪类有哪些？ 1）id 选择器（#myid） 2）类选择器（.myclassname） 3）标签选择器（div，h1，p） 4）相邻选择器（h1 + p） 5）子选择器（ul &gt; li） 6）后代选择器（li a） 7）通配符选择器（* ） 8）属性选择器（ a[rel = &quot;external&quot;]） 9）伪类选择器（a: hover, li: nth - child）### 可继承的样式： font-size font-family color, UL LI DL DD DT### 不可继承的样式： border padding margin width height### 载入样式以最后载入的定位为准; 优先级为: !important &gt; id &gt; class &gt; tag ； important 比 内联优先级高 ### 如何居中div？ 给div 设置一个宽度，然后添加 margin:0 auto 属性；div&#123;width:200px; margin:0 auto; &#125;### 如何居中一个浮动元素？ 确定容器的宽高 宽500 高300的层，设置层的外边距(走自己的一半 1/2宽高) .div&#123;width:500px;height:300px;margin:-150px 0 0 -250px; position:relative;background:green；left：50%；top：50%&#125;### css3有哪些新特性？ CSS3 实现圆角（border-radius:8px;）， 阴影（box-shadow:10px）, 对文字加特效（text-shadow）, 线性渐变（gradient）， 旋转（transform） transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转，缩放，定位，倾斜 增加了更多的 css 选择器 多背景 rgba### display:inline-block 什么时候会显示间隙？ display:inline-block布局的元素在chrome下会出现几像素的间隙， 原因是因为我们在编辑器里写代码的时候，同级别的标签不写在同一行以保持代码的整齐可读性， 即inline-block布局的元素在编辑器里不在同一行，即存在换行符， 因此这就是著名的inline-block“换行符/空格间隙问题”。 如果inline-block元素间有空格或是换行产生了间隙，那是正常的，应该的。 如果没有空格与间隙才是不正常的（IE6/7 block水平元素）。 1.给 li 写font-size:0 2.把li标签写到一行，不要在编辑器里敲回车换行，但是这种写法对于标签很多的情况可读性太差， 适用与例如&lt;a&gt;&lt;/a&gt;&lt;a&gt;&lt;/a&gt;这样简单的结构 3.把li的标签改成这样的写法 &lt;li&gt; &lt;span&gt;...&lt;/span&gt; &lt;/li&gt;&lt;li&gt; &lt;span&gt;...&lt;/span&gt; &lt;/li&gt; 移除空格，使用margin 负值、使用 font-size:0、letter-spacing 、word-spacing ### 什么是盒子模型？ 在网页中，一个元素占有空间的大小由几个部分构成，其中包括 元素的内容（content） 元素的内边距（padding） 元素的边框（border） 元素的外边距（margin） 四个部分。 box-sizing: border-box;/*无论是加 border 还是padding 盒子的总体大小都不会改变*/ 这四个部分占有的空间中，有的部分可以显示相应的内容， 而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。### px和em的区别 px: 的值是固定的，指定是多少就是多少，计算比较容易。 em: 得值不是固定的，并且em会继承父级元素的字体大小。 浏览器的默认字体高都是16px。 所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em rem: 是相对于根元素文字大小的一个尺寸单位； 例如：html&#123;font-size：50px;&#125; div&#123;font-size:0.5rem;&#125;/*div中字体大小为：25；### rgba() 和 opacity的透明度效果有什么不同? opacity作用于元素, 以及元素内所有的内容. raba()只作用与元素的颜色或背景色(子元素不会继承透明度效果)### css设置dom元素不显示浏览器可视范围 基本方式: 1 display:none 2 visibility:hidden 技巧性: 3 宽高0 4 透明度0 5 z-index:-100 6 定位出浏览器可视范围### 行内node与块级node区别 行内node是否可以设置padding和maring 行内:display:inline 同站一行 宽高 内外边距的top/bottom都不可以设置, 但是 内外边距的left/right可以设置 块级:display:block 独占一行 可以设置 可以设置宽高 内外边距... 行内块:inline-block 拥有内在尺寸 可设置宽高 单依然不会自动换行 行内快标签: input,img,button,texterea,label### 去除a标签跳转效果 &lt;a href =&quot;javascript:return false;&quot;&gt;这个链接不能点击 &lt;/a&gt; &lt;a href =&quot;javascript:volid(0);&quot;&gt;### css那些属性可以继承 可以: font-size, font-family, color, ul, li, dl, dd, dt 不行: border, padding, margin, width, height### css优先级算法如何计算 !important &gt; id &gt; class &gt; 标签 !important 比 内联优先级高 *优先级就近原则 样式定义最近者为准 *以最后载入的样式为准 1：直接设置 color：red; 2：十六进制方式 color：#00ff; 3: rgb设置 color：rgb(0-255,0-255,0-255); red green blue 4: rgba color:rgba(0-255,0-255,0-255,0-255,0.1);### css有3种书写方式 1 ：外联式：：新建css 内部引用 &lt;link href=&quot;css 文件路径&quot; rel=&quot;&quot;&gt; （主要写法 推荐） 1）：该写法影响范围比较广，整个站点 2）：完全实现了html结构与样的分离（代码可维护性比较好） 2 ：内嵌式 ：在头部的style 中书写 1）：只会影响当前页面样式的改变 2）：没有实现html结构与样式的完全分离 3 ：行内式写法 ：直接在标签内些style 1）：影响只有当前标签 2）：没有实现html结构与样式的分离### css的特性： 1 层叠行： 当同一个标签（权重一样）的样式发生冲突的时候，最后定义的样式会将前面定义的样式覆盖掉（层叠性）。 与样式定义的顺序有关，和样式调用的顺序无关 2 继承性：标签之间的关系属于嵌套关系 可以被继承的属性：有关文字的相关属性都可以被集成 如 颜色 大小 行高 字体 注意：1 a标签不能直接使用父元素中的文字颜色。 2 标题标签不能直接使用父元素中的文字大小。 ### 伪类 ：用来向选择器定义样式或添加特定的效果.常用的伪类还有focus nth-child等 1 a:link &#123;属性: 值;&#125; 设置a标签默认样式 2 a:visited &#123;属性: 值;&#125; 链接访问过后的样式 3 a:hover &#123;属性: 值;&#125; 鼠标移动到超链接上的样式 4 a:active &#123;属性: 值;&#125; 链接激活状态下的样式 注意:link :visited :hover :active（L oVe H A te顺序）爱 与 恨 (顺序书写) 可以解决 a标签在四种状态中出现的小问题 5 a:focus&#123;属性: 值;&#125; 获取光标焦点的样式 6 :first-child 向元素的第一个子元素添加样式 7 :last-child 向元素的最后一个子元素添加样式### CSS3新增伪类举例： p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素； p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素； p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素； p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素； p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素； :enabled :disabled 控制表单控件的禁用状态； :checked 单选框或复选框被选中。### 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）：输入地址1.浏览器查找域名的 IP 地址2.这一步包括 DNS 具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存…3.浏览器向 web 服务器发送一个 HTTP 请求4.服务器的永久重定向响应5.浏览器跟踪重定向地址6.服务器处理请求7.服务器返回一个 HTTP 响应8.浏览器显示 HTML9.浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）10.浏览器发送异步请求 ### Overflow的用法 1 overflow：hidden 将超出盒子部分的内容隐藏 2 overflow：scorll 添加滚动条 3 overflow：auto 自适应 ### 定位(position) : 定位的元素常与具体的方位名称配合使用 left top right bottom 1 静态定位(static) 页面中的标准流下的盒子，都是静态定位的盒子 2 绝对定位(absolute) （看脸型） ---- 脱标------ 不占位 ----- 实现模式转换 1 父元素没有设置定位，子元素设置绝对定位，子元素是以浏览器左上角为基准设置定位。 2 父元素设置了定位，子元素设置绝对定位会以父元素左上角为基准设置定位 3 元素设置了绝对定位后，该元素不占位置（脱离标准流） 4 绝对定位可以实现模式转换 3 相对定位 (relative) （自恋型）---- 未脱标------ 占位 ----- 不能实现模式转换 1 如果一个元素设置了相对定位，那么该元素会以自己原来的位置为基准设置定位 2 设置了相对定位的元素，该元素占位置（没有脱标） 3 设置了相对定位的元素，不能实现模式转换 4 一般情况下，设置子绝父相 4 固定定位(fixed) ---- 脱标------ 不占位 ----- 实现模式转换 1 设置了固定位的元素 只会看浏览器的左上角 2 设置了固定位的元素 脱离了标准流 不占位置 3 固定定位的元素实现了模式转换### Z-index(层级) 1 元素与元素之间的层级关系 2 在css2中，只有定位的元素才有z-index 3 默认情况下，定位的元素z-index的值auto (0) Z-index可以取正数还可以取负数。 特点: 1 如果两个元素都设置了定位，那么后面定位的元素会覆盖前面定位的元素（后来居上） 2 如果想让一个盒子压另一个盒子，可以设置z-index值。 3 如果元素的父元素设置了z-index值，那么程序会以父元素的z-index值为准### vue生命周期钩子 1.beforcreate 2.created 3.beformount 4.mounted 5.beforeUpdate 6.updated 7.actived 8.deatived 9.beforeDestroy 10.destroyed### js跨域请求的方式，能写几种是几种 1、通过jsonp跨域 2、通过修改document.domain来跨子域 3、使用window.name来进行跨域 4、使用HTML5中新引进的window.postMessage方法来跨域传送数据（ie 67 不支持） 5、CORS 需要服务器设置header ：Access-Control-Allow-Origin。 6、nginx反向代理 这个方法一般很少有人提及，但是他可以不用目标服务器配合，不过需要你搭建一个中转nginx服务器，用于转发请求 ### 对前端工程化的理解 开发规范 模块化开发 组件化开发 组件仓库 性能优化 项目部署 开发流程 开发工具 ### js设计模式 总体来说设计模式分为三大类： 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模### iframe有那些缺点？ iframe会阻塞主页面的Onload事件； 搜索引擎的检索程序无法解读这种页面，不利于SEO; iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。### css容易混淆属性 text-indent: 2em; /* 设置首行缩进两个汉字 Logo优化内容移除*/ text-align: center; /* text-align给块级元素设置，其文本会水平居中 */ text-decoration: none; /*去掉下划线*/ font-style: italic ; /* 文字斜体显示*/ font-weight: 700; /* 文字加粗显示*/ line-height: 20px; /* 设置文字的行高*/ line-break: normal; /*应用日文文本的默认换行规则*/ list-style: none; /* 去除列表前面的图标*/ disabled:true; /*禁用文本框*/ disabled:false; /*解禁文本框*/ outline-style: none; /* 去掉输入框的默认轮库线*/ overflow: hidden; /*1 触发元素的bfc(格式化上下文) 解决外边距塌陷问题 2 将多余部分隐藏 可设置 水平 垂直方向的如 ： overflow-x: hidden; overflow-y: hidden; 3 给父元素这是 可以清楚浮动 * * */ overflow: auto; /*给添加滚动条 可设置水平 */ overflow：hidden； /*超出的部分隐藏 */ visibility：hidden； /*元素隐藏 该属性隐藏元素后，元素占位置*/ display：none: ; /*元素隐藏 隐藏元素不占位置*/ display: block; /*显示元素*/ display: inline; /* 转化为 行*/ display: block; /* 转化为 块*/ vertical-align: baseline /*只对img/img4和表格起作用*/ vertical-align: middle; /*垂直居中对齐*/ border-collapse: collapse; /* 合并边框 与 表格属性中的 cellspacing=&quot;0&quot; 一样*/ white-space: nowrap; /*将行内快元素在一行上显示*/**备注：** 前端的路上我们一起携手共进！如果转载，请标注本链接地址。` ​MIT ©杨方涛 Email:58267980@qq.com","categories":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://lzws0931.cn/categories/面试宝典/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://lzws0931.cn/tags/面试/"}]},{"title":"法门扫地僧的第一篇博文","slug":"hello-world","date":"2018-03-15T16:21:00.000Z","updated":"2018-03-19T13:54:23.732Z","comments":true,"path":"2018/03/16/hello-world/","link":"","permalink":"https://lzws0931.cn/2018/03/16/hello-world/","excerpt":"","text":"Welcome to Hexo! 纪念1234567经过三天的踩坑，走弯路，我终于把自己的技术博客搭建起来了，本博客用的是 hexo+github page 搭建起来的。买了两个域名，目前正在备案中，等审核通过，那么我就正式拥有自己的个人博客了，还没规划好做什么类型网站，等有想法初成，一定打造好自己的小窝！ 对MD文档的书写规范还不是很熟练，慢慢摸索，慢慢成长。感谢miho主题开源者: MinHow我在原来模版基础之上进行了DIY部分修改。 感谢您的到访。","categories":[{"name":"博客制作","slug":"博客制作","permalink":"https://lzws0931.cn/categories/博客制作/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://lzws0931.cn/tags/生活/"}]}]}